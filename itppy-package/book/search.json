[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Programming",
    "section": "",
    "text": "Preface"
  },
  {
    "objectID": "content/intro/intro.html#book-anatomy",
    "href": "content/intro/intro.html#book-anatomy",
    "title": "Introduction",
    "section": "Book Anatomy",
    "text": "Book Anatomy"
  },
  {
    "objectID": "content/intro/intro.html#background",
    "href": "content/intro/intro.html#background",
    "title": "Introduction",
    "section": "Background",
    "text": "Background\nUse of technology is increasing and impacting more and more domains. Most of the workforce in cities use technology for work and personal work. This provides its own challenges but also opportunities, and requirements to use those opportunities. Introduction to programming is one of those requirements.\nLearning computer programming serves few important purposes.\n\nUse technology more efficiently and resourcefully\nProvides a common language for communicating with those developing solutions\n\nBe aware of the possibilities during communication\n\nCreate your own solutions\n\nTherefore it makes sense to make introduction to computers, operating systems, computer programming and its basic applications, part of the school education than college for everyone."
  },
  {
    "objectID": "content/intro/intro.html#objectives",
    "href": "content/intro/intro.html#objectives",
    "title": "Introduction",
    "section": "Objectives",
    "text": "Objectives\nThough this book can be read to learn to program or get an independent perspective to programming, the main goal of this book is to serve as a supplement to the course taught in class. This is because for beginners learning without demonstrations adds unnecessary complexity. On the other hand, in class setup demos, experimentation and QnA decrease complexity and aid understanding.\nFor learners, this should help as reference notes to quickly find information as needed while learning and years after initial learning.\nFor instructors, this book along with slides should be helpful to teach the course. The content is available with freedom to use, modify and distribute. It should help focus efforts on creating other material (assignments, quizes, exams, labs, projects) and student interaction and monitoring.\nThe source code for the book and slides is available to edit as required. More information is at resources section at the end of this chapter.\nThe offline version for the content is available too and can be downloaded as required."
  },
  {
    "objectID": "content/intro/intro.html#content",
    "href": "content/intro/intro.html#content",
    "title": "Introduction",
    "section": "Content",
    "text": "Content\nThe attempt is to abstract the core concepts and contexts related to computer programming which acts as a framework to learn not just Python but any programming language.\nThe focus is on concretizing the framework to understand evolution of programming. The concepts involved are generally the same for most part.\nThere are certain topics which are avoided in beginner courses. These have been included with an attempt to reduce the complexity but still give enough exposure. This is with the intent that this will provide a better understanding of how developers provide solutions which eventually should improve the usage of those solutions and writing programs in general.\nThe part Overview of programming sets the outline for the book and programming in general. For those who are new to programming, this will not make sense in first reading but will clearly layout the outline for learning. Second reading is recommended after completing the remaining sections when many of the components will be understood better. This is also recommended for classroom environment, going through the overview part at the end will provide a summary and better understanding of the components compared to the coverage in initial lectures.\nSimilarly, Tools part has a lot of information which will not be useful in the beginning but becomes clearer as you progress forward in the course and use the tools.\n\nWhy Python?\n\nPopular & Generic\nPython is one of the most popular generic programming language at the moment and this increases the chances of using the language you learn programming with.\nPython is a generic programming language with contributions in almost every domain, specially compared to other languages. So chances are higher that you will find an existing solution, irrespective of the field you work in.\nAnother advantage is that there is lot of help available online as there are more users/developers.\n\nEase of use\nPython has well designed syntax which is clear and easy to write and read which makes it easy to focus on what you need the code to do.\nPython provides features like garbage collection which does the memory management in background making it easier to code."
  },
  {
    "objectID": "content/intro/intro.html#terminology",
    "href": "content/intro/intro.html#terminology",
    "title": "Introduction",
    "section": "Terminology",
    "text": "Terminology\n\nProgramming is used in context of computer programming\nProgram is used in context of computer programs\nPseudo code has been used at several places. Pseudo code is structured natural language code without using the specified syntax, to explain what the code does. Spaces, line breaks etc. are used to make it easier to understand.\nFlow diagrams are used to explain schematics of code through visualization\nSymbols\n\n[] typically used to represent optionality\n\ne.g. item[s] means ‘s’ is optional as there can be one or more item[s]\n\n&lt;&gt; is typically used as place holder\n\ne.g. cp &lt;src path&gt; &lt;dst path&gt; implies source and destination paths are to be entered as needed"
  },
  {
    "objectID": "content/intro/intro.html#sec-resources",
    "href": "content/intro/intro.html#sec-resources",
    "title": "Introduction",
    "section": "Resources",
    "text": "Resources\n\nLecture slides\n\n\nSolutions\n\n\nSource code"
  },
  {
    "objectID": "content/overview/background.html#definition",
    "href": "content/overview/background.html#definition",
    "title": "1  Background",
    "section": "1.1 Definition",
    "text": "1.1 Definition\nComputer hardware is a machine which can be configured to do several tasks as needed.\nA program, in context of computers, is a set of instructions for the computer. A program is also referred to as software.\nConfiguring the computer hardware to do some tasks to solve a problem is called programming."
  },
  {
    "objectID": "content/overview/background.html#hardware",
    "href": "content/overview/background.html#hardware",
    "title": "1  Background",
    "section": "1.2 Hardware",
    "text": "1.2 Hardware\nThere are a lot of good short videos on web which you get by searching, e.g. “how do computers work”. It is worth spending some hours on this general search given the amount of time spent with technology.\nUnderstanding everything in detail is beyond the scope. Still it is helpful to understand the flow of information and operations at a high level.\nComputers are based on binary arithmetic. Computer hardware comprises of a large number of electronic circuits which communicate with each other through electrical signals, which essentially means communicating in binary, 0 or 1. The hardware is designed to understand different sequences of binary signals to perform different tasks.\nData and instructions are stored in binary format. 1 bit is the atomic unit of storage which stores 0 or 1. Instructions are also data in terms of computer memory, but usually term “data” is used for static information other than instructions.\nAt most basic level, hardware operates using below basic elements\n\nCPU: central processing unit or processor\n\nALU (Arithmetic logic unit): operates on very small amount of binary data to perform arithmetic and logical operations\nController unit: controls the input/output signals from/to different parts of the computer\nregisters: smallest memory, closest to processing\ncache (L1, L2, L3): next level memory for preprocessing\n\nRAM: random access memory\n\nlarger than CPU cache but smaller than hard disk\nslower than CPU cache but faster than hard disk\nall data slots are equally accessible in same time\n\nHard drive: long term storage\n\nlargest in size but slowest\n\nInput/output devices: keyboard, mouse, monitor, speakers\n\n\nThe CPU decides the architecture of information flow in a computer. Architecture has 2 main components related to design of conversion to machine code\n\nInstruction set architecture (ISA) that processor follows, e.g. x86-64, ARMv8-64\nProcessing Width: maximum number of bits the processor can process at a time\n\ncurrently most CPU’s support 64 bit, earlier it was 32 bit\nthe 64 in x86-64, ARMv8-64 is 64 bit width"
  },
  {
    "objectID": "content/overview/background.html#programming-hardware",
    "href": "content/overview/background.html#programming-hardware",
    "title": "1  Background",
    "section": "1.3 Programming hardware",
    "text": "1.3 Programming hardware\nThe computer hardware understands machine code, which is in binary, but it is not feasible to write, read and modify the machine code.\nFor illustration, if 010011001010 ... is a set of instruction in binary to tell the computer to beep, in programming language you type beep, the code will be mapped to instruction in binary and sent to processor.\nTherefore programming language is needed. The key idea is to have a set of instructions in natural language which can be mapped to different set of instructions in machine code."
  },
  {
    "objectID": "content/overview/languages.html#overview",
    "href": "content/overview/languages.html#overview",
    "title": "2  Programming languages",
    "section": "2.1 Overview",
    "text": "2.1 Overview\nMachines understand machine code which is in binary and is hard to work with. While writing instructions for the machine, it is easier to understand and work with natural language like english. Therefore, a mapping is needed to translate natural language like english to machine code.\nThe general idea of mapping natural language to machine code (binary) lead to evolution of programming languages.\nThere are multiple ways to solve the mapping problem based on the intended use case. Therefore there are numerous programming languages.\nTypically a programming language refers to 2 distinct parts.\n\nSpecification: rules for writing code\n\nlexicon: allowed keywords, symbols, characters\nsyntax: rules of arranging lexicons and creating new names (variables)\nsemantics: rules to assign meaning to different combinations of lexicons and syntax\n\nImplementation: A system application that implements the specification, like Compiler or Interpreter, to convert the natural language code into machine code and execute.\n\nReferred to as ‘language engine’ henceforth.\n\n\nSome common type of language engines, applications to create this mapping or conversion are\n\nAssembler\nCompiler\nInterpreter\n\nNote that the implementation for a language, the engine, is itself a program in machine code stored on hardware. A programming language defines the mapping rules, specifications, which can be implemented using any of the above approaches, but usually a particular combination becomes more popular.\nFor example Python has many implementations. The official and most popular is CPython which is interpreter written mostly in C. There are other implementations as well, which have their own specifications which are similar but not the same.\nAnother example is C++, the specifications are maintained and revised by a central organization, The Standard C++ Foundation. Then there are various organizations that implement the compiler using the latest specifications. The GNU compiler collection (GCC), Microsoft Visual C++ (MSVC), CLang (LLVM) etc."
  },
  {
    "objectID": "content/overview/languages.html#types",
    "href": "content/overview/languages.html#types",
    "title": "2  Programming languages",
    "section": "2.2 Types",
    "text": "2.2 Types\nLanguages can be classified into below main categories in order of decreasing complexity and based on method of conversion.\n\nlow level languages\n\nassembly languages\n\nhigh level languages\n\ncompiled languages (compiler): C, C++, Go\ninterpreted languages (interpreter): shell (bash, etc.)\n\nhybrid: Python\n\nJIT: Just in Time compilation, e.g. Java, JavaScript, C#\n\n\n\n\n\n2.2.1 Assembly languages\nAssembly languages have very limited set of specifications and are difficult to code in. They are machine specific and used to provide basic configuration to hardware, e.g. BIOS setup on computers. They are closest to the hardware and hence provide access to all components. They are very fast as they are directly translated to machine code using an assembler and specifications to be checked and converted are very limited.\nSince there are very few mappings, every instruction has to be explicit, therefore the code written in assembly language is much longer compared to that in high level languages.\n\n\n2.2.2 High level languages\nHigh level languages is the next step in the mapping problem. They define their own set of specifications (lexicon, syntax and semantics) to provide a lot more features for writing programs, e.g. data types, control flow mechanisms, ways to define functions and objects, managing storing data on memory, managing input/output etc.\nFor example in C/C++ memory management and data types have to be dealt with by the programmer manually, but in Python a lot of these features are provided as default where programmer does not have to deal with them.\nSince there are many pre-built instructions built in, the code written in high level languages tend to be shorter.\n\n2.2.2.1 Compiled languages\nCompiled languages solve the mapping problem using a compiler.\nThe compiler reads the whole program and converts it to machine code before execution. This process is also referred to as Ahead of time compilation (AOT).\nThe compiler is dependent on 3 major factors\n\nhardware architecture (this is dependent on CPU primarily)\n\ninstruction set: x86, ARM64, …\nprocessing size: 64 bit or 32 bit\n\nOperating system (OS)\n\nTherefore compiled languages like C/C++ have compilers available for most common architecture and OS combinations. The compiled machine code produced is different for different combinations.\n\nPros\n\nfast\n\nmachine code is generated as standalone output\n\n\nCons\n\nPortability\n\nhave to be compiled for different OS + Hardware combinations\nthis is more of an inconvenience, as compilers for most popular combinations are available\n\nDifficulty\n\ncompared to hybrid interpreter languages which are higher level with more features towards ease of use\nhave higher development time, takes more time to code\n\n\n\n\n\n\n\n\n\nHow to write the compiler itself?\n\n\n\nThis seems to be a chicken and egg problem but it is not. Imagine there are no high level languages available and the first compiler for C language has to be written. The first compiler can be written in assembly language on a given system. This gives the machine code for C compiler. But now you can write compiler for any high level language in C and get the machine code for that compiler by compiling it with C compiler. From there on any compiler can be written in any compiled language and turned to machine code for needed systems.\n\n\n\n\n2.2.2.2 Interpreted languages\nThe interpreter produces machine code at run time and can run code interactively. Interpreter takes care of system architecture and OS dependencies so can be run on any machine as long as the interpreter can be installed on that machine.\nInterpreters are of different types depending on implementation for a language. In simplest form they execute one instruction at a time, like most shell programs do, e.g. bash or zsh.\n\n2.2.2.2.1 Hybrid\nLanguages like Java, C# and CPython (Official and most used Python version) use a hybrid approach. The mapping is done in 2 main steps\n\ncompilation step: source code is checked and compiled into intermediate bytecode\ninterpreter step: the bytecode is interpreted into machine code and run at runtime\n\nThe run time behavior is still same as interpreter, in the sense that machine code is produced at run time rather than at compile time.\n\nPros\n\nPortability\n\nsame program can be run on different machines by just installing the language interpreter\n\nEase of use\n\ngenerally these languages are higher than compiled languages than C, C++\ntime to write code is reduced\n\n\nCons\n\nSlower\n\nprogram is converted to machine code at run time\nthis depends on the use case, specially considering the increase in hardware capacity, for most of common tasks this can be ignored\n\n\n\n\n2.2.2.2.1.1 JIT\nSome implementations of some languages use just in time compilation (JIT) to optimize the interpreter.\nThe key idea is to compile certain pieces of code to optimized machine code at run time.\nThis is more of an optimization technique for increasing speed, but this is still slower compared to compiled languages.\nExamples of language implementations that use JIT:\n\nJava: Java Virtual Machine (JVM)\nC#: Common language runtime (CLR)"
  },
  {
    "objectID": "content/overview/languages.html#popular-languages",
    "href": "content/overview/languages.html#popular-languages",
    "title": "2  Programming languages",
    "section": "2.3 Popular languages",
    "text": "2.3 Popular languages\n::: {.cell hash=‘languages_cache/html/unnamed-chunk-2_c7637beb7b6358ca3748ce7957bb6ec3’}\n\n\n\n\n\n\n\n\n\n\n\nUse Case\n\n\n\n\nPython\n\n\n\n\nR\n\n\n\n\nJavaScript\n\n\n\n\nC\n\n\n\n\nC++\n\n\n\n\nJava\n\n\n\n\n\n\n\nAutomation\n\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\n\n\n\n\n\nData analysis\n\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\n\n\n\n\n\nScientific Computing\n\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\n\n\n\n\n\nWeb dev\n\n\n\n\n\nx\n\n\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\n\n\n\nSystem App dev\n\n\n\n\n\nx\n\n\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\n\n\n\nMobile App dev\n\n\n\n\n\nx\n\n\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\n\n\n\nCloud dev\n\n\n\n\n\nx\n\n\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\n\n\n\nNetwork dev\n\n\n\n\n\nx\n\n\n\n\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\nx\n\n\n\n\n:::\n\n2.3.1 Desktop & Mobile applications\nMajor operating systems create their own language and frameworks to develop applications to run on the os. This is changing now to target cross platform development, i.e. application built using a framework + language combination can be built for multiple devices and OS, just like compilers.\nFrameworks are an extra layer of functionalities and ways of binding them for a specific hardware architecture + os combination. For example, for creating graphical user interfaces building blocks are prebuilt and can be glued into the main application program without having to write them from scratch.\nThe OS specific languages and platforms are now shifting to being cross platform.\n::: {.cell hash=‘languages_cache/html/unnamed-chunk-3_b109e958db69bc11c7e0c3260f37b551’}\n\n\n\n\n\n\n\n\nLanguage\n\n\n\n\nDevice\n\n\n\n\nOS\n\n\n\n\nFramework\n\n\n\n\n\n\nC#, Visual Basic, F#\n\n\n\n\nDesktop\n\n\n\n\nWindows (Microsoft)\n\n\n\n\n.NET, XAMARIN\n\n\n\n\n\n\nSwift\n\n\n\n\nDesktop, Mobile\n\n\n\n\nMacOS, IOS (Apple)\n\n\n\n\nSwiftUI\n\n\n\n\n\n\nC++\n\n\n\n\nCross-platform\n\n\n\n\nCross-platform\n\n\n\n\nQT\n\n\n\n\n\n\nDart\n\n\n\n\nCross-platform\n\n\n\n\nCross-platform\n\n\n\n\nFlutter\n\n\n\n\n\n\nJava\n\n\n\n\nCross-platform\n\n\n\n\nCross-platform\n\n\n\n\nMultiple frameworks\n\n\n\n\n\n\nKotlin\n\n\n\n\nCross-platform\n\n\n\n\nCross-platform\n\n\n\n\nMultiple frameworks\n\n\n\n\n:::\n\n\n2.3.2 Websites (web dev)\nWeb technologies have become popular with the creation and development of browsers and web networks.\n\nFront end (GUI) is based on HTML, CSS and JavaScript\nBackend functionalities: like databases, analytics can be developed in language of choice\n\nIn practice there are many frameworks available for development which provide standard templates of pre built code for different functionalities.\n::: {.cell hash=‘languages_cache/html/unnamed-chunk-4_fa7b5d9cbff4fbc3d3e312d467842004’}\n\n\n\n\n\n\nName\n\n\n\n\nDescription\n\n\n\n\n\n\nHTML\n\n\n\n\nMarkup language to structure user interface structure and text\n\n\n\n\n\n\nCSS\n\n\n\n\nResponsible for the user interface styling\n\n\n\n\n\n\nJavaScript\n\n\n\n\nResponsible for the functionality behind web pages, e.g. click button actions, form submissions, …\n\n\n\n\n\n\nTypeScript\n\n\n\n\nStricter version of Javascript which is static typed\n\n\n\n\n:::\nHow do browsers run code?\nBrowsers are primarily running JavaScript using their own set of mapping engines.\nEarlier the browser JavaScript engines were using interpreter approach but now have shifted to JIT approach like Java.\n\nGoogle Chrome: V8 engine\nMozilla Firefox: SpiderMonkey\nApple Safari: JavaScriptCore\nMicrosoft Edge: Chakra\n\n\n\n2.3.3 General purpose\n\n2.3.3.1 C and C++\nC and C++ are very popular compiled languages for writing high performance code. They provide access to most of the functionality hardware has to offer. Most of the critical applications like operating systems, compilers, virtual machines are written in C/C++.\nThese have the steepest learning curve as the programmer has to know the how the hardware works to use these languages and most of the interactions like managing data stored on RAM, directing CPU for parallel processing have to be coded by the programmer.\nC is the older among the two with lesser features available. Everything has to be built from scratch or using some one elses code.\nC++ is a newer version of C with OOP, few changes in syntax and a lot more features. Also C++ is under active development.\nBoth are compiled languages and compilers are available from various sources, most common being GNU GCC, which is a collection of compilers for different hardware architecture and OS combinations.\nAlthough these are not used directly in all use cases but much of the functionality under the hood uses these for performance reasons. For example, much of the libraries for scientific computing and data analysis in languages like Python and R are developed using C/C++ and a wrapper is implemented in Python or R. All major operating systems are written using C/C++ in part or in full.\n\n\n2.3.3.2 Python\nPython is a general purpose programming language. The official and most common version of Python that is used and covered in this course is implemented in C, and therefore also referred to as CPython.\nPython is very popular language with applicability in most of the application areas. Also it has a lot of pre built code available for majority of the regular tasks."
  },
  {
    "objectID": "content/overview/languages.html#programming-paradigms",
    "href": "content/overview/languages.html#programming-paradigms",
    "title": "2  Programming languages",
    "section": "2.4 Programming paradigms",
    "text": "2.4 Programming paradigms\n\nA programming paradigm defines the approach or style of solving problems through programming.\n\nProgramming paradigms are grouped into 2 main categories.\n\nImperative: focusses on how to solve the problem\n\nProcedural programming\nObject oriented programming\nStructured programming\n\nDeclarative: focusses on what to solve\n\nLogic programming\nFunctional programming\nData driven programming\n\n\nA language, through design of specifications and implementation, can support one or more of paradigms.\nAlmost all popular programming languages support multiple paradigms and hence the term multi-paradigm is used. e.g Python, C, C++, Java, Javascript etc.\nFor example, in Python, a problem can be solved using loops, functional programming or OOP. Python provides all the options."
  },
  {
    "objectID": "content/overview/languages.html#general-structure",
    "href": "content/overview/languages.html#general-structure",
    "title": "2  Programming languages",
    "section": "2.5 General structure",
    "text": "2.5 General structure\nThis is an attempt to structure all knowledge related to programming, including practical aspects.\n\nLanguage specifications\n\nBuilding blocks: specifications for elements and blocks of code\nArchitecture: specifications for writing programs\n\nmeans and specifications to combine elements and blocks to build programs\nmanagement of execution of blocks (under the hood)\n\n\nDesign: knowledge of how to write good programs\nTools: needed to write, test, debug and run programs\n\n\n\n\n\n\n\nLanguage specification\n\n\n\n\n\n\n \n\n\n\n\n\n\n\nBuilding blocks\n\n\n\n\nBasic specifications\n\nLexicons\nVariables\nComments\n\nData types and operations\nControl flow blocks\nFunctions\nOOP\nSpecial features\n\n\n\n\n \n\n\n\n\n\n\n\nArchitecture\n\n\n\n\nEnvironment = Namespace + Scope\nScripts and packages\nExternal packages\nLanguage engine\nDebugging\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\nDesign\n\n\n\n\nComponents\n\nDesign patterns\n\nMap reduce\n\nDSA\nRegular expressions\n\nFrameworks\nWorkflow\n\n\n\n\n \n\n\n\n\n\n\n\nTools\n\n\n\n\nCommand line interface\nVersion control system\nLanguage installation\n\nEngine\nExternal packages\nVirtual environments\n\nEditor\n\n\n\n\n\nAlmost all programming languages can be fitted to this generic structure/framework, therefore getting started with any language will become easier if you keep this structure in mind. This book is structured to follow this structure as well.\nThe wiki link provides a comparison of different languages where you can use this structure to look for relevant basic syntax.\nThe implementation and implications will differ for some pieces from language to language which you learn by experience in coding in it as use case arise. For example, in Python you do not need to worry about hardware management as it is taken care by the interpreter, but in C/C++ you have to manage them yourself. The scope rules are different from language to language."
  },
  {
    "objectID": "content/overview/languages.html#underlying-concepts",
    "href": "content/overview/languages.html#underlying-concepts",
    "title": "2  Programming languages",
    "section": "2.6 Underlying Concepts",
    "text": "2.6 Underlying Concepts\nThe 3 basic concepts (means of abstraction, encapsulation and combination) have been foundational in development of computer science from hardware to software. Once you start seeing this pattern in every aspect of definition of a programming language, you will understand and implement programming better.\n\n\n\n\n\n\nUnderlying concepts\n\n\n\n\nMeans of abstraction\n\nbuilding blueprints of data, operations, functionality, …\n\nMeans of encapsulation\n\nhiding details of implementation\n\nMeans of combination\n\nusing basic data structures to create compound data\ncombine basic functions to build bigger functionality\n\n\n\n\n\n2.6.1 Means of Abstraction\nAbstraction in general means to isolate ideas or concepts from actual physical reality. In other words it is a process of generalizing physical phenomenon without worrying about the details around it. Below are examples to understand application of abstraction in programming.\nProgramming language is itself built on this idea where abstract specification is isolated from actual implementation. For example C++ language specification is provided and maintained by a group of people. The actual implementation of the compiler can be done by anyone using those specifications. Therefore there are many C++ compilers available like GCC, LLVM etc.\nData types have evolved by isolating the specification and implementation. Interfaces, or abstract data types (ADT), define general desired properties a certain data type should possess. Data structure with algorithms provide a concrete implementation for an interface. For example, dictionary is an ADT while Python dict is a data structure with algorithms for different operations. The performance of a dictionary in CPython might differ from a dictionary in C++ or even JPython (Implementation of Python VM using Java).\nFunctional programming uses this idea in many different ways. Example 1, map, filter and reduce are general concepts related to a collection of items, the actual output depends on the function supplied while using the concept. Example 2, factory functions provide a blueprint of functionality, the arguments supplied decide the actual function created.\nObject oriented programming (OOP) is built around this idea where class is an abstract blueprint of an object and instance is the actual object which depends on the data it holds.\n\n\n2.6.2 Means of Encapsulation\nEncapsulation in general means hiding the details of implementation.\nProgramming language: hides the details of mapping problem, which is the actual implementation of the engine, and lets the programmer create new solutions using natural language, rules and syntax without worrying about details of implementation of compiler, hardware management etc.\nData types: Once a data type is implemented you can create multiple instances without worrying about the details of implementation. For e.g. most languages provide way of defining numbers and strings by directly entering them without worrying about implementation details of how and where to store the data.\nFunctional programming: Once a function is created you can use them as and when required without worrying about the implementation details during usage.\nObject oriented programming (OOP): Classes provide a way to define blue prints of objects with certain attributes. After that multiple instances of the data type can be created and operated upon without worrying about the implementation details during usage.\n\n\n2.6.3 Means of Combination\nCombining in general means joining. In programming it means the same, ways to combine simple parts to make a more complex part and make it simple using encapsulation.\nProgramming language is built around the same concept, smaller pieces are the elements of specification like lexicons and syntax, then semantics and architecture defines ways to combine them to make more complex programs.\nData types: Data structures like tuple, list, dictionaries etc. provide means of combining different data types to create arbitrarily larger and more complex data.\nFunctional programming: Using the rules of scopes and namespaces functions can be joined and nested in many interesting ways to create more complex functions.\nObject oriented programming (OOP): Class itself allows combining data and operations to create arbitrarily large and complex data types as needed. Further more rules of inheritance provide ways of relating class definitions to create and structure even more complex data types."
  },
  {
    "objectID": "content/overview/applications.html#embedded-devices",
    "href": "content/overview/applications.html#embedded-devices",
    "title": "3  Applications",
    "section": "3.1 Embedded Devices",
    "text": "3.1 Embedded Devices\nAcross industries more and more robotic devices are in use for automation of manual tasks. Most of this is done using assembly languages and C/C++ by embedding the final machine code in the robotic device itself."
  },
  {
    "objectID": "content/overview/applications.html#operating-systems",
    "href": "content/overview/applications.html#operating-systems",
    "title": "3  Applications",
    "section": "3.2 Operating Systems",
    "text": "3.2 Operating Systems\nMajor operating systems like Microsoft Windows, Apple Mac, Linux distributions are built with C/C++.\nMobile devices have their own operating systems like Google’s Android and Apple’s IOS. These are written in multiple languages but use C heavily.\nOS provides a default set of operations to interact with the hardware. There are several smaller applications to interact with components of hardware\n\ninput devices: keyboard, mouse, camera, microphone\noutput devices: display, speakers\nnetwork devices\nhard disk: file system\n\nAll the smaller applications are glued by the operating system and a graphical user interface is provided to interact with the hardware. This is done through desktop applications like file manager, text editor, photo viewer etc."
  },
  {
    "objectID": "content/overview/applications.html#cli-terminal-shell",
    "href": "content/overview/applications.html#cli-terminal-shell",
    "title": "3  Applications",
    "section": "3.3 CLI = Terminal + Shell",
    "text": "3.3 CLI = Terminal + Shell\nTerminal is the first layer of interaction provided by the os. Terminal is a text based user interface (tui) application which hosts a shell program. Shell program is an interpreter running the commands written in shell language. Terminal and shell programs are mostly written in C/C++ too. Terminal and shell together provide the command line interface or CLI. CLI is covered in detail in Tools part of the book in Chapter 5."
  },
  {
    "objectID": "content/overview/applications.html#desktop-applications",
    "href": "content/overview/applications.html#desktop-applications",
    "title": "3  Applications",
    "section": "3.4 Desktop applications",
    "text": "3.4 Desktop applications\nExamples of desktop applications are the file manager, media viewer etc. A desktop application is simply a program that can run on the os and provide means to perform certain tasks.\nSome are provided by the os as default applications while others like Adobe’s Acrobat, Photoshop etc. are provided by companies. In addition individual developers and group of developers can provide desktop applications through Windows app store or Apple store. Linux distributions have their own app stores.\nMicrosoft Office applications (word, excel, powerpoint, access database) are written in C/C++.\nLibreOffice is the free version of Microsoft Office which is developed using multiple languages like C++, Java, XML, Bash, SQL, etc."
  },
  {
    "objectID": "content/overview/applications.html#databases",
    "href": "content/overview/applications.html#databases",
    "title": "3  Applications",
    "section": "3.5 Databases",
    "text": "3.5 Databases\nDatabases are applications which specialize in storage, maintenance and operations on data. Most of them are built using C or C++.\n\n\n\n\n\n\n\n\n\n\nName\nType\nFree\nLanguage\n\n\n\n\nMySQL\nSQL\nYes\nC, C++\n\n\nPostgreSQL\nSQL\nYes\nMultiple\n\n\nRedis\nNoSQL, Key-value\nYes\nC, ANSI C\n\n\nSQLite\nSQL, Embedded\nYes\nC\n\n\nCassandra\nNOSQL, Wide-column\nYes\nJava\n\n\nOracle database\nMultiple\nNo\nC, C++, Assembly\n\n\nSQL Server\nSQL\nMixed\nC, C++, C#\n\n\nMicrosoft Access\nSQL\nMixed\nC++\n\n\nMongoDB\nNoSQL, Document\nMixed\nMultiple"
  },
  {
    "objectID": "content/overview/applications.html#websites",
    "href": "content/overview/applications.html#websites",
    "title": "3  Applications",
    "section": "3.6 Websites",
    "text": "3.6 Websites\nWeb technologies have become popular with the creation and development of browsers and web networks.\n\nFront end (GUI) is based on HTML, CSS and JavaScript\nBackend functionalities: like databases, analytics can be developed in language of choice\n\nIn practice there are many frameworks available for development which provide standard templates of pre built code for different functionalities.\n::: {.cell hash=‘applications_cache/html/unnamed-chunk-3_c9ec6e49f67214c2fa5c61bbad1dadd9’}\n\n\n\n\n\n\nName\n\n\n\n\nDescription\n\n\n\n\n\n\nHTML\n\n\n\n\nMarkup language to structure user interface structure and text\n\n\n\n\n\n\nCSS\n\n\n\n\nResponsible for the user interface styling\n\n\n\n\n\n\nJavaScript\n\n\n\n\nResponsible for the functionality behind web pages, e.g. click button actions, form submissions, …\n\n\n\n\n\n\nTypeScript\n\n\n\n\nStricter version of Javascript which is static typed\n\n\n\n\n:::\nHow do browsers run code?\nBrowsers are primarily running JavaScript using their own set of mapping engines.\nEarlier the browser JavaScript engines were using interpreter approach but now have shifted to JIT approach like Java.\n\nGoogle Chrome: V8 engine\nMozilla Firefox: SpiderMonkey\nApple Safari: JavaScriptCore\nMicrosoft Edge: Chakra"
  },
  {
    "objectID": "content/overview/applications.html#mobile-applications",
    "href": "content/overview/applications.html#mobile-applications",
    "title": "3  Applications",
    "section": "3.7 Mobile Applications",
    "text": "3.7 Mobile Applications\nMobile applications for Android and IOS are like desktop applications but designed to use limited resources of mobile. These are primarily oriented to use touch input.\nGoogle play and Apple store host applications developed by companies, individuals and group of developers."
  },
  {
    "objectID": "content/overview/applications.html#data-analysis",
    "href": "content/overview/applications.html#data-analysis",
    "title": "3  Applications",
    "section": "3.8 Data Analysis",
    "text": "3.8 Data Analysis\nWith the continuous increase in volume of data collected, data analysis & visualization, artificial intelligence, machine learning are getting developed and used heavily for analysis and decision making.\nPython and R are the languages used in this field as there is a lot of dependence on scientific computing, statistics and math.\nBasic data analysis is helpful for everyone using technology across all domains.\nChapter 25 introduces data analysis in more detail."
  },
  {
    "objectID": "content/overview/applications.html#automation",
    "href": "content/overview/applications.html#automation",
    "title": "3  Applications",
    "section": "3.9 Automation",
    "text": "3.9 Automation\n\n3.9.1 Documentation\nThere are tools like Quarto available to automate documentation in multiple output formats. Quarto is based on Pandoc which is an application written in Haskell programming language for conversions between different markup languages. Quarto uses Pandoc’s markdown syntax which makes writing documents as easy as writing text in a word processor or notepad. Content once written can be exported to different formats, html based website, pdf, word etc. This book has been written using Quarto.\n\n\n3.9.2 System tasks\nShell and Python scripts are used to automate a large number of system tasks both for personal and official work.\nTask can be as simple as creating a backup of your important files to more complex tasks to create templates of a project or task which you can create with automatic time and date stamps and other content pre-filled.\nThis book therefore introduces system task automation later as an application of programming."
  },
  {
    "objectID": "content/overview/learning-map.html#introduction",
    "href": "content/overview/learning-map.html#introduction",
    "title": "4  Learning map",
    "section": "4.1 Introduction",
    "text": "4.1 Introduction\nAcquiring knowledge of any subject involves answering 3 fundamental questions.\n\nWhy? Most fundamental question that teaches the motivation\nWhat? Declarative knowledge that teaches the definition\nHow? Imperative knowledge that teaches ways to apply the knowledge\n\nSimilarly to learn computer programming you can use the below map.\n\nWhy do you learn computer programming? \\(\\to\\) Use cases\nWhat is computer programming? \\(\\to\\) Theory: Building blocks, Architecture, Design\nHow do you do computer programming? \\(\\to\\) Practical experience: Tools, Application\n\nLearning theory equip you with knowledge about the subject, but to develop skill in the subject you need the tools and practical experience of applying the knowledge.\nWhile covering theory, there is an attempt to provide exposure to some common scenarios of where and how to apply the concepts along with some common mistakes. Topic of design is related to this. Whereas by experience, you get better at the skill of deciding what concepts to apply under which situations.\nFor example, there are limited specifications of a language which you can learn quickly, but there are much larger possible ways to combine them. Operating systems, language compilers and interpreters have been written using the same specifications, without even using OOP, which is related to the skill of writing programs (applying theory in practice). For basic usage it is not required to have skills to write an operating system, but the example is to illustrate the difference between the “what” and “how” parts above.\nThe learning map, in context of depth of knowledge, will depend on the career path. There are 3 distinct possible career paths in context of programming.\n\nGeneric: Basic\nSTEM (minus CSE): Intermediate\nComputer science & Engineering (CSE): Advanced\n\n\nSTEM =&gt; Science, Technology, Engineering & Math related fields"
  },
  {
    "objectID": "content/overview/learning-map.html#basic",
    "href": "content/overview/learning-map.html#basic",
    "title": "4  Learning map",
    "section": "4.2 Basic",
    "text": "4.2 Basic\nThere are some common elements of programming which can be the starting point for all career paths.\n\nIntroduction to programming with basic applications (this book)\nBasics of data analysis\n\n\n4.2.1 Theory\nAs a beginner, you learn the basics of any one programming language. Python is chosen in this book as it is most popular generic programming language.\nThis book covers the basics and some intermediate topics in detail. Additionally, some intermediate and advanced topics are introduced, but not covered in detail, to improve the understanding of context while programming, but keeping the complexity low.\n\nColor coding rules used\n\ncovered in detail\nhigh level introduction\nnot covered\n\n\n\n\n\n\n\n\nLanguage specification\n\n\n\n\n\n\n \n\n\n\n\n\n\n\nBuilding blocks\n\n\n\n\nBasic specifications\n\nLexicons\nVariables\nComments\n\nData types and operations\nControl flow blocks\nFunctions\nOOP\nSpecial features\n\n\n\n\n \n\n\n\n\n\n\n\nArchitecture\n\n\n\n\nEnvironment = Namespace + Scope\nScripts and packages\nExternal packages\nLanguage engine\nDebugging\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\nDesign\n\n\n\n\nComponents\n\nDesign patterns\n\nMap reduce\n\nDSA\nRegular expressions\n\nFrameworks\nWorkflow\n\n\n\n\n \n\n\n\n\n\n\n\nTools\n\n\n\n\nCommand line interface\nVersion control system\nLanguage installation\n\nEngine\nExternal packages\nVirtual environments\n\nEditor\n\n\n\n\n\n\n\n4.2.2 Applications\n\nAutomation\n\nsystem operations\ndocumentation\n\nBasics of data analysis (including visualization)\nDomain specific basic applications"
  },
  {
    "objectID": "content/overview/learning-map.html#intermediate",
    "href": "content/overview/learning-map.html#intermediate",
    "title": "4  Learning map",
    "section": "4.3 Intermediate",
    "text": "4.3 Intermediate\nMost of the science and engineering fields require heavy usage of data science which requires good practical programming skills along with math involved, specially probability and statistics.\nIn context of programming, the assumption is you would know the basics (content of this book) and move on to learn intermediate level theory. The topics will be same but study will be intermediate to advanced level. For example, details of OOP, design patterns like generators, context managers, etc. and how to implement them from scratch.\nIn addition it would be good to learn a compiled language like C++, with lower level details like memory management and parallel processing.\nThe key aim will be to be able to build basic domain specific packages and applications using frameworks if required.\n\nTheory\n\nprogramming (intermediate level)\ndata science (intermediate level)\nmath: probability & statistics to model data\n\nApplication\n\ndata analytics\nbuilding domain specific packages\nbuilding basic applications using frameworks"
  },
  {
    "objectID": "content/overview/learning-map.html#advanced",
    "href": "content/overview/learning-map.html#advanced",
    "title": "4  Learning map",
    "section": "4.4 Advanced",
    "text": "4.4 Advanced\nIn terms of theory there will be advanced coverage of topics depending on specialization.\n\nMath for computer science\nLanguage specification, implementation & design\nData structures & Algorithms\nDesign patterns\nFrameworks\n\nIn terms of application the path will depend on the choices.\n\nEmbedded devices\nOperating systems\nDesktop applications\nMobile applications\nDatabases\nWebsites\nNetwork applications\nMedia\n…"
  },
  {
    "objectID": "content/tools/tools-overview.html#background",
    "href": "content/tools/tools-overview.html#background",
    "title": "Overview",
    "section": "Background",
    "text": "Background\nTo be able to use any of the tools a computer with an operating system is required. Computers come with 2 major commercial operating system options are Windows and Mac. Then there are a large number of free (in context of price) and open source Linux (Unix based) distributions. Mac is itself based on Linux so has similar workflow as other Linux distributions. Newer windows machines can run a Linux distribution using wsl or a virtual machine.\nWith the evolution of programming, there has been evolution of tools to write and execute programs. Learning these tools is not a one time task and takes time."
  },
  {
    "objectID": "content/tools/tools-overview.html#introduction",
    "href": "content/tools/tools-overview.html#introduction",
    "title": "Overview",
    "section": "Introduction",
    "text": "Introduction\nBelow is an overview of main tools used with their primary uses in context of programming.\n\nOperating system\n\nCommand line interface (CLI)\n\nmanage files\nbuild and run files and projects\nmanage system installations and updates\n\nVersion control system (VCS): manage history of changes\nPython:\n\nCPython installation: interpreter, built-ins, standard library\nExternal packages\n\nEditor: compilation of tools needed in one place"
  },
  {
    "objectID": "content/tools/tools-overview.html#resources",
    "href": "content/tools/tools-overview.html#resources",
    "title": "Overview",
    "section": "Resources",
    "text": "Resources\nLinux foundation offers a course, Introduction to Linux. This should provide a good background on how an operating system provides an interface to work on a computer. There are some parts of the course, example bash scripting, which should be referred to after getting some experience with programming.\nMIT Course: The Missing Semester of Your CS Education covers the tools needed. You can refer to cli and Vim (editor) part ignoring what seems advanced or irrelevant.\nThese can be considered as an optional pre-requisites."
  },
  {
    "objectID": "content/tools/tools-overview.html#objectives",
    "href": "content/tools/tools-overview.html#objectives",
    "title": "Overview",
    "section": "Objectives",
    "text": "Objectives\nThe chapters in this part provide background and introduction to these tools, to help get started and act as notes for reference in the beginning. There are a lot of choices for each of the tools, some recommendations are provided.\nThere is a lot of learning involved with the tools, specially cli and editor, as there is a lot of functionality and it keeps evolving. Therefore it makes sense to start gradually, focus on using the features when needed, research when there is spare time.\nUsage, e.g. configuration of advanced editors like NeoVim, requires knowledge of programming. Therefore just an introduction to the tools is provided to act as quick start guides, to use them while learning to program. Once you learn to program, you can learn more about the tools using reference to resources provided and also do an independent research.\n\n\nCLI\nBasic usage of CLI is independent from programming. The built-in commands can be used as is for normal tasks while working on a computer. These are included.\nScripting is typically used to automate repetitive tasks. The scripting part can be learnt gradually after introduction to programming as the requirements arise. The Bash manual and the Linux course should be enough to get to a decent stage.\n\n\nVCS\nGit is introduced here to provide a high level introduction for familiarity and basic usage.\nAfter learning basics of Git, you can start experimenting with it using CLI. For example, initialize a rough repository for the files you create while learning this content and create some commits, view logs. Once you move to editor you can use the integrated gui support for Git.\nVCS is typically used for large coding projects and in practical set up has a lot more to it. Actual details will depend on the set up, which you can learn if needed.\n\n\nPython\nInstallation and management of Python and external packages is a requirement for programming with Python and will be used throughout.\n\n\nJupyter notebooks\nJupyter notebooks are introduced to do experiments by executing small pieces of code in isolation with annotation, like while learning the building blocks.\nAlthough experimentation with small pieces of code can be done using a regular Python script, Jupyter notebooks provide an extra option with other functionality like basic documentation, interactively view data and visualization, required for data analysis.\n\n\nEditor\nEditor is used after learning about scripts and packages in Architecture part.\nIt is the main tool to do programming, so it will be used throughout."
  },
  {
    "objectID": "content/tools/cmd-line.html#overview",
    "href": "content/tools/cmd-line.html#overview",
    "title": "5  Command line interface",
    "section": "5.1 Overview",
    "text": "5.1 Overview\n\n5.1.1 Introduction\nThere is a lot of ambiguity in terminology. Terminal is an old term which refers to a physical interface to access the system. Console and tty is also often used in similar context, tty derives its name from hitorical tele typewriter machine.\nTerminal emulator is a generic term for an application to provide text input/output environment.\nShell is a generic term for an interpreter that provides commands to interact with the system.\nTerminal emulator and the shell program together provide command line interface, aka cli, to interact with the system (hardware, processes, applications, …) using text based interface.\nCompared to graphical user interface (gui) based interaction with the system, cli is much faster and more powerful, once you learn it.\n\n\n\n5.1.2 Terminal Emulator\nEvery operating system gives a default and often is called terminal.\n\nWindows\n\nWindows Console Host: old\nWindows Terminal: latest (as of 2023)\n\nLinux: default depends on the version\nMac: has its own default terminal emulator referred to as terminal\n\n\n\n5.1.3 Shell\nThere are several popular shells for Linux based systems.\n\nWindows: command prompt (cmd), powershell\nLinux: bash, zsh, fish, …\nMac: earlier it was bash, now (as of 2023) it is zsh\n\n\n5.1.3.1 Bash\nbash is the default shell on most linux based operating systems and is available across all operating systems.\n\nLinux: default on most distributions\nMac: earlier bash was default, latest is zsh, extension of bash\nWindows: easily accessible through wsl, cygwin, git/gitbash\n\n\n\n5.1.3.2 What do shell programs do?\nShell provides commands and scripts to manage system.\n\nHardware (monitor, keyboard, mouse, network, camera, …)\nProcesses (logon, startup, users, security, …)\nApplications (browser, file explorer, …)\nFile system (create/delete/rename/move files and folders)\n\nScripts contain commands and variables, combined using the language specifications, as any other programming language. Scripts behave as other commands and can be used from cli.\n\n\n5.1.3.3 Use cases\nSome examples of where cli is used.\n\n5.1.3.3.1 Managing Workflow\n\nFiles and directory operations\nInstallation, update, maintenance of applications (software)\nAutomation\n\n\n\n5.1.3.3.2 System Administration\n\nFiles and directory operations\nInstallation, update, maintenance of applications (software)\nAutomation\nSecurity: Group and user access\nManaging databases, servers, processes\n\n\n\n\n5.1.3.4 Note\nMost of the tasks that can be done from command line can be done with Python but understanding command line will help use Python better.\n\n\n\n\n\n\n\nCaution\n\n\n\nCommand line can be dangerous as one wrong command can destroy a large chunk of your work or even bring the system down.\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n… and this happens more frequently with experienced users"
  },
  {
    "objectID": "content/tools/cmd-line.html#bash-1",
    "href": "content/tools/cmd-line.html#bash-1",
    "title": "5  Command line interface",
    "section": "5.2 Bash",
    "text": "5.2 Bash\n\n5.2.1 Resources\n\nHomepage\nBash manual\n\n\n\n5.2.2 Setup\nInstallation depends on operating system.\n\nLinux distributions: bash is available and default on most distributions\nMacOS: zsh is the default but bash is available\nWindows: git comes with gitbash which should be enough\n\nFor windows, Git is covered in the next chapter. There are some other options for installing bash on windows, msys2, cygwin, wsl.\n\n\n5.2.3 Configuration\nThere are certain aspects which are driven by the terminal emulator program. These are colors, fonts, terminal related keyboard shortcuts, windows and tabs management etc. These are configured directly through terminal program.\nBash configurations involve\n\nEnvironment: What are the default variables like $PATH, $HOME etc. available\nPrompt: What information does the prompt show\nHistory: How and where history is saved\nAliases: Short codes for frequently used commands\n\nSuch settings are configured through .bashrc, .bash_profile, .bash_aliases files which are stored in $HOME path, which depends on operating system.\nActual configuration has more details to it and more configuration files. Additionally there are dependencies on the operating system. To learn more, it is advisable to do web search based on OS.\n\n\n5.2.4 Commands\nBash is an interpreter that runs tasks using the concept of commands which are usually short codes (functions) to do certain task. They can optionally take flags, options and (positional) arguments.\n\n5.2.4.1 General format\n&lt;command name&gt; [-flag[s]] [-option[s][=/ ]value[s]] [&lt;argument[s]&gt;]\n\nCommand name: are scripts containing code to perform tasks\n\ne.g. ls prints files and folders contained in a folder\ncomes first\n\nFlags (Switches): are short codes to alter the behavior of the program\n\nmultiple flags can be combined\nit is safer to combine and provide all flags before any options and arguments\ne.g. ls -al changes the way ls command lists the files and folders\n\nnote that a and l are 2 flags combined\nls -a -l works as well\n\n\nOptions: are codes that take value\n\ne.g. head -n=15 &lt;file path&gt; prints starting 15 lines of the given file\noptions can use = or space, e.g. head -n 15 &lt;file path&gt; works\n\nArguments: inputs to the command interpreted based on position\n\ne.g. cp &lt;src&gt; &lt;dst&gt;: first argument is provided to source to be copied from and second to destination where to copy\n\n\nThe flags and options additionally have long and short forms. e.g.\n\nls -l --all \\(\\iff\\) ls -al\n\nThere are many variations to how flags, options and arguments can be positioned. The allowed placements vary by commands as well. The safe rule of thumb is\n\nBeginning (after command name): combine flags using short forms\nMiddle: options\nEnd: arguments\n\n\n\n5.2.4.2 Types\nCommands can be grouped into below types\n\nbuilt-ins: present by default\n\nman, less, ls, cp, mv, mkdir, rm, find, grep, …\n\ncommand line utilities\n\nmany applications give command line utility commands\ne.g. create a Python virtual environment\n\npython3 -m venv &lt;path to virtual environment&gt;\n\n\ncustom scripts: create your own\n\nBash, like other shell programs, have its own scripting language which can be used to create scripts. Bash scripts end with .sh extension and can be run using\nbash &lt;custom_script_name&gt;.sh command.\nThis is basic way to run scripts. There are advanced ways using file permissions which can be avoided in the beginning.\nBelow are some common commands based on category of tasks.\n\n\n5.2.4.3 Summary\n\nhelp: man, &lt;cmd_name&gt; --help\nlist and print: ls, pwd, echo, | less\nchange directory: cd\ncreate file/directory: touch, mkdir\nremove file/directory: rm\nmove/rename file/directory: mv\n\n\n\n5.2.4.4 Getting help\n\nsearch web by use-case\nwithin terminal: man &lt;command name&gt;\n\nman man\nto sroll and search man man | less\n\non windows/git-bash man will not work\n\n&lt;command name&gt; --help\n\ncheck installation location\n\nwhich &lt;app name&gt;\n\n\n\n\n5.2.4.5 List and Print\n\nlist files and folders: ls\nlist all files and folders: ls -a\nlist all files and folders in long format: ls -al\nprint current directory: pwd\nprint to console: echo \"content\"\n\n\n\n5.2.4.6 File & Folder\n\n5.2.4.6.1 Change directory\n\nchange directory 1 level up: cd ..\n\nchange directory 2 level up: cd ../..\n\ncd &lt;relative dir path&gt;\ncd &lt;absolute dir path&gt;\ntab completion\n\n\n\n5.2.4.6.2 Create\n\ncreate file: touch &lt;file-path&gt;\n\ndirectory should exist\n\ncreate directory: mkdir &lt;dir-path&gt;\ncreate directory and intermediate directories if does not exist:\n\nmkdir -p &lt;dir-path&gt;\n\n\n\n\n5.2.4.6.3 Remove\n\nremove file: rm &lt;file path&gt;\nremove empty directory: rm -r &lt;dir path&gt;\nremove non-empty directory: rm -rf &lt;dir path&gt;\n\n\n\n5.2.4.6.4 Copy\n\ncopy file:\ncp &lt;src file path&gt; &lt;dst file path&gt;\ncopy source dir with its content recursively:\ncp -r &lt;src dir path&gt; &lt;dst dir path&gt;\ncopy only contents of source dir to destination recursively:\ncp -r &lt;src dir path&gt;/. &lt;dst dir path&gt;\n\n\n\n5.2.4.6.5 Move (rename)\n\nmove/rename: mv &lt;src&gt; &lt;dst&gt;\n\nsrc = old file/directory name\ndst = new file/directory name\nif the src and dst path are\n\ndifferent =&gt; move\nsame =&gt; rename\n\n\n\n\n\n\n\n5.2.5 Keyboard shortcuts\n\n\n\n\n\n\n\n\nMain\n\n\n\n\nclear: ctrl-l (L)\nquit: ctrl-d\ncopy: ctrl-shift-c\npaste: ctrl-shift-v\n\n\n\n\n\n\n\n\n\nDelete\n\n\n\n\ndelete till end (from cursor): ctrl-k\ndelete till start (from cursor): ctrl-u\n\n\n\n\n\n\n\n\n\n\n\n\nMovement\n\n\n\n\nmove to start: ctrl-a\nmove to end: ctrl-e\n\n\n\n\n\n\n\n\n\nProcesses\n\n\n\n\ncancel (kill) running jobs: ctrl-c\nput current process in background: ctrl-z\n\n\n\n\n\n\n\n\n\n\n\nHistory\n\n\n\n\nview history: history\nrun command from history: !&lt;#&gt;\nput command from history: !&lt;#&gt;:p\nsearch previous command: ctrl-r\n\nkeep pressing ctrl-r to go through search list"
  },
  {
    "objectID": "content/tools/vcs.html#introduction",
    "href": "content/tools/vcs.html#introduction",
    "title": "6  Version control system: Git",
    "section": "6.1 Introduction",
    "text": "6.1 Introduction\nVersion control system, aka VCS or source control, is a software to maintain history of changes to a project, in context of folders, files and content of files.\nIn context of programming projects, a vcs is used for code and config files needed to reproduce a project. All the information is stored in a compressed directory.\nMajor use cases for a VCS are\n\nTrack: history of changes with related information\nRollback: in case needed\nCollaborate: changes to different parts can be made in parallel and merged\n\nSome popular VCS are\n\nGit\nApache Subversion\nMercurial\n\nThis book covers Git as it is most popular. Getting familiar with vcs through cli should help with the following\n\nBasic usage of vcs without branching\nIntroduce how basic things work without gui\nUnderstand and use gui tools better\nThere are few complex tasks that can only be done from cli, when needed\n\nThere are gui tools in most editors so most of the interaction is through them.\nTo learn Git in-depth, refer to Pro Git. It is recommended to go through first 2 sections of the book to understand the basic fundamentals and operations.\nA VCS is complemented by an online (cloud) service for hosting repositories. There are several different online providers with their own set of functionalities.\n\nSourceForge: supports multiple VCS\nGitHub: supports git only\nGitLab: supports git only\nBitBucket: supports multiple VCS\n\nThe key ideas behind working of Git are summarized in the first section of Pro Git, which is highly recommended."
  },
  {
    "objectID": "content/tools/vcs.html#git-cli",
    "href": "content/tools/vcs.html#git-cli",
    "title": "6  Version control system: Git",
    "section": "6.2 Git CLI",
    "text": "6.2 Git CLI\nBelow is a summary of common Git cli commands based on use cases.\n\n6.2.1 Config\n\nCheck Git config\n\ngit config --list --show-origin\n\nSetup username and email for Git\n\nmandatory after fresh installation\nthese are stamped for each commit to track who made changes\n\n\ngit config --global user.name \"name\"\ngit config --global user.email \"email@example.com\"\n\n\n6.2.2 Initialize repository\ngit init\nThe above command is run from the folder to be version controlled.\nWhen a repository is initialized\n\n.git folder is created which is the repository\nAll files and sub-folders are tracked by default\n\nAdd .gitignore to ignore tracking certain files and folders\n\n\n\n\n6.2.3 Check status and logs\ngit status --short\ngit log --oneline\n\n\n6.2.4 Add changes to staging area\ngit add &lt;file or dir path&gt;\n\n\n6.2.5 Commit\n\n6.2.5.1 Using text editor\ngit commit\n\nOpens the default text editor to enter message and commit the staged changes\n\nin this case first line will be the short message\nremaining typed lines will form the detailed message\n\n\n\n\n6.2.5.2 Quick commit\ngit commit -m \"message text\"\n\n\n6.2.5.3 Stage all changes and commit\ngit commit -am \"message text\"\n\nStage all changes\nCommit the staged changes with short message\nIn the -a option no need to add files separately\n\n\n\n\n6.2.6 Check differences\n\n6.2.6.1 Since last commit\ngit diff\n\n\n\n6.2.7 Undo changes from last commit\ngit restore &lt;file name&gt;\n\nDiscard changes to file in working directory"
  },
  {
    "objectID": "content/tools/python.html#installation",
    "href": "content/tools/python.html#installation",
    "title": "7  Python",
    "section": "7.1 Installation",
    "text": "7.1 Installation\nPython installation resources and instructions, based on operating system, are available at the official website.\n\nDownload installer\nInstructions\n\nUnix\nMac\nWindows\n\n\nPython installation includes\n\nCPython interpreter\nPre built Python objects, scripts and packages with additional functionality\n\nBuilt-ins\nStandard library\n\n\n\n7.1.1 Check Python installation from bash\n\nWindows\n\npy --list-paths\n\nLinux/Mac: there are several methods one of which is given below\n\nls -ls /usr/bin/python*"
  },
  {
    "objectID": "content/tools/python.html#ways-to-runinteract-with-python",
    "href": "content/tools/python.html#ways-to-runinteract-with-python",
    "title": "7  Python",
    "section": "7.2 Ways to run/interact with Python",
    "text": "7.2 Ways to run/interact with Python\n\nRepl\n\nIPython repl: enhanced version of default Python repl\n\nJupyter notebooks\nRun scripts from command line\nRun scripts from editor\n\nPython repl and jupyter notebooks are covered in this part. The later two are included in the architecture part of the book."
  },
  {
    "objectID": "content/tools/python.html#python-repl",
    "href": "content/tools/python.html#python-repl",
    "title": "7  Python",
    "section": "7.3 Python repl",
    "text": "7.3 Python repl\nrepl = read evaluate print loop\nrepl is a tool to interact with the interpreter.\nTo start a repl simply type python3/py in bash and press enter, actual command will depend on the operating system and python version.\nrepl is rarely used directly, instead editors use it under the hood to provide functionalities like running and debugging the code. Below are some reasons why this is the case.\n\nrepl does not save work\nnot designed write large programs as it does not have all the tools needed\n\nIt is useful in conjunction with editor, to test code short pieces of code or while debugging.\nIPython repl is newer modern repl. To use ipython instead of default repl, ipython has to be installed. To use it from editor, additional configuration is needed."
  },
  {
    "objectID": "content/tools/python.html#pip",
    "href": "content/tools/python.html#pip",
    "title": "7  Python",
    "section": "7.4 pip",
    "text": "7.4 pip\nThe Python Package Index (PyPI) is a repository of packages (collection of Python programs) written for use in Python programming language. pip is one of the listed packages.\nThe term package here has special meaning, more than just a regular or namespace package used in Python programming. Package here refers to collection of Python scripts and packages for distribution. In the beginning, details can be avoided, but when needed refer to Python docs: Installing packaging.\npip is the package installer for Python which manages the installation and maintenance of other external packages contributed by developers. It has its own independent website with all the details. pip website.\nTypically pip is included in Python installation but you can check using bash with any of the below commands.\n\n\n\npip -V\n\n\npip -h\n\n\npip --help\n\n\n\n\n7.4.1 Usage\nTo install or update refer to installation guide. Once pip is installed it is easy to install any external package from cli, pip install &lt;package name&gt;, e.g.\npip install jupyterlab\nAlthough above works in most cases, it is advisable to use full command with Python version, as given below. This takes care of edge cases when there are multiple Python installations on a pc. Each Python installation can have its own pip or not. Using the below form of installation command ensures relevant pip is used and installation is done in the specified installation. The below command is explicit, use python3 installation’s pip and install jupyterlab into python3 installation. If python3 does not have pip installed, it will give error asking to install pip first.\nIn general use python installation path. For system installation, python3 for example links to the path directly. For virtual environments, explicit path is needed.\npython3 -m pip install jupyterlab\nWhen working with virtual environments, which are discussed later (Section 18.4), it is safer to use the below form of command. For Unix based systems (Linux/BSD/MAC)\n&lt;venv path&gt;/bin/python3 -m pip install jupyterlab\n\n\n7.4.2 Requirements file\nOne of the important feature of pip is to manage a project’s dependencies, through a requirements.txt file. In this book, this is discussed in section on virtual environment in architecture. There is a section dedicated in the official documentation, link to requirements section."
  },
  {
    "objectID": "content/tools/jupyter.html#overview",
    "href": "content/tools/jupyter.html#overview",
    "title": "8  Jupyter notebooks",
    "section": "8.1 Overview",
    "text": "8.1 Overview\n\n8.1.1 Introduction\nJupyter is an independent project that provides\n\nJupyter Notebooks: interactive code cells, markdown text, tables, plots, latex math formulas\nJupyter Lab: web-based interactive development environment (editor)\nJupyter Hub: multi-user version of notebooks\n\nJupyter notebook is new version of interactive python notebook that have extension .ipynb, which is still used.\n\n\n8.1.2 Objectives\nIn this book intent is to provide notes and references to get started with jupyter notebooks using jupyter lab. Note that jupyter notebooks can be used independent from jupyter lab. There are other editors which support using jupyter notebooks, e.g. VSCode, RStudio etc.\n\n\n8.1.3 Resources\nJupyter project’s website has extensive documentations for further learning."
  },
  {
    "objectID": "content/tools/jupyter.html#installation",
    "href": "content/tools/jupyter.html#installation",
    "title": "8  Jupyter notebooks",
    "section": "8.2 Installation",
    "text": "8.2 Installation\nJupyter notebook can be installed independently but it is recommended to install jupyter lab which contains notebook and related dependencies. Link to help page.\n&lt;python installation path&gt; -m pip install jupyterlab\nRefer to pip usage section (Section 7.4.1)."
  },
  {
    "objectID": "content/tools/jupyter.html#features",
    "href": "content/tools/jupyter.html#features",
    "title": "8  Jupyter notebooks",
    "section": "8.3 Features",
    "text": "8.3 Features\n\nRun code interactively\nMix rich text, code and results using markdown and code cells\nExport results in different formats like html, pdf, word etc."
  },
  {
    "objectID": "content/tools/jupyter.html#use-cases",
    "href": "content/tools/jupyter.html#use-cases",
    "title": "8  Jupyter notebooks",
    "section": "8.4 Use cases",
    "text": "8.4 Use cases\n\nInteractive programming for quick trials or learning with annotation\nReproducible Research: quick and easy sharing of ideas/analysis with code and results"
  },
  {
    "objectID": "content/tools/jupyter.html#keyboard-shortcuts",
    "href": "content/tools/jupyter.html#keyboard-shortcuts",
    "title": "8  Jupyter notebooks",
    "section": "8.5 Keyboard Shortcuts",
    "text": "8.5 Keyboard Shortcuts\n\n\n\nadd cell\n\nbelow: b\nabove: a\n\nchange cell type\n\nmarkdown: m\ncode: y\n\n\n\n\ncut cell: x\ncopy cell: c\npaste cell below: p\nenter/exit cell edit mode: enter/esc\n\n\n\n\nrun cell: Ctrl + Enter\nrun cell and move to cell below: Shift + Enter"
  },
  {
    "objectID": "content/tools/jupyter.html#markdown",
    "href": "content/tools/jupyter.html#markdown",
    "title": "8  Jupyter notebooks",
    "section": "8.6 Markdown",
    "text": "8.6 Markdown\nMarkdown is a markup language which provides simple syntax for text to be converted to different formats. It is used extensively by many tools which try to automate documentation, e.g. quarto, pandoc, github, jupyter notebooks and many more. Each have their own subtle variations, but are very similar as the root is markdown.\nMarkdown syntax is easy and quick to learn.\n\n8.6.1 Syntax cheat sheet\n\n\n\n\n\n\n\n\nDescription\nSyntax\n\n\n\n\nHeading\n# H1\n## H2\n### H3\n\n\nBold\n**bold text**\n\n\nItalic\n*italicized text*\n\n\nBlockquote\n&gt; blockquote\n\n\nOrdered List\n1. First item\n2. Second item\n3. Third item\n\n\nUnordered List\n- First item\n- Second item\n- Third item\n\n\nTask List\n- [x] task 1 (checked)\n- [ ] task 2\n- [ ] task 3\n\n\nCode\n`code`\n\n\nHorizontal Rule\n---\n\n\nLink\nmarkdown [title](www.example.com)\n\n\nImage\n![alt text](image.jpg)\n\n\nStrikethrough\n~~This text is striked.~~\n\n\nSubscript\nH~2~O\n\n\nSuperscript\nX^2^\n\n\nMath: inline\n$e = mc^2$\n\n\nMath: display\n$$e = mc^2$$"
  },
  {
    "objectID": "content/tools/editor.html#overview",
    "href": "content/tools/editor.html#overview",
    "title": "9  Editor",
    "section": "9.1 Overview",
    "text": "9.1 Overview\n\n9.1.1 Introduction\nEditor combines most of the tools and functionality needed for programming in one interface. Therefore, it is the tool which is used most while programming.\n\n\n9.1.2 Background\nAs the programming languages evolved, so did the tools, specially editors. Historically there were two primary types of editors, text based lightweight editors (e.g. Emacs, Vim, Nano, Atom) and full fledged integrated development environments or IDE’s (e.g. Visual Studio, IntelliJ Idea).\nIDE’s were loaded with lot of features for developers, but used a lot of CPU and RAM. IDE’s conventionally were designed for use with specific languages and provided a lot of features for development in that language. IDE’s were focussed towards ease of use to attract developers towards specific platforms and frameworks.\nThe text based editors were lightweight with less features but generic. Text based editors have evolved to be able to be configured to as IDE while being generic, they can be configured for use with almost any programming language. e.g. VSCode (based on Atom), Emacs, NeoVim (Based on Vim). Emacs was an exception, it was light weight by default, but provided extensibility to configure it as much more powerful than a conventional IDE, but that required good programming skills in Lisp (programming language).\nCurrently (as of 2023) the boundary is blurred because of technologies like language server protocol (lsp). For example, VSCode, a text editor based on Atom, is light weight but can work like an IDE using extensions (plugins) without much knowledge of programming. Emacs and NeoVim are also similar but not as easy to configure, but once you know programming then they can be configured to be much more powerful.\nPlugins or extensions are pieces of code to add some functionality to a computer application.\n\n\n9.1.3 Features\nBelow are some features that an editor can have. Some are independent of programming language and some depend on the programming language.\nEven features that are specific to a programming language, need initial configuration specific to the programming language. Post that much of the interaction in editor, like keyboard shortcuts and commands, remain the same.\nTherefore, it makes sense to choose an editor which has support for most languages.\n\n\n\n \n\n\n\n\n\n\n\nCommon features\n\n\n\n\nUser interface\n\nthemes\nwindows\nframes\n\nEditing\n\ntabs/spaces\nfolding\nmultiple cursors\nkeybindings\n\nOutline\n\nproject files\nvcs\nextensions\n\nTerminal\nProjects & Workspaces\nVersion control\n\n\n\n\n \n\n\n\n\n\n\n\nLanguage specific features\n\n\n\n\nSyntax highlighting\nAuto\n\ncompletion\nformatting\nlinting\nrefactoring\nsnippets\nhelp/documentation\n\nObject browser\nDebugger\nCompile/build/run\nTesting\n\n\n\n\n\n\n\n9.1.4 Options\nThere are a lot of editors available. There are some editors specific to a language and some are generic. Below are examples of some popular editors.\nIt makes sense to use a generic editor as it reduces effort while using multiple languages. This is because you can leverage the learning involved for language independent common features. Some popular open source options are listed below with features.\n\n9.1.4.1 Python Specific\n\nPyCharm\nSpyder\nRStudio\n\n\n\n9.1.4.2 Generic\n\n9.1.4.2.1 Vim\n\nHomepage\nPlain text editor\nSteep learning curve\nModal key bindings are powerful\nUseful for quick changes directly from terminal\nExtensions are available for additional functionality\nNeoVim is based on Vim\n\nadvanced features\noffers extensibility with Lua programming language\nneorg, inspired by Emacs org mode, under development\n\nFaster than most other editors\nWorks from cli\n\n\n\n9.1.4.2.2 Emacs\n\nHomepage\nVery powerful and hackable using emacs lisp language\nSteep learning curve\nSpacemacs (a modified distribution of Emacs) is a good blend of vim keybindings and emacs\nExtensions are available for additional functionality\n\n\n\n9.1.4.2.3 VSCode\n\nWorks out the box\nEasy to configure\nEasy to use\nSupports Jupyter notebooks\nHighly configurable\nLight weight\nSupports most of the languages\nSupports most of functionality required\nExtensions available for additional functionality"
  },
  {
    "objectID": "content/tools/editor.html#recommendation",
    "href": "content/tools/editor.html#recommendation",
    "title": "9  Editor",
    "section": "9.2 Recommendation",
    "text": "9.2 Recommendation\nVSCode is recommended to begin programming with, specially because of ease of use in getting started.\nKeybindings in VSCode can be configured. It is recommended to learn and use Vim key bindings. Learning Vim keybindings will help using Vim when needed. VSpaceCode extension is useful as it includes Vim keybindings and additionally allows integration of all keybindings in more mnemonic style."
  },
  {
    "objectID": "content/tools/editor.html#resources",
    "href": "content/tools/editor.html#resources",
    "title": "9  Editor",
    "section": "9.3 Resources",
    "text": "9.3 Resources\nVSCode is well documented at VSCode docs. Below are recommended sections to get started.\n\nSetup\n\nKeybindings\n\nIntroductory video series\nPython setup\nProfiles\n\nAs you progress you can learn and use more features using the documentation."
  },
  {
    "objectID": "content/building-blocks/bb-overview.html#background",
    "href": "content/building-blocks/bb-overview.html#background",
    "title": "Overview",
    "section": "Background",
    "text": "Background\nLearning a programming language starts with learning the specifications of elemenatary pieces or building blocks.\n\nLanguage specifications\n\nBuilding blocks: specifications for elements and blocks of code\nArchitecture: specifications for writing programs\n\nmeans to combine elements and blocks to build programs\nmanagement of execution of blocks behind the scenes\n\n\nDesign: knowledge of how to write good programs\nTools: needed to write, test, debug and run programs"
  },
  {
    "objectID": "content/building-blocks/bb-overview.html#introduction",
    "href": "content/building-blocks/bb-overview.html#introduction",
    "title": "Overview",
    "section": "Introduction",
    "text": "Introduction\nBuilding blocks comprise of following elements which provide the basic elements to write code.\n\nBasic specifications\n\nLexicons: allowed symbol\nVariables: mechanism of storing and re-using information\nComments: annotating code\n\nData types and operations: storing and operating on numbers, strings, collections\nControl flow blocks\n\nConditional exectution blocks: if-elif-else, match-case\nLoops (Iteration): for, while\n\nFunctions: re-use code with configurable inputs\nObject Oriented Programming (OOP): re-use predefined type of data and associated operations\nSpecial features: Python specific extra features\n\nConditional expressions: short-circuit, context aware evaluation\nComprehensions: special short syntax to combine transformation iteration filter"
  },
  {
    "objectID": "content/building-blocks/bb-overview.html#objectives",
    "href": "content/building-blocks/bb-overview.html#objectives",
    "title": "Overview",
    "section": "Objectives",
    "text": "Objectives\nBuilding blocks are introduced with related specifications (lexicons, syntax, semantics). Examples are provided to demonstrate implications of the specifications to demonstrate experimentation. Specifications are limited and easy to understand, implications are a lot as they grow with application and combination of the specifications.\nBuilding blocks can be combined in multiple directions to solve problems. Multiple direction means a conditional block can contain a function, and a function can contain a conditional block. Therefore there are multiple ways to combine different elements, but not are same in terms of readability elegance and efficiency.\nThe objectives for this part are to\n\nLearn specifications (lexicons, syntax, semantics) for the building blocks\n\nUnderstand semantic specifications and their implications\ndo experiments in isolation\n\nIntroduce basic examples of combining different building blocks\nTools: Jupyter notebook in editor (VSCode or Jupyter lab)"
  },
  {
    "objectID": "content/building-blocks/basics.html#objects",
    "href": "content/building-blocks/basics.html#objects",
    "title": "10  Basics",
    "section": "10.1 Objects",
    "text": "10.1 Objects\nIn Python everything is an object stored on RAM (random access memory), and is looked up using object reference that is a memory address on RAM.\nObjects are fundamental to object oriented programming, which will be covered in the OOP section.\nObject stores information in attributes which are of 2 fundamental forms.\n\ndata attributes\noperations\n\nTo understand the idea think of an object as object = data + operation where,\n\ndata = noun and operation = verb\ndata = state and operation = behavior\n\nFor example, consider an integer “text” stored as an object in Python. It has data type attributes like value which is the “text” and numerous operations like capitalize which returns another string “Text”. The actual implementation has more details, this is simplification of the general concept.\nData attributes are responsible for storing the information that defines the state of an object.\nEvery object has special data attribute which defines what type of object it is. In Python it is __class__.\nOperations are other type of attribute, which provide functionality. They are functions with some additional features and are often referred to as methods.\n\n10.1.1 dot operator\nDot operator .gives access to object’s attributes, data and operations.\n\nnum_1 = 1.5\n\n\nnum_1.as_integer_ratio()\n\n&gt;&gt;&gt;  (3, 2)"
  },
  {
    "objectID": "content/building-blocks/basics.html#variables",
    "href": "content/building-blocks/basics.html#variables",
    "title": "10  Basics",
    "section": "10.2 Variables",
    "text": "10.2 Variables\n\n10.2.1 Introduction to variables\nVariables are named references that provide a handle to the object. They are stored separately on RAM in a separate table called namespace.\nNamespaces are mapping between variable names and reference to objects which can be used to lookup memory address of the object.\nNote that memory address is not constant, the language interpreter stores created objects at available memory address and deletes them when not needed. On many occasions the memory address will change, e.g. re running a program. That is where variables and namespaces come in.\nVariables provide handle to objects for\n\nreuse and passing around objects\nperforming operations\n\nIn Python, variable are defined using the = operator.\nWhen a variable is defined for example\nsome_var = \"some text\"\n\na string type object \"some text\" is created in RAM which has some_id\nsome_var variable name is bound to \"some text\" object created\n\nthis is referred to as name binding\n\nvariable name some_var and memory address of object \"some text\" are stored in a namespace\n\nBelow figure illustrates the relationship between a variable name and object.\n\n\n\nOnce the language interpreter sees what type of object it is, it knows what is the structure of data and operations stored in the object. Hence, the associated variable name has access to the attributes.\n\n\n10.2.2 Deciding variable names\n\n10.2.2.1 Must-follow\n\ncase sensitive\nstart with _ or letter (a-z A-Z)\nfollowed by any number of _, letters or digits\ncannot be one of reserved words\n\nBelow code can be used to check keyword list in Python.\nimport keyword\nprint(keyword.kwlist)\n::: {.cell hash=‘basics_cache/html/unnamed-chunk-4_b2fda5d47bc1f38c97584e045b16237b’}\n\n\nPython keywords (35)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFalse\n\n\n\n\nNone\n\n\n\n\nTrue\n\n\n\n\nand\n\n\n\n\nas\n\n\n\n\nassert\n\n\n\n\nasync\n\n\n\n\n\n\nawait\n\n\n\n\nbreak\n\n\n\n\nclass\n\n\n\n\ncontinue\n\n\n\n\ndef\n\n\n\n\ndel\n\n\n\n\nelif\n\n\n\n\n\n\nelse\n\n\n\n\nexcept\n\n\n\n\nfinally\n\n\n\n\nfor\n\n\n\n\nfrom\n\n\n\n\nglobal\n\n\n\n\nif\n\n\n\n\n\n\nimport\n\n\n\n\nin\n\n\n\n\nis\n\n\n\n\nlambda\n\n\n\n\nnonlocal\n\n\n\n\nnot\n\n\n\n\nor\n\n\n\n\n\n\npass\n\n\n\n\nraise\n\n\n\n\nreturn\n\n\n\n\ntry\n\n\n\n\nwhile\n\n\n\n\nwith\n\n\n\n\nyield\n\n\n\n\n:::\n\n\n10.2.2.2 Should-follow\n\n_my_var: names starting with single underscore\n\nused for private or internal objects\nnot exported by from module import *\n\navoid using names with dunder\n\n__my_var: names starting with double underscore\n\nused to mangle class attributes in class chains\n\n__my_var__: names starting and ending in double underscore\n\nsystem defined names used in class internal attributes\n\n\n\n\n\n10.2.2.3 PEP-8 Conventions\nPEP refers to Python enhancement proposals which have detailed documentation about the rationale and description of changes to Python language specifications.\nPEP-8 is related to Python code styles and is highly recommended read. Below are the conventions suggested for variable names. These will be used all through the course with few exceptions.\nFollowing these conventions makes the code readability and understanding the code easy for both the writer and users.\n\n\n\n\n\n\n\n\nObject Type\nConvention\nExample\n\n\n\n\nPackages\n\nshort\nall-lowercase names\npreferably no underscores\n\nutilities\n\n\nModules\n\nshort\nall-lowercase names\ncan have underscores\n\ndb_utils.py or dbutils.py\n\n\nClasses\nupper CamelCase\nBankAccount\n\n\nClass instances\nlower snake_case\nbank_account\n\n\nFunctions\nlower snake_case\nmy_func\n\n\nVariables\nlower snake_case\nmy_var\n\n\nConstants\nupper SNAKE_CASE\nMY_CONST\n\n\nDummy variables\nunderscore\n_\n\n\n\n\n\n\n10.2.3 Python features\n\n10.2.3.1 Dynamic type\nIn Python, variable type do not need to be declared and same variable can be bound to different type of objects.\nThis is leads to terms like Python is a dynamically typed language.\nOpposite to dynamic type is strict type, e.g. C, where once a variable is declared to point to string objects it can only store string objects.\n\nsome_var = 10\nsome_var = \"some text string\"\n\n\nprint(f'{some_var=}')\n\n&gt;&gt;&gt;  some_var='some text string'\n\n\nVariable type can be declared for assistance and code readability, but does not enforce the type, which means it can be bound to other object type.\nIt is not recommended to declare type and then use different type of object.\nPEP-487 has more detailed discussion around this.\n\nsome_var:str = \"some text string\"\nsome_var:int = 10\n\n\nprint(f'{some_var=}')\n\n&gt;&gt;&gt;  some_var=10\n\n\n\n\n10.2.3.2 Multiple assignment\nTo exchange values of a set of variables you do not need temporary assignments. Below examples illustrates this.\n\na = 10; b = \"some text\"; c = [\"this\", \"is\", \"a\", \"list\"]\n\n\nprint(f'{a=}, {b=}, {c=}')\n\n&gt;&gt;&gt;  a=10, b='some text', c=['this', 'is', 'a', 'list']\n\n\n\na, b, c = c, a, b\n\n\nprint(f'{a=}, {b=}, {c=}')\n\n&gt;&gt;&gt;  a=['this', 'is', 'a', 'list'], b=10, c='some text'"
  },
  {
    "objectID": "content/building-blocks/basics.html#commonly-used-syntax",
    "href": "content/building-blocks/basics.html#commonly-used-syntax",
    "title": "10  Basics",
    "section": "10.3 Commonly used syntax",
    "text": "10.3 Commonly used syntax\n\n10.3.1 Comments (#)\nComments are text within code which is not evaluated and is used for documentation and code readability.\nThere are 2 basic rules related to comments.\n\npython ignores and does not parse/evaluate the line content after #\ncannot use # just after assignment operator =\n\n\n10.3.1.1 Examples\n\n10.3.1.1.1 Example 1\nBelow is simple usage to document the code.\n# Enter the value of inputs below\nx = 10\ny = 20\n\n# Calculate sum\nz = x + y\n\n\n10.3.1.1.2 Example 2\nIn the example below, variable num_in_comment gives an error while trying to print on line 2 because line 1 is commented and not evaluated, therefore there is no variable num_in_comment in namespace.\n\n# num_in_comment = 10\nprint(num_in_comment)\n\n&gt;&gt;&gt;  Error: NameError: name 'num_in_comment' is not defined\n\n\n\n\n10.3.1.1.3 Example 3\nBelow example illustrates incorrect usage of # after =.\n\nsome_num = # value on next line\n10\nprint(some_num)\n\n&gt;&gt;&gt;  invalid syntax (&lt;string&gt;, line 1)\n\n\n\n\n\n\n10.3.2 Newline\n\nNew lines can be introduced in multiple ways\n\nexplicit method\n\nbreak lines using \\\njoin lines using ;\n\nimplicit method: Expressions within (), [], {}\n\ncan be broken into multiple lines\ncan contain comments\ncan have trailing commas\n\n\nNew line syntax can be used to enhance code readability\n\n\n10.3.2.1 Explicit method example\nsome_var_1 = 10\nsome_var_2 = 20\nsome_var_3 = 30\nsome_var_4 = 40\nif some_var_1 &gt; 5 and some_var_2 &gt; 10 and some_var_3 &gt; 20 and some_var_4 &gt; 30:\n    print('yes')\nWhen the code becomes too long to fit or is too short it is useful to use explicit method to join or break lines to improve code organization and readability.\nsome_var_1 = 10; some_var_2 = 20\nsome_var_3 = 30; some_var_4 = 40\n\nif some_var_1 &gt; 5 and some_var_2 &gt; 10 \\\n    and some_var_3 &gt; 20 and some_var_4 &gt; 30:\n    print('yes')\n\n\n10.3.2.2 Implicit method example\nExpressions in (), [] or {} can be split into multiple lines without needing explicit use of backslash (\\). Optionally they can contain comments.\nNote that trailing commas are allowed, illustrated in second example.\n\n\n\na = (\n    \"item 1\",\n    \"item 2\",\n    \"item 3\"\n)\n\n\na = [\n    1, # first item\n    2, # second item\n    3, # third item\n    ]\n\n\n\n\n\n\n10.3.3 Blocks (indentation)\nPython uses indentation to isolate distinct blocks, like control flow blocks (if, while), functions (def), classes (class). This improves code readability.\nIndentation can be made using special tab characters or spaces. It is recommended to use 4 spaces and is generally a good choice. Below is an example, to illustrate how indentation improves code readability.\nimport math\ndef calc_circle_area(r=1, pi=math.pi):\n    if r &lt; 0:\n        print(\"radius should be &gt;= 0\")\n    else:\n        return pi*(r**2)\nEditors allow you to choose the method and amount of indentation to use. So in VSCode it is recommended to set it to 4 spaces. “Editor: Tab Size” is the relevant setting which is documented at link."
  },
  {
    "objectID": "content/building-blocks/basics.html#functions",
    "href": "content/building-blocks/basics.html#functions",
    "title": "10  Basics",
    "section": "10.4 Functions",
    "text": "10.4 Functions\nThis section provides introduction to some basic functions which will be used to explain some underlying concepts in topics that follow.\nFocus on\n\nunderstand at high level what information the function provides\ngetting a hang of running code in jupyter notebooks\nusing variable assignment\n\nIgnore the details of f'' string formats for now, they are there for formatting output. They will be covered later.\n\n10.4.1 type\n\ntype(): returns object type\n\n\nvar_1 = 10\nvar_2 = 10.0\nvar_3 = \"string\"\n\n\ntype(var_1), type(var_2), type(var_3), type(10.2)\n\n&gt;&gt;&gt;  (&lt;class 'int'&gt;, &lt;class 'float'&gt;, &lt;class 'str'&gt;, &lt;class 'float'&gt;)\n\n\n\n\n10.4.2 id\n\nid(): returns object memory reference id\n\nhex() just converts to hexadecimal for better readability\n\n\n\n_string_1 = \"some text\"\n\n\nid(_string_1), hex(id(_string_1))\n\n&gt;&gt;&gt;  (140305212559088, '0x7f9b5a5acef0')\n\n\n\n\n10.4.3 is\na is b: check if a and b refer to same object\nThis means checking if the memory address of the given variables or objects is same.\nIn the example below a list object [10] is created and both a and b are bound to the same object. Therefore a is b returns true.\n\na = b = [10]\n\n\nprint(f'{a is b = }\\n{hex(id(a))=}\\n{hex(id(b))=}')\n\n&gt;&gt;&gt;  a is b = True\n&gt;&gt;&gt;  hex(id(a))='0x7f9b7051c440'\n&gt;&gt;&gt;  hex(id(b))='0x7f9b7051c440'\n\n\nIn the example below a list object [10] is created and variable a is bound to that object. Then variable b is bound to the object that a is bound to.\n\na = [10]\nb = a\n\n\nprint(f'{a is b = }\\n{hex(id(a))=}\\n{hex(id(b))=}')\n\n&gt;&gt;&gt;  a is b = True\n&gt;&gt;&gt;  hex(id(a))='0x7f9b6efa6fc0'\n&gt;&gt;&gt;  hex(id(b))='0x7f9b6efa6fc0'\n\n\nSince [10] is a list type object, even though c and d assignments look the same, they point to different objects.\n\nc = [10]\nd = [10]\n\n\nprint(f'{c is d = }\\n{hex(id(c))=}\\n{hex(id(d))=}')\n\n&gt;&gt;&gt;  c is d = False\n&gt;&gt;&gt;  hex(id(c))='0x7f9b7051c440'\n&gt;&gt;&gt;  hex(id(d))='0x7f9b5a5b0b40'\n\n\nAbove examples illustrate subtle points about variable and object bindings which lead to a lot of implications while using mutable and immutable objects. This is covered in more detail in next section on data types and rest of the book."
  },
  {
    "objectID": "content/building-blocks/basics.html#modules-and-import",
    "href": "content/building-blocks/basics.html#modules-and-import",
    "title": "10  Basics",
    "section": "10.5 Modules and import",
    "text": "10.5 Modules and import\nModules in Python refer to different things, based on context.\n\na file with .py extension containing Python code\nan object once a .py file or package is imported using import statement\n\nPackages are special type of modules, a folder containing Python files.\nOne of the important use-case of these specifications is to use external code. Python standard library has a lot of built in functionality for various use cases. The modules and packages contained in the standard library can be imported and used as required.\nImport system in Python provides ways of managing objects in code and files. This is introduced here for basic usage in examples. All this is covered in detail in Architecture part.\nIn the example below,\n\nmath module is imported using import statement\nobjects: data and definitions are accessed using dot operator\n\n\nimport math\n\nprint(math.pi)\n\n&gt;&gt;&gt;  3.141592653589793\n\nprint(math.ceil(10.2))\n\n&gt;&gt;&gt;  11"
  },
  {
    "objectID": "content/building-blocks/data-types.html#introduction",
    "href": "content/building-blocks/data-types.html#introduction",
    "title": "11  Data types",
    "section": "11.1 Introduction",
    "text": "11.1 Introduction\nData type refers to object types that store information and provide some operations on that information.\nCompare a function and a number, both are objects but a function stores code and numbers stores numeric data primarily. That is why, function, class etc. are not referred to as data types like int or float which are numeric data types.\nData types are the most critical part of any language. They are used to store, access and operate upon information within code.\nNumbers and text are the most fundamental data types.\nSome languages like C, distinguish between characters and strings, where strings are treated as sequence of characters. Python has just strings for text, which are a sequence of characters, and can be a sequence of single character.\nThen there are collections which provide ways to combine objects to create more complex data. Data types like list, dictionary etc. are provided in higher level languages. Every high level language has its own implementations and syntax with differences, but underlying design principles are the same.\nData Structures and Algorithms part of the book gives a high level background of how the data designs have evolved.\n\n11.1.1 Overview\nBelow tree provides an overview of data types implemented in Python with categories.\n\nThe nodes with red text are the data types which are builtin in Python and are covered in the book\nThe nodes with blue text are data types available by loading from standard library\n\n\nStandard library is discussed in architecture part of the book: Section 18.2\n\n\nCollection is generally used for collection of objects, and it can be compounded, collection of collection of objects.\nSequence type is a collection of objects with preserved order. In base Python, strings, tuples and lists are sequence type.\nSequences can be mutable or immutable.\nIterable is any collection of objects from which objects can be retrieved one at a time and hence can be looped through. str, tuple, list, dict, set are all iterables.\nSequence is a subset of collections. All sequences are iterables.\nMethods available in any sequence type can be categorized as below.\n\ncommon methods for sequence types\n\nsequence level operations (e.g. length of a sequence)\nelement level operations (e.g. indexing and slicing)\nmethods available for iterables (can be used in loops)\n\nif mutable then methods for mutable sequence types\nmethods specific to a sequence type\n\nIterable methods are related to use in looping and are discussed in respective sections.\nBased on this categorization, methods are discussed for respective sequence types, string, list and tuple.\nAll this information is end product of developments in the field of data structures. The DSA part of the book has more information on this, post reading which context of why Python data types behave the way they do will be more clear.\n\n\n11.1.2 Objectives\nFocus on understanding the underlying concepts and where to look for information in a structured way.\n\nCreation and syntax\nOperations: understand how operations are structured across data types\nIndexing and slicing for sequence types\nImplications: understand the usage and implications using example use cases given\n\nMutable vs Immutable data types\n\nChoosing data types: understand when to use which data type"
  },
  {
    "objectID": "content/building-blocks/data-types.html#none",
    "href": "content/building-blocks/data-types.html#none",
    "title": "11  Data types",
    "section": "11.2 None",
    "text": "11.2 None\nNone signifies absence of value. A variable might be defined but not bound to any object. None is a placeholder to signify this state.\nIt is specially useful in conditionals, to avoid error when checking if a value has been assigned to a variable. This is covered in chapter on conditionals (Section 11.10.1.2.3, Section 15.1.5).\n\n11.2.1 Example\n\nsome_var = None\nprint(f'{some_var=}, {type(some_var)=}')\n\n&gt;&gt;&gt;  some_var=None, type(some_var)=&lt;class 'NoneType'&gt;"
  },
  {
    "objectID": "content/building-blocks/data-types.html#numeric-types",
    "href": "content/building-blocks/data-types.html#numeric-types",
    "title": "11  Data types",
    "section": "11.3 Numeric types",
    "text": "11.3 Numeric types\n\n11.3.1 Summary\n\n\n\n\n\n\n\n\n\n\n\nBoolean\nIntegers\nRationals\nReal\nComplex\n\n\n\n\nbool\nint\nfractions.Fraction\nfloat decimal.Decimal\ncomplex\n\n\n\n\n\nnumeric data types are immutable\nfor basic calculations int and float are sufficient\n\nothers are listed for completeness\n\nboolean and comparison operations are discussed separately\n\nImmutable implies that once an object is created, its value cannot be modified.\nFor variable assignment this implies that if a variable is storing some number and is assigned another number, a new object is created in background. This does not have any significant impact in case of numeric data types.\nMutability is discussed in more detail at the end of this chapter.\n\n\n11.3.2 Specifications\nNumbers, integers or floats, can be typed as done in regular math. There are some special syntax available for code readability.\n\nUnderscores can be used for better code readability. During execution they are treated normally.\n\none_million_int = 1_000_000\none_million_float = 1_000_000.00\nprint(f'{one_million_int = }')\n\n&gt;&gt;&gt;  one_million_int = 1000000\n\nprint(f'{one_million_float = }')\n\n&gt;&gt;&gt;  one_million_float = 1000000.0\n\n\n\nScientific notation can be used with floats. e has to be preceded by a number.\n\nx = [1e-2, 3.314e+5]\nprint(x)\n\n&gt;&gt;&gt;  [0.01, 331400.0]\n\n\n\n\n\n11.3.3 Operations\nRegular math operations can done using the symbols provided as listed below. Other functions commonly used are\n\nround(x[, n]) is a builtin function provided\nStandard library has more options for numeric operations\n\nmath module\n\ne.g. math.floor(x), math.ceil(x), math.trunc(x) etc.\n\nrandom module for pseudo random number generations\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\naddition\nsubstraction\nmultiplication\ndivision\nexponents\nfloored division\nmodulo\n\n\n\n\n+\n-\n*\n/\n**\n//\n%\n\n\n\n\n\nusing division always returns float\noperations with int and float return float\n\n\n11.3.3.1 Increment/Decrement\nIncrementing and decrementing a value is provided through operators += and -=.\n\nx += n is same as x = x + n\nx -= n is same as x = x - n\n\nPython uses a special syntax for these common operations and can be extended to below operations.\n\nx *= n is same as x = x * n\nx /= n is same as x = x / n\nx **= n is same as x = x ** n\n\n\n\n\n\n\n\nCaution for float\n\n\n\nThere are some issues and limitations with floating point arithmetic using float.\nIt is recommended to go through them at python documentation on limitations of using float type.\n\n\n\n\n\n11.3.4 Examples\n\n11.3.4.1 Example 1\nBelow is a basic example of assigning int and float. Note that if decimal is present then, even if number is integer, it is stored as float.\n\nnum1 = 10; num2 = 10.0\n\n\nprint(f'{num1 = }, {type(num1) = }')\n\n&gt;&gt;&gt;  num1 = 10, type(num1) = &lt;class 'int'&gt;\n\nprint(f'{num2 = }, {type(num2) = }')\n\n&gt;&gt;&gt;  num2 = 10.0, type(num2) = &lt;class 'float'&gt;\n\n\n\n\n11.3.4.2 Example 2\nOperations with int and float return float.\n\nnum1 = .25; num2 = 100\nnum3 = num2 * num1\n\n\nprint(f'{num1 = }, {type(num1) = }')\n\n&gt;&gt;&gt;  num1 = 0.25, type(num1) = &lt;class 'float'&gt;\n\nprint(f'{num2 = }, {type(num2) = }')\n\n&gt;&gt;&gt;  num2 = 100, type(num2) = &lt;class 'int'&gt;\n\nprint(f'{num3 = }, {type(num3) = }')\n\n&gt;&gt;&gt;  num3 = 25.0, type(num3) = &lt;class 'float'&gt;\n\n\n\n\n11.3.4.3 Example 3\nObjects of type int, within certain range (-5 to 256), are not duplicated for performance reasons.\n\nsome_int_1 = 10; some_int_2 = 10\n\n\nsome_int_1 is some_int_2\n\n&gt;&gt;&gt;  True\n\n\n\nThe basic idea is to intern for memory optimizations. Sometimes useful for strings, string interning. This causes surprizes such as this example.\n\n\n\n11.3.4.4 Example 4\nNumeric data types are immutable. In the example below, when some_int is assigned a new value, a new object is created in memory and bound to some_int.\n\nsome_int = 10\nprint(hex(id(some_int)), f'{some_int=}')\n\n&gt;&gt;&gt;  0x7f55cbb1c210 some_int=10\n\n\n\nsome_int += 1\nprint(hex(id(some_int)), f'{some_int=}')\n\n&gt;&gt;&gt;  0x7f55cbb1c230 some_int=11"
  },
  {
    "objectID": "content/building-blocks/data-types.html#string",
    "href": "content/building-blocks/data-types.html#string",
    "title": "11  Data types",
    "section": "11.4 String",
    "text": "11.4 String\n\n11.4.1 Overview\nIn Python, a string (str type object) is an immutable sequence of unicode code points. More generally speaking it is an immutable sequence of characters, numbers and symbols.\n\nStrings are sequence type\n\nlike mathematics, order has meaning in sequences\n\nstring is not same as trgins\n\nthis helps enable support for indexing and slicing\n\nStrings are immutable\n\na new object is created in memory on modification\n\nreferred as copy-on-modify\n\nadding/deleting/changing elements is not provided by default\n\nPython Tutorial: Gentle introduction to text\nPython library reference: Detailed documentation on str\n\n\n\n11.4.2 Specifications\n\n11.4.2.1 Overview\n\nStrings can be created using\n\nsingle quotes: 'some string'\ndouble quotes: \"some string\"\nmulti-line strings\n\ntriple single quotes: '''some string'''\ntriple double quotes: \"\"\"some string\"\"\"\n\nraw strings just need a preceding r character for any method\n\nr\"string with \\\", r'string with \\'\n\n\nSpecial string types\n\nmultiline strings\nraw strings\nformatted string literals\n\nprint changes the way results are displayed\n\n\n\n11.4.2.2 Basic strings\n\nstring_1 = 'using single quotes'\n\n\nstring_2 = \"using double quotes\"\n\n\nstring_3 = \"including \\\"double quotes\\\" using double quotes\"\n\n\nstring_4 = 'including \"double quotes\" using single quotes'\n\n\n\n11.4.2.3 Multiline strings\nMultiline strings can be created using triple quotes (single/double). A physical new line within a string is not included in the string. The spaces and tabs on a line are included, see string_2 below.\n\nstring_1 = \"\"\"This is a multiline string\nwith no tabs using triple double quotes\"\"\"\nstring_2 = '''This is a multiline string\n              with tabs using triple single quotes'''\n\n\nprint(string_1)\n\n&gt;&gt;&gt;  This is a multiline string\n&gt;&gt;&gt;  with no tabs using triple double quotes\n\n\n\nprint(string_2)\n\n&gt;&gt;&gt;  This is a multiline string\n&gt;&gt;&gt;                with tabs using triple single quotes\n\n\n\n\n11.4.2.4 Using backslash (\\)\nBackslash can be used to insert some special character sequences in a string, which are used by the print and similar functions which can parse such special character sequences.\nExamples:\n\nnewline: \\n\ntabs: \\t\nescape quote symbol: \\' or \\\"\n\nNote in below examples, when variables are output without print function, special character sequences like newline and tab are not parsed and shown as is.\n\nstring_1 = \"Line 1\\nLine 2\"\nstring_2 = \"text 1\\ttext 2\"\n\n\nstring_1; print(string_1)\n\n&gt;&gt;&gt;  'Line 1\\nLine 2'\n&gt;&gt;&gt;  Line 1\n&gt;&gt;&gt;  Line 2\n\n\n\nstring_2; print(string_2)\n\n&gt;&gt;&gt;  'text 1\\ttext 2'\n&gt;&gt;&gt;  text 1 text 2\n\n\n\n\n11.4.2.5 Raw strings\nRaw strings do not escape backslash (\\). To create a raw string prepend string with r or R character.\nOne typical use case is to store windows path which have backslashes. Note in below example since \\u has special meaning it gives error while creating the path which contains such sequence of characters.\n\nstring_1 = \"C:\\user\\name\"\n\n&gt;&gt;&gt;  (unicode error) 'unicodeescape' codec can't decode bytes in position 2-3: truncated \\uXXXX escape (&lt;string&gt;, line 1)\n\n\n\nstring_2 = r\"C:\\User\\name\"\n\n\nprint(string_2)\n\n&gt;&gt;&gt;  C:\\User\\name\n\n\n\n\n11.4.2.6 Formatted strings\nFormatted strings are used for mixing hard coded text and variable values with formatting.\n\nold syntax\n\n\"text with {0[:fs]} and {1}\".format(var1, var2)\n\nnew f-string syntax (Python version &gt;= 3.6)\n\nf'text with {var1[:fs]} and {var2[:fs]}'\n\n\n\nwhere fs to be read as format specifier\n\nThis is specially useful in controlling the format of output message from the code. Message could be an error, warning or a regular informative message.\nThere are a lot of options to play around which can be found at link.\n\n11.4.2.6.1 Examples\n\n11.4.2.6.1.1 Ex 1\nUsing old format style.\n\nuser_name = \"First Last\"\nuser_age = 20\nmy_string = \"Name: {0}\\nAge: {1}\".format(user_name, user_age)\n\n\nprint(my_string)\n\n&gt;&gt;&gt;  Name: First Last\n&gt;&gt;&gt;  Age: 20\n\n\n\n\n11.4.2.6.1.2 Ex 2\nUsing old format style with format specifier.\n\nuser_name = \"First Last\"\nuser_age = 20\nuser_balance = 1000001\nmy_string = \"Name: {0:^30}\\nAge: {1:^30}\\nBalance: {2:,.2f}\".format(\\\n  user_name, user_age, user_balance)\n\n\nprint(my_string)\n\n&gt;&gt;&gt;  Name:           First Last          \n&gt;&gt;&gt;  Age:               20              \n&gt;&gt;&gt;  Balance: 1,000,001.00\n\n\n\n\n11.4.2.6.1.3 Ex 3\nUsing new f-string with format specifier.\n\nuser_name = \"First Last\"\nuser_age = 20\nuser_balance = 1000001\nmy_string = f\"Name: {user_name:&gt;15}\\nAge: {user_age:&gt;16}\\\n    \\nBalance: {user_balance:&gt;12.2f}\"\n\n\nprint(my_string)\n\n&gt;&gt;&gt;  Name:      First Last\n&gt;&gt;&gt;  Age:               20    \n&gt;&gt;&gt;  Balance:   1000001.00\n\n\n\n\n\n\n\n11.4.3 Operations\nBelow are the 2 major categories of operations a string supports.\n\ncommon operations on sequence types\noperations specific to strings\n\nCommon sequence operations like indexing and slicing are provided with examples below, but are same for all sequence types like tuple and list.\n\n11.4.3.1 Sequence\n\noperations on sequence itself\n\nlength (len(s))\nconcatenate (s1 + s2), for same type sequences\nrepeat (s*n or n*s) where n is the number of repeats\ncomparisons, for same type sequences\n\noperations on items in sequence\n\nretrieve by position: index/slice (s[i[, j[, k=1]]])\nmin/max\ncheck element’s\n\nexistence: e in s, e not in s\nindex: s.index(e)\ncount: s.count(e)\n\n\n\n\n11.4.3.1.1 Index & Slice\nIndexing refers to retrieving elements by position. Slicing refers to extracting subset of elements of a sequence.\n\nindexing starts at 0 and ends at n - 1\nnegative indices are allowed\nusage\n\ns[i]: return item at index i\ns[i:j]: return items from index i to j-1\n\nreturns j - i items\n\ns[i:j:k]: return items from index i to j-1 with step k\n\nk=1 by default\n\n\n\n\n\n\n11.4.3.1.2 Examples\n\nstring_1 = \"abcdefgh\"\n\nEnumerate function is used to get pairs of index and elements of a sequence.\n\nprint([*enumerate(string_1)])\n[(0, ‘a’), (1, ‘b’), (2, ‘c’), (3, ‘d’), (4, ‘e’), (5, ‘f’), (6, ‘g’), (7, ‘h’)]\n\n\nselect c to f\n\n\nstring_1[2:6]\n\n&gt;&gt;&gt;  'cdef'\n\n\n\nselect second last - g\n\n\nstring_1[-2]\n\n&gt;&gt;&gt;  'g'\n\n\n\n[(0, ‘a’), (1, ‘b’), (2, ‘c’), (3, ‘d’), (4, ‘e’), (5, ‘f’), (6, ‘g’), (7, ‘h’)]\n\n\nselect last 3 elements\n\n\nstring_1[-3:]\n\n&gt;&gt;&gt;  'fgh'\n\n\n\n[(0, ‘a’), (1, ‘b’), (2, ‘c’), (3, ‘d’), (4, ‘e’), (5, ‘f’), (6, ‘g’), (7, ‘h’)]\n\n\nselect d onwards\n\n\nstring_1[3:]\n\n&gt;&gt;&gt;  'defgh'\n\n\n\nselect up till d\n\n\nstring_1[:4]\n\n&gt;&gt;&gt;  'abcd'\n\n\n\nstring_1[:3] + string_1[3:]\n\n&gt;&gt;&gt;  'abcdefgh'\n\n\n\n\n\n11.4.3.2 String specific\n\nThere are a lot of default operations (link)\n\ncase, find/replace, checks, strip, split, …\nusually easy to use, look at reference as needed\n\nregular expressions\n\nsearching and matching patterns in strings\ndepends on module re in standard library\nadvanced topic, avoid at this stage\n\n\n\n\n11.4.3.3 Arithmetic Operators\nThe + and * operations can be used with strings, other operators will give error.\nNote that operations work with compatible type of objects.\n\n+: concatenate strings\n\nworks with str type objects, i.e. strings\n\n*: repeat a string\n\nworks with a str and an int\n\n\n\n11.4.3.3.1 Example 1\n\nsome_str_1 = \"some string 1\"; some_str_2 = \"some string 2\"\nconcat_1_2 = some_str_1 + \" \" + some_str_2\nprint(concat_1_2)\n\n&gt;&gt;&gt;  some string 1 some string 2\n\n\n\n\n11.4.3.3.2 Example 2\n\nsome_str = \"xyz\"\nprint(some_str*5)\n\n&gt;&gt;&gt;  xyzxyzxyzxyzxyz\n\n\n\n\n11.4.3.3.3 Example 3\n\nsome_str_1 = \"some string 1\"; some_str_2 = \"some string 2\"\nconcat_1_2 = some_str_1 * some_str_2\n\n&gt;&gt;&gt;  Error: TypeError: can't multiply sequence by non-int of type 'str'"
  },
  {
    "objectID": "content/building-blocks/data-types.html#tuple",
    "href": "content/building-blocks/data-types.html#tuple",
    "title": "11  Data types",
    "section": "11.5 Tuple",
    "text": "11.5 Tuple\n\n11.5.1 Overview\nTuple is an immutable collection of ordered, heterogeneous objects with below features\n\nsequence type (collection of ordered objects)\n\nthis helps enable support for indexing and slicing\nthe position of data has meaning\nuseful in passing and operating on set of objects within code\n\nheterogeneous: can contain any type of object\n\nmore efficient if items are homogeneous\n\nimmutable\n\nmodify in-place operations are not supported\n\na new object is created in memory on modification if elements are immutable\n\nadding/deleting/changing elements is not provided by default\n\nPython Tutorial: Gentle introduction to tuples\nPython library reference: Detailed documentation on sequences\n\n\n\n11.5.2 Specifications\n\n11.5.2.1 Creation syntax\n\nusing commas\n\ncomma decides the tuple\nparenthesis are just for code readability\n\nusing tuple constructor: tuple()\nusing unpacking (Python special syntax)\nusing comprehension (covered in Python special features)\n\n\n\n11.5.2.2 Creation by use case\n\nusing elements\n\n0 item: () or tuple()\n1 item: i, or (i,)\n\n(i) will give error, comma is needed\n\nmore than 1 item: i1, i2, i3 or (i1, i2, i3)\n\nusing elements from another iterable[s]:\n\nusing tuple constructor: tuple(iterable[s])\nusing unpacking\n\nt = *l,, t = (*l,), t = (*s, *l)\nt = (*l) will give error, comma is needed\n\n\n\n\n\n\n11.5.3 Operations\nTuple has access to common operations on sequence types with no additional methods.\n\noperations on sequence itself\n\nlength (len(s))\nconcatenate (s1 + s2), for same type sequences\nrepeat (s*n or n*s) where n is the number of repeats\ncomparisons, for same type sequences\n\noperations on items in sequence\n\nretrieve by position: index/slice (s[i[, j[, k=1]]])\nmin/max\ncheck element’s\n\nexistence: e in s, e not in s\nindex: s.index(e)\ncount: s.count(e)"
  },
  {
    "objectID": "content/building-blocks/data-types.html#list",
    "href": "content/building-blocks/data-types.html#list",
    "title": "11  Data types",
    "section": "11.6 List",
    "text": "11.6 List\n\n11.6.1 Overview\nList is a mutable collection of ordered, heterogeneous objects with following features.\n\nsequence type\n\nthis helps enable support for indexing and slicing\nthe position of data has meaning\nuseful in passing and operating on set of objects within code\n\nheterogeneous: can contain any type of object\n\nmore efficient if items are homogeneous\n\nmutable\n\nadding/deleting/changing elements is provided by default\nmodify in-place operations are supported\n\nPython Tutorial: Gentle introduction to list: part 1, part 2\nPython library reference: Detailed documentation on sequences\n\n\n\n11.6.2 Specifications\n\nempty list: [] or list()\nusing elements: [i1, i2, ...], [i1]\nusing elements from iterable[s]:\n\nusing list constructor: list(iterable)\nusing unpacking\n\n[*t], [*t,], [*s, *t, *l]\n\nusing comprehension (covered in Python special features)\n\n\n\n\n11.6.3 Operations\nThere are 2 sets of operations a list supports.\n\ncommon operations on sequence types\noperations on mutable sequence types\n\n\n11.6.3.1 Sequence operations\n\noperations on sequence itself\n\nlength (len(s))\nconcatenate (s1 + s2), for same type sequences\nrepeat (s*n or n*s) where n is the number of repeats\ncomparisons, for same type sequences\n\noperations on items in sequence\n\nretrieve by position: index/slice (s[i[, j[, k=1]]])\nmin/max\ncheck element’s\n\nexistence: e in s, e not in s\nindex: s.index(e)\ncount: s.count(e)\n\n\n\n\n\n11.6.3.2 Mutable sequence operations\n\nmost of the operations are in-place\n\nimplies no new object creation on modification\n\noperations on sequence itself\n\ncopy (shallow), extend, repeat, reverse\n\noperations on items\n\ndelete, replace, append, clear all, remove, insert, pop\n\nlink"
  },
  {
    "objectID": "content/building-blocks/data-types.html#sec-range",
    "href": "content/building-blocks/data-types.html#sec-range",
    "title": "11  Data types",
    "section": "11.7 Range",
    "text": "11.7 Range\nRange is a special iterable to generate a sequence of integers with following characteristics.\n\nimmutable sequence type\ncannot see all elements at a time\n\nhave to be unpacked into a list or tuple\n\nsyntax for creation\n\nrange(stop)\nrange(start, stop[, step])\n\nstart is included\nstop is excluded\n\n\nprimarily used for loops which is discussed at Section 12.3.1\n\n\n11.7.1 Examples\n\nprint(range(10))\n\n&gt;&gt;&gt;  range(0, 10)\n\n\n\nprint(list(range(10)))\n\n&gt;&gt;&gt;  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nprint([*range(11)])\n\n&gt;&gt;&gt;  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n\n\nprint([*range(1, 11)])\n\n&gt;&gt;&gt;  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n\n\nprint([*range(-1, -11)])\n\n&gt;&gt;&gt;  []\n\n\n\nprint([*range(-1, -11, -1)])\n\n&gt;&gt;&gt;  [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10]"
  },
  {
    "objectID": "content/building-blocks/data-types.html#dictionary",
    "href": "content/building-blocks/data-types.html#dictionary",
    "title": "11  Data types",
    "section": "11.8 Dictionary",
    "text": "11.8 Dictionary\n\n11.8.1 Overview\nA dictionary is a mutable mapping type collection of heterogeneous objects mapped to keys that are hashable and unique objects.\n\nin newer versions (&gt;3.9) the order is guaranteed\ncollection of {key: value} pairs where\n\nkey can be any hashable object\n\nstrings, numeric data types can be used\nimmutable type which contain only immutable objects\ntuples with immutable objects can be used\nlists, dictionary cannot be used\n\nvalue can be any Python object\n\n\nA dictionary is useful when a collection of objects is needed with the option to do quick searches based on keys rather than index, unlike sequences.\n\nPython Tutorial: Gentle introduction to dictionary\nPython library reference: Detailed dictionary documentation\n\nConcept of hashable objects is introduced in DSA (Section 21.4.4).\n\n\n11.8.2 Specifications\n\nusing key value pairs separated by commas\n\nd = {\"key1\": value1, \"key2\": value2, ...}\n\nusing type constructor\n\nd = dict([(\"key1\", value1), (\"key2\", value2), ...])\nd = dict(key1=value1, key2=value2)\n\ncreate empty dictionary\n\nd = {}\nd = dict()\n\nusing comprehensions (covered in Python special features)\nif a key is passed multiple times, final value exists\n\n\n\n11.8.3 Operations\n\noperations on dictionary itself\noperations on keys and values\n\n\n11.8.3.1 Operations on dictionary\n\nlength: len(d)\nclear: d.clear()\nshallow copy: d.copy()\nupdate from another dictionary: d.update([other])\n\n\n\n11.8.3.2 Operations on keys and values\n\ncheck keys: key in d / key not in d\nview all keys/values: d.keys() / d.values() / d.items()\nget all keys/values as list of tuples: list(enumerate(d))\nget all keys as list: list(d)\nget all keys as list reversed: list(reversed(d))\nget value, error if key not present: d[key]\nset value, inserts key if key not present: d[key] = value\ndel key/value, deletes last entry and returns deleted key, value: d.popitem()\nif key not present return default if defined else error\n\nget value: d.get(key[, default])\ndel key/value and return deleted value: d.pop(key[, default])"
  },
  {
    "objectID": "content/building-blocks/data-types.html#set",
    "href": "content/building-blocks/data-types.html#set",
    "title": "11  Data types",
    "section": "11.9 Set",
    "text": "11.9 Set\nSet is a collection of unique objects with operations related to math sets available, e.g. union, intersection.\nIn other words, set is a special dictionary with keys only.\nIn Python specifically, set is an unordered collection of hashable objects. In newer versions (&gt;3.9) the order is guaranteed.\n\nPython tutorial for sets\nPython documentation on set type\n\nSets are commonly used for\n\nmembership testing: search by value\nremoving duplicates from a collection\n\n\n11.9.1 Specifications\nA set can be created using curly braces with the exception of empty set.\n\ncreate a set with valid keys\n\ncurly braces\nset constructor\n\n\nsome_set = {key1, key2, ...}\nsome_set = set(iterable)\n\nempty set can be created using set() constructor\n\nusing {} creates an empty dictionary"
  },
  {
    "objectID": "content/building-blocks/data-types.html#boolean-data-type",
    "href": "content/building-blocks/data-types.html#boolean-data-type",
    "title": "11  Data types",
    "section": "11.10 Boolean data type",
    "text": "11.10 Boolean data type\nBoolean data type, True and False, is the fundamental unit for implementing boolean conditional expressions.\nBoolean comparison operator are used to create elementary conditions. Combination operators allow for building larger conditions by combining multiple conditions.\nConditional control flow blocks, if and match, use conditions.\nThe idea is based on boolean math. It is essential in controlling the flow of the program based on state of one or more objects in the program.\n\nbool in Python, based on usage, can refer to\n\ndata type\nfunction\n\nbool type is used to represent boolean values\nbool type inherits from int type\nbool data type can take value from 2 built-in constants, True and False\n\nunderlying int values are int(True) = 1 and int(False) = 0 respectively\n\ncan be stored in variables like other objects\n\nuseful in conditional blocks\n\n\nBelow are some examples for familiarity.\n\nbasics\n\n\nbool(True), int(True), type(True)\n\n&gt;&gt;&gt;  (True, 1, &lt;class 'bool'&gt;)\n\nbool(False), int(False), type(False)\n\n&gt;&gt;&gt;  (False, 0, &lt;class 'bool'&gt;)\n\n\n\nstoring in variables\n\nit is useful to name boolean variables like is_&lt;some check&gt;\n\n\n\nis_int = True\nis_int, bool(is_int), int(is_int), type(is_int)\n\n&gt;&gt;&gt;  (True, True, 1, &lt;class 'bool'&gt;)\n\n\n\n11.10.1 Boolean comparison operators\nBoolean comparison operators are used for object comparisons and return True or False, if used with compatible object types.\nThey are mostly used to create boolean conditions which are used in conditional blocks, if and match..case.\nWhen used with sequence types (string, tuple, list)\n\nequality operators (==, !=) return True if all elements are equal (not equal) in content\ninequality operators only test minimum and maximum as appropriate\nmembership testing check for existence of elements and is most useful\n\n\n11.10.1.1 Options and syntax\n::: {.cell hash=‘data-types_cache/html/unnamed-chunk-55_719f0e3bdffca2fca631a4041ca03613’}\n\n\n\n\n\n\n\nOperation\n\n\n\n\nPython Operator\n\n\n\n\nComments\n\n\n\n\n\n\nbasic value comparisons\n\n\n\n\n==, !=, &lt;, &gt;, &lt;=, &gt;=\n\n\n\n\n\ncompares values\n\n\ndifferent types ok, but must be compatible\n\n\n\n\n\n\n\nmembership testing\n\n\n\n\nin, not in\n\n\n\n\n\nused with sequence types\n\n\n\n\n\n\n\nobject id comparison\n\n\n\n\nis, is not\n\n\n\n\n\ncompares memory address\n\n\nworks on all type\n\n\n\n\n\n:::\n\n\n11.10.1.2 Examples\n\n11.10.1.2.1 Numeric\n\nnum_1 = 10; num_2 = 15; num_3 = 10.0\n\n\nnum_1 == num_2, num_1 &lt; num_2, num_1 &lt;= num_3\n\n&gt;&gt;&gt;  (False, True, True)\n\n\n\ncan be stored in variables\n\n\ncnd = num_1 &gt; num_3\n\n\nprint(f\"{cnd = }, {type(cnd) = }\")\n\n&gt;&gt;&gt;  cnd = False, type(cnd) = &lt;class 'bool'&gt;\n\n\n\n\n11.10.1.2.2 Sequence type\nMembership testing is more useful for sequence types. Below examples illustrate the usage.\n\n11.10.1.2.2.1 Strings\n\ntest character in a string\n\n\nsome_string = \"abcd\"\nsome_chr_1 = \"a\"\nsome_chr_2 = \"e\"\n\n\nsome_chr_1 in some_string\n\n&gt;&gt;&gt;  True\n\n\n\nsome_chr_2 in some_string\n\n&gt;&gt;&gt;  False\n\n\n\ntest a small string in a longer string\n\n\nsome_long_str = \"A reasonably long string\"\nsome_short_str = \"long\"\n\n\nsome_short_str in some_long_str\n\n&gt;&gt;&gt;  True\n\n\n\n\n11.10.1.2.2.2 Tuples and lists\n\nsome_list = [1, 2, 3, 4, (1, 2, 3)]\nsome_tuple = 1, 2, 3\nnum_1 = 3; num_2 = 5\n\n\nnum_1 in some_list\n\n&gt;&gt;&gt;  True\n\n\n\nsome_tuple in some_list\n\n&gt;&gt;&gt;  True\n\n\n\nnum_2 in some_tuple\n\n&gt;&gt;&gt;  False\n\n\n\nstore a boolean operation in a variable\n\n\ncnd = some_tuple in some_list\n\n\n\n&gt;&gt;&gt;  cnd = True, type(cnd) = &lt;class 'bool'&gt;\n\n\n\n\n\n11.10.1.2.3 None type\nSince there is a single instance of None type object created in a Python session, object id comparison is useful. None is used to signify if a variable is defined but not assigned a value yet.\nBelow example illustrates the object id comparison for None type in isolation.\n\nsome_var = None\nsome_var is None\n\n&gt;&gt;&gt;  True\n\n\n\n\n\n\n11.10.2 Boolean combination operators\nBoolean combination operators use boolean math to provide means of combining multiple comparison operations and conditions to form larger conditions.\n::: {.cell hash=‘data-types_cache/html/unnamed-chunk-72_ef0cc12dac9dbc79e0c01649b0efada4’}\n\n\n\n\n\n\n\nOperation\n\n\n\n\nPython Operator\n\n\n\n\nComments\n\n\n\n\n\n\nnot\n\n\n\n\nnot x\n\n\n\n\n\ninverts the bool value\n\n\nif x is false, then True, else False\n\n\n\n\n\n\n\nand\n\n\n\n\nx and y\n\n\n\n\n\ntest if both conditions are True\n\n\n\n\n\n\n\nor\n\n\n\n\nx or y\n\n\n\n\n\ntest if any condition is True\n\n\n\n\n\n\n\n()\n\n\n\n\n(cnd1 and cnd2) or (cnd3)\n\n\n\n\n\nused to group conditions\n\n\nconditions inside () are evaluated first\n\n\n\n\n\n:::\n\nbasic examples of combining conditions\n\na == 10\na &gt;= 5 and a &lt;= 10\n(a &gt; 0 and a &lt; 10) or (a &gt;= 10 and a &lt; 25)\n\norder of precedence used for evaluation\n\n()\ncomparison operators have same priority (==, !=, &lt;, &gt;, &lt;=, &gt;=)\nnot &gt; and &gt; or\n\nchained comparisons\n\nare automatically converted to paired and comparisons\nexample: a &lt; b &lt; c is same as a &lt; b and b &lt; c\nthis is specific to Python\n\nfor conditions with too many nested combinations it is recommended to use ()\n\nbest for code readability\navoid errors due to precedence order\n\ncan be stored in variables like other objects\n\nand used later in control flow\n\n\nand and or operators are based on logic gates in boolean math. Truth tables, given below, summarize results for logic gates. 0 and 1 are used instead of False and True for better readability.\n::: {.cell hash=‘data-types_cache/html/unnamed-chunk-73_4219c4749a3057317a8b6c584ca8f59a’}\n\n\n\n\n\n\n\n\nx\n\n\n\n\ny\n\n\n\n\nx and y\n\n\n\n\nx or y\n\n\n\n\n\n\n1\n\n\n\n\n1\n\n\n\n\n1\n\n\n\n\n1\n\n\n\n\n\n\n1\n\n\n\n\n0\n\n\n\n\n0\n\n\n\n\n1\n\n\n\n\n\n\n0\n\n\n\n\n1\n\n\n\n\n0\n\n\n\n\n1\n\n\n\n\n\n\n0\n\n\n\n\n0\n\n\n\n\n0\n\n\n\n\n0\n\n\n\n\n:::\n\nThere are some additional features which Python provides related to boolean data type and are discussed in the Python special features chapter (Section 15.1). They are left from this section to keep the complexity low at this stage."
  },
  {
    "objectID": "content/building-blocks/data-types.html#generic-concepts",
    "href": "content/building-blocks/data-types.html#generic-concepts",
    "title": "11  Data types",
    "section": "11.11 Generic concepts",
    "text": "11.11 Generic concepts\n\n11.11.1 Iterable unpacking\nIterable unpacking is a special feature in newer versions of Python. Some features were introduced in Python version 2, more features added using PEP-3132: Extended Iterable Unpacking in version 3.\n\n* unpacks remaining items\nreturns a list\nadvantages\n\nbetter code readability\neasier than using indexing\nfaster\n\ngives error if there is a mismatch in number of items and variables\n\n\n11.11.1.1 Examples\n\nUnpack and assign elements of an iterable to variables\n\nget first and remaining items of an iterable\n\n\n\nsome_list = [1, 2, 3, 4]; some_tuple = (1, 2, 3, 4)\n\n\nfirst_item = some_list[0]\nend_items = some_list[1:]\n\n\nprint(f'{first_item = }, {end_items = }')\n\n&gt;&gt;&gt;  first_item = 1, end_items = [2, 3, 4]\n\n\n\nfirst_item, *end_items = some_list\n\n\nprint(f'{first_item = }, {end_items = }')\n\n&gt;&gt;&gt;  first_item = 1, end_items = [2, 3, 4]\n\n\n\nUnpack and assign elements of an iterable to variables\n\nget last and remaining items of an iterable\n\n\n\nsome_list = [1, 2, 3, 4]; some_tuple = (1, 2, 3, 4)\n\n\nbegin_items = some_tuple[0:-1]\nlast_item = some_tuple[-1]\n\n\nprint(f'{begin_items = }, {last_item = }')\n\n&gt;&gt;&gt;  begin_items = (1, 2, 3), last_item = 4\n\n\n\n*begin_items, last_item = some_tuple\n\n\nprint(f'{begin_items = }, {last_item = }')\n\n&gt;&gt;&gt;  begin_items = [1, 2, 3], last_item = 4\n\n\n\nUnpack and assign elements of an iterable to variables\n\nget first two, last and remaining middle items of an iterable\n\n\n\nsome_list = [1, 2, 3, 4, 5, 6, 7]; some_tuple = (1, 2, 3, 4, 5, 6, 7)\n\n\nfirst_item, second_item, *remaining_items, last_item = some_tuple\n\n\nprint(f'{first_item = }, {second_item = }')\n\n&gt;&gt;&gt;  first_item = 1, second_item = 2\n\nprint(f'{remaining_items = }, {last_item = }')\n\n&gt;&gt;&gt;  remaining_items = [3, 4, 5, 6], last_item = 7\n\n\n\nCombine iterables into another\n\n\nsome_list_1 = [1, 2, 3]; some_tuple_1 = (4, 5);\nsome_tuple_2 = (*some_list_1, *some_tuple_1)\n\n\n\n&gt;&gt;&gt;  some_tuple_2=(1, 2, 3, 4, 5)\n\n\n\n** for mapping types - dictionary\n\n\nsome_dict_1 = {\"key1\": \"value1\", \"key2\": \"value2.1\"}\nsome_dict_2 = {\"key2\": \"value2.2\", \"key3\": \"value3\"}\nsome_dict_3 = {**some_dict_1, **some_dict_2}\n\n\n\n&gt;&gt;&gt;  some_dict_3={'key1': 'value1', 'key2': 'value2.2', 'key3': 'value3'}\n\n\n\n\n\n11.11.2 Implications of mutability\n\nModify in-place: any modification to the object does not lead to creation of a new object\nCopy on modify: create a new copy of object if modified, opposite of modify in-place\nMutable \\(\\implies\\) modify in-place\n\nLists and dictionaries can be modified without creation of new object on RAM\n\nImmutable \\(\\implies\\) copy on modify\n\nStrings and tuples create new objects on RAM if modified\n\n\nModify in-place means any modification to the object does not lead to creation of a new object. For e.g. strings and tuples create new objects on RAM if modified, whereas lists and dictionaries can be modified without creation of new object on RAM.\n\nImplications\n\nflexibility\nefficiency (in terms of speed and memory)\n\nImmutable objects (strings, tuples) are\n\nefficient for constant data\nless flexible\n\nMutable objects (lists, dictionaries) are\n\nless efficient for constant data\nflexible, support in-place modification\ncan be more efficient if data keeps changing over time\n\n\n\n11.11.2.1 Changing elements\nSince strings and tuples are immutable, elements cannot be assigned new values though indexing. This is unlike mutable types where this is allowed, e.g. lists.\n\nsome_string = \"abcdee\"\nsome_string[-1] = \"f\"\n\n&gt;&gt;&gt;  Error: TypeError: 'str' object does not support item assignment\n\n\n\nsome_tuple = (0, 1, 1)\nsome_tuple[2] = 2\n\n&gt;&gt;&gt;  Error: TypeError: 'tuple' object does not support item assignment\n\n\n\nsome_list = [0, 1, 5]\nsome_list[2] = 2\nprint(some_list)\n\n&gt;&gt;&gt;  [0, 1, 2]\n\n\nStrings have internal methods that can change elements, but then they follow copy-on-modify.\n\nsome_string_1 = \"abc\"\nsome_string_2 = some_string_1.replace(\"a\", \"b\")\n\n\nprint(f'{some_string_1=}, {some_string_2=}\\n\\\n    {some_string_1 is some_string_2 = }')\n\n&gt;&gt;&gt;  some_string_1='abc', some_string_2='bbc'\n&gt;&gt;&gt;      some_string_1 is some_string_2 = False\n\n\n\nsome_string = \"abc\"; some_string_orig_id = hex(id(some_string))\n\n\n\n&gt;&gt;&gt;  some_string='abc', some_string_orig_id = '0x7f55cba5d170'\n\n\n\n\n&gt;&gt;&gt;  hex(id(some_string.replace(\"a\", \"b\"))) = '0x7f55b597b0b0'\n\n\n\n\n&gt;&gt;&gt;  some_string='abc', some_string_orig_id = '0x7f55cba5d170'\n\n\n\nsome_string = some_string.replace(\"a\", \"b\")\n\n\n\n&gt;&gt;&gt;  some_string='bbc'\n&gt;&gt;&gt;  hex(id(some_string)) = '0x7f55c7b4bbf0'\n&gt;&gt;&gt;  some_string_orig_id = '0x7f55cba5d170'\n\n\n\n\n11.11.2.2 Propagation of changes\nMutable types like lists or dictionaries, when passed around through variable assignment, changes are propagated.\n\nwhen you make changes to original list they propagate\n\nthis is required in many cases\nbut can also lead to a bug\nbe aware of the concept\n\nto avoid default behavior when needed use\n\nconstructor list(iterable)\nunpacking [*iterable]\nloops\n\n\n\nsome_list_1 = [1, 2, \"a\", \"b\"]\nsome_list_2 = some_list_1\n\n\nprint(f'{some_list_1=}, {some_list_2=}\\n{some_list_2 is some_list_1 = }')\n\n&gt;&gt;&gt;  some_list_1=[1, 2, 'a', 'b'], some_list_2=[1, 2, 'a', 'b']\n&gt;&gt;&gt;  some_list_2 is some_list_1 = True\n\n\n\nsome_list_1[2] = \"abc\"\n\n\nprint(f'{some_list_1=}, {some_list_2=}\\n{some_list_2 is some_list_1 = }')\n\n&gt;&gt;&gt;  some_list_1=[1, 2, 'abc', 'b'], some_list_2=[1, 2, 'abc', 'b']\n&gt;&gt;&gt;  some_list_2 is some_list_1 = True\n\n\n\nsome_list_2[-1] = \"xyz\"\n\n\nprint(f'{some_list_1=}, {some_list_2=}\\n{some_list_2 is some_list_1 = }')\n\n&gt;&gt;&gt;  some_list_1=[1, 2, 'abc', 'xyz'], some_list_2=[1, 2, 'abc', 'xyz']\n&gt;&gt;&gt;  some_list_2 is some_list_1 = True\n\n\n\nusing constructor or unpacking does not pass the object itself\n\n\nsome_list_1 = [1, 2, \"a\", \"b\"]\nsome_list_2 = list(some_list_1)\n\n\n\n&gt;&gt;&gt;  some_list_1=[1, 2, 'a', 'b'], some_list_2=[1, 2, 'a', 'b']\n&gt;&gt;&gt;  some_list_2 is some_list_1 = False\n\n\n\nsome_list_1[2] = \"abc\"\n\n\n\n&gt;&gt;&gt;  some_list_1=[1, 2, 'abc', 'b'], some_list_2=[1, 2, 'a', 'b']\n&gt;&gt;&gt;  some_list_2 is some_list_1 = False\n\n\n\nusing constructor or unpacking does not pass the object itself\n\n\nsome_list_1 = [1, 2, \"a\", \"b\"]\nsome_list_2 = [*some_list_1]\n\n\nprint(f'{some_list_1=}, {some_list_2=}\\n{some_list_2 is some_list_1 = }')\n\n&gt;&gt;&gt;  some_list_1=[1, 2, 'a', 'b'], some_list_2=[1, 2, 'a', 'b']\n&gt;&gt;&gt;  some_list_2 is some_list_1 = False\n\n\n\nsome_list_1[2] = \"abc\"\n\n\nprint(f'{some_list_1=}, {some_list_2=}\\n{some_list_2 is some_list_1 = }')\n\n&gt;&gt;&gt;  some_list_1=[1, 2, 'abc', 'b'], some_list_2=[1, 2, 'a', 'b']\n&gt;&gt;&gt;  some_list_2 is some_list_1 = False\n\n\n\n\n11.11.2.3 Mutable in immutable\n\ntuple is immutable in terms of its element objects\nthe contained object remains mutable if it is mutable\n\n\nsome_list = [1, 2, 3, 4, 5]\nsome_tuple = (some_list, \"some other object\")\n\n\nprint(f'{some_list=}\\n{some_tuple=}\\n{some_list is some_tuple[0] = }')\n\n&gt;&gt;&gt;  some_list=[1, 2, 3, 4, 5]\n&gt;&gt;&gt;  some_tuple=([1, 2, 3, 4, 5], 'some other object')\n&gt;&gt;&gt;  some_list is some_tuple[0] = True\n\n\n\nsome_list.pop()\n\n&gt;&gt;&gt;  5\n\n\n\nprint(f'{some_list=}\\n{some_tuple=}\\n{some_list is some_tuple[0] = }')\n\n&gt;&gt;&gt;  some_list=[1, 2, 3, 4]\n&gt;&gt;&gt;  some_tuple=([1, 2, 3, 4], 'some other object')\n&gt;&gt;&gt;  some_list is some_tuple[0] = True\n\n\n\nif only contents are needed and propagation is to be avoided use unpacking or constructor\n\n\nsome_list = [1, 2, 3, 4, 5]\nsome_tuple_1 = *some_list,; some_tuple_2 = tuple(some_list)\n\n\nprint(f'{some_list=}\\n{some_tuple_1=}\\n{some_tuple_2=}')\n\n&gt;&gt;&gt;  some_list=[1, 2, 3, 4, 5]\n&gt;&gt;&gt;  some_tuple_1=(1, 2, 3, 4, 5)\n&gt;&gt;&gt;  some_tuple_2=(1, 2, 3, 4, 5)\n\nprint(f'{some_list is some_tuple_1 = }')\n\n&gt;&gt;&gt;  some_list is some_tuple_1 = False\n\nprint(f'{some_list is some_tuple_2 = }')\n\n&gt;&gt;&gt;  some_list is some_tuple_2 = False\n\n\n\nsome_list.pop()\n\n&gt;&gt;&gt;  5\n\n\n\nprint(f'{some_list=}\\n{some_tuple_1=}\\n{some_tuple_2=}')\n\n&gt;&gt;&gt;  some_list=[1, 2, 3, 4]\n&gt;&gt;&gt;  some_tuple_1=(1, 2, 3, 4, 5)\n&gt;&gt;&gt;  some_tuple_2=(1, 2, 3, 4, 5)\n\nprint(f'{some_list is some_tuple_1 = }')\n\n&gt;&gt;&gt;  some_list is some_tuple_1 = False\n\nprint(f'{some_list is some_tuple_2 = }')\n\n&gt;&gt;&gt;  some_list is some_tuple_2 = False\n\n\n\n\n11.11.2.4 Shallow vs deep copy\nShallow copy creates a new object for the collection being copied but does not create new objects, if items in the collection are themselves collection. This can have side effects.\nRegular copy method available in all collections (string, tuple, list, dictionary) makes a shallow copy.\nThis works fine if elements of the collection are immutable objects like numbers, strings or tuples, but if there are mutable types like list or dict then propagation will occur.\nThis might not be desirable at times, so a deep copy is needed which creates new objects for all elements of the original container going through nested structure of the collection recursively.\nThe standard library has copy module which has deepcopy function to achieve this.\nBelow example illustrates the point. It is recommended to do experiments to understand the concept.\nsome_list_1 is a list containing a list, tuple and a dictionary.\nsome_list_2 is a regular copy, so is different object from some_list_1, but elements point to the same underlying some_list, some_tuple and some_dict\nsome_list_3 is a regular copy from copy module, so behaves similar to some_list_2.\nsome_list_4 is a deep copy from copy module, so elements are different objects as well.\n\nimport copy\nsome_list = [1,2,3]; some_tuple = (4, 5); some_dict = {\"six\": 6, \"seven\": 7}\nsome_list_1 = [some_list, some_tuple, some_dict]\nsome_list_2 = some_list_1.copy()\nsome_list_3 = copy.copy(some_list_1)\nsome_list_4 = copy.deepcopy(some_list_1)\n\n\n\n&gt;&gt;&gt;  some_list_2 is some_list_1 = False\n\n\n&gt;&gt;&gt;  some_list_3 is some_list_1 = False\n\n\n&gt;&gt;&gt;  some_list_4 is some_list_1 = False\n\n\n&gt;&gt;&gt;  some_list_2[0] is some_list_1[0] = True\n\n\n&gt;&gt;&gt;  some_list_3[0] is some_list_1[0] = True\n\n\n&gt;&gt;&gt;  some_list_4[0] is some_list_1[0] = False"
  },
  {
    "objectID": "content/building-blocks/control-flow.html#introduction",
    "href": "content/building-blocks/control-flow.html#introduction",
    "title": "12  Control Flow",
    "section": "12.1 Introduction",
    "text": "12.1 Introduction\n\n12.1.1 Overview\nWhen do you need to control the flow of a program?\n\nchange outcome based on state of object[s] (condition[s])\n\nconditional blocks: if...[elif]....[else], match...case\n\nrepeat certain task[s] or iterate through a collection of data\n\nloops: for...[else], while...[else] blocks\n\navoid stopping of program on errors and handle the flow differently\n\nerror handlers: try...[except]...[else]...[finally] blocks\n\nremove dependency on certain tasks\n\nasyncio (asynchronous input output)\n\nincrease efficiency by optimizing redirection of tasks to multiple cpu cores/threads\n\nparallel computing, …\n\n\n\nNote: square brackets are generally used to represent something optional\n\nAs a beginner to programming conditional blocks and loops are sufficient to get started.\nError handlers are not needed for most of the basic stuff, but there are a few cases where it is useful to know the basics. For example it is useful to know the basics of using try block for a few situations. Most of debugging is based on the concepts related to error handlers. Editors provide support for debugging using these concepts. Developers rely heavily on using these concepts to handle expected errors differently. Therefore it is useful to understand the basics of error handling as it is certain to make errors and handle them.\nAsynchronous input/output (asyncio) and parallel computing are advanced topics used to increase efficiency of larger programs. They are not covered.\n\n\n12.1.2 Objectives\nFor all of the control flow techniques, conditionals, loops and error handlers\n\nget acquainted to specifications\nunderstand the rules and few implications conceptually\nexamples of common use cases\nunderstand conceptually when to use what\nexperiment with individual pieces"
  },
  {
    "objectID": "content/building-blocks/control-flow.html#conditional-blocks",
    "href": "content/building-blocks/control-flow.html#conditional-blocks",
    "title": "12  Control Flow",
    "section": "12.2 Conditional blocks",
    "text": "12.2 Conditional blocks\nConditional blocks use conditions to control and change the flow of a program. Conditions are created using boolean operations.\n\nif...[elif]...[elif]...[else] blocks\n\ncovers everything needed from basic conditional blocks\n\nmatch...case...[case_] blocks\n\nspecial case where a variable has to be tested for different values\nin most cases can be implemented using if block\nbetter for code readability\nhas some additional special features related to pattern matching\n\n\n\n12.2.1 if blocks\nif blocks are used to execute some code only when a condition is evaluated to True.\n\n12.2.1.1 Specifications\nBelow are possible forms of if block.\n\n\nif condition:\n    # if block content\nif condition:\n    # if block content\nelse:\n    # else block content\n\n\n\nif condition_1:\n    # if block content\nelif condition_2:\n    # elif block 1 content\nelif condition_3:\n    # elif block 2 content\nelse:\n    # else block content\n\n\n# execute some short expression conditionally\nif condition: &lt;short expression&gt;\n\nstart an if block\n\nif statement with an expression ending in colon (:)\n\nend an if block\n\nshort expression on the same line\nindented block of one or more lines of code\n\nthere can be 0 or more elif (else if) blocks\nthere can be 0 or 1 else block\nsyntax of elif and else is same as if\n\n\n12.2.1.1.1 Ternary operator\nPython additionally provides a ternary form for short, one line conditionals. Below is the syntax, where X and Y are short expressions to be evaluated and returned.\nTernary operator is useful for code readability. It removes the requirement for a multiline if block for quick checks required in code.\nX if condition else Y\n\nprint(\"condition True\") if 1 &gt; 0 else print(\"condition False\")\n\n&gt;&gt;&gt;  condition True\n\n\n\nprint(\"condition True\") if 1 == 0 else print(\"condition False\")\n\n&gt;&gt;&gt;  condition False\n\n\n\n\n\n12.2.1.2 Control flow\nFlow diagram below illustrates the control flow for a if block.\n\n\n\n\n\nBasic idea\n\ncheck if and elif conditions sequentially\n\nif any of the conditions evaluate to True\n\nexecute the corresponding block content and exit\n\nif all of the conditions evaluate to False\n\nexecute else block if present and exit\n\n\n\n\n\n12.2.1.3 Examples\n\n12.2.1.3.1 Basic\n\nsome_num = 12\nif some_num &gt;= 0:\n    print(f'{some_num} is positive')\n\n&gt;&gt;&gt;  12 is positive\n\n\n\n\n12.2.1.3.2 With else block\n\nsome_num = 12\nif some_num &gt;= 0:\n    print(f'{some_num} is positive')\nelse:\n    print(f'{some_num} is negative')\n\n&gt;&gt;&gt;  12 is positive\n\n\n\n\n12.2.1.3.3 With elif block\n\nsome_num = 12\nif some_num == 0:\n    print(f'{some_num} is zero')\nelif some_num &gt; 0:\n    print(f'{some_num} is positive')\nelif some_num &lt; 0:\n    print(f'{some_num} is negative')\n\n&gt;&gt;&gt;  12 is positive\n\n\n\n\n12.2.1.3.4 With elif and else\n\nsome_num = 12\nif some_num == 0:\n    print(f'{some_num} is zero')\nelif some_num &gt; 0:\n    print(f'{some_num} is positive')\nelse:\n    print(f'{some_num} is negative')\n\n&gt;&gt;&gt;  12 is positive\n\n\n\n\n\n\n12.2.2 match...case block\nMatch blocks are used if some object is to be tested against multiple cases. It can be achieved using if blocks but match blocks are better for code readability and ease of use for the given use case.\n_ is optional and for case when none of the options match.\n\n\n\nmatch some_obj:\n    case option_1:\n        # do something and exit\n    case option_2:\n        # do something and exit\n    [case _:\n        # do something and exit\n    ]\n\n\n \n\n\nif some_obj == option_1:\n    # do something and exit\nelif some_obj == option_2:\n    # do something and exit\n[else\n    # do something and exit\n]\n\n\n\nMore information can be found at Python documentation for match statements."
  },
  {
    "objectID": "content/building-blocks/control-flow.html#loops",
    "href": "content/building-blocks/control-flow.html#loops",
    "title": "12  Control Flow",
    "section": "12.3 Loops",
    "text": "12.3 Loops\n\nLoops are needed for iteration\n\nrepeating certain pieces of code\niterating over collections to access, operate or modify elements\n\nWhen number of repetitions is\n\nknown: use for block\nnot known: use while block\n\nIt is recommended not to modify the collection that is being iterated,\ninstead use any of the below solutions\n\ncreate a new collection\ncreate a copy\n\n\n\nIterating is a common term which refers to going through elements of a collection. Iterables and iterators in Python are based on this idea.\n\n\n12.3.1 for block\n\n12.3.1.1 Specifications\n\n\n\nfor item in iterable:\n    # do something\n    # item is available\n    print(item)\n\n\n \n\n\nfor i in range(n):\n    # do something\n    # i is available\n    print(item)\n\n\n\nfor item in iterable: print(item)\nFundamental form\n\nfor keyword declares the start of a for block\nitem in iterable is the generic form\n:, colon, to declare end of for declaration\ncode to be repeated, which has access to an item for a given iteration\n\nif a short expression has to be repeated it can be used on the same line\n\n\nUsing this fundamental form other variation are created. e.g.\n\nrange(n) function is used to loop through fixed number of times\n\nexample to repeat 10 times\n\nfor i in range(10): i takes values 0 through 9\nfor i in range(1, 11): i takes values 1 through 10\n\nrange() function is discussed at Section 11.7\n\nloops can be nested using indentation\n\nuseful for working with nested data structures\n\n\n\n12.3.1.1.1 continue\ncontinue clause causes the loop to jump to next iteration without executing remaining lines in loop.\nIn the below structure, when the condition is true, item will not be printed.\n\nfor item in iterable:\n    # do something\n    # item is available\n    if condition:\n        continue\n    print(item)\n\nContinue is useful if you need to skip execution of some code for certain elements of the iterable.\n\n\n12.3.1.1.2 break and else\n\nbreak clause causes exit of the innermost loop\n\nis optional\ninnermost is critical when there are nested loops\n\nelse clause\n\nis optional\nis executed only if loop ends normally, i.e. no break is hit\n\n\n\nfor item in iterable:\n    # do something\n    # item is available\n    if condition:\n        break\n    print(item)\nelse:\n    print(\"No break found\")\n\n\n\n\n12.3.1.2 Control flow\n\n\n\n\n\n\n\n12.3.1.3 Examples\n\n12.3.1.3.1 Basic\n\nLoop through 1 to n_max = 20\n\nstore even numbers in a list evens\nstore odd numbers in a list odds\n\n\n\nn_max = 20\nevens = []; odds = []\nfor i in range(1, n_max + 1):\n    evens.append(i) if i % 2 == 0 else odds.append(i)\n\n\nprint(evens)\n\n&gt;&gt;&gt;  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\nprint(odds)\n\n&gt;&gt;&gt;  [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\n\n\n\n12.3.1.3.2 continue\nIn the below example only odd numbers are printed as the loop hits continue for even numbers.\n\nfor i in range(5):\n    if i % 2 == 0: continue\n    print(i)\n\n&gt;&gt;&gt;  1\n&gt;&gt;&gt;  3\n\n\n\n\n12.3.1.3.3 break and else\n\nFor a given list of numbers\n\nvalidate if the numbers are within some limits, e.g. [0, 100]\nif all values are within limits\n\nprint “validation successful”\n\nif any of the values are outside limits\n\nprint “validation failed” with value\nexit the loop\n\n\n\n\ncorrect_list = [65, 24, 53, 91, 59, 81, 93, 7, 78, 10]\nfor num in correct_list:\n    if num &lt; 0 or num &gt; 100:\n        print(f\"validation failed, list contains {num}\")\n        break\nelse:\n    print(\"validation successful\")\n\n&gt;&gt;&gt;  validation successful\n\n\n\nincorrect_list = [97, 144, 115, 127, 33, 99, 85, 109, 21, 110]\nfor num in incorrect_list:\n    if 0 &lt;= num &lt;= 100:\n        continue\n    else:\n        print(f\"validation failed, list contains {num}\")\n        break\nelse:\n    print(\"validation successful\")\n\n&gt;&gt;&gt;  validation failed, list contains 144\n\n\n\nNotice that else block is useful in this situation as it is run only when for loop iteration is complete without hitting break statement.\n\n\nThere are different ways to structure the same conditions and required outcome.\n\n\n\n12.3.1.3.4 Nested loops\nPrint table of numbers from 1 through 12 for multiplication with 1 through 10.\n\nfor i in range(1, 13):\n    for j in range(1, 11):\n        end = \"\\n\" if j == 10 else \"\\t\"\n        print(i*j, end=end)\n\n&gt;&gt;&gt;  1  2   3   4   5   6   7   8   9   10\n&gt;&gt;&gt;  2  4   6   8   10  12  14  16  18  20\n&gt;&gt;&gt;  3  6   9   12  15  18  21  24  27  30\n&gt;&gt;&gt;  4  8   12  16  20  24  28  32  36  40\n&gt;&gt;&gt;  5  10  15  20  25  30  35  40  45  50\n&gt;&gt;&gt;  6  12  18  24  30  36  42  48  54  60\n&gt;&gt;&gt;  7  14  21  28  35  42  49  56  63  70\n&gt;&gt;&gt;  8  16  24  32  40  48  56  64  72  80\n&gt;&gt;&gt;  9  18  27  36  45  54  63  72  81  90\n&gt;&gt;&gt;  10 20  30  40  50  60  70  80  90  100\n&gt;&gt;&gt;  11 22  33  44  55  66  77  88  99  110\n&gt;&gt;&gt;  12 24  36  48  60  72  84  96  108 120\n\n\n\n\n\n\n12.3.2 while\n\n12.3.2.1 Specifications\nwhile condition:\n    # code block\n    [continue]\n    # code block\n    [break]\n[else]:\n    # code block\n\nloop repeats while condition is True or break statement is hit\ncontinue, break, else clauses are optional\n\nBelow diagram illustrates the control flow for a while loop.\n\nmain while block contents are executed repeatedly until condition is True\n\nif continue statement is hit\n\nloop restarts and condition is checked again\n\n\nif break statement is hit anywhere loop exits\n\nwithout going through else block even if present\n\nwhen condition is False\n\nelse block is executed if present\nloop is exited\n\n\n\n\n\n\n\n\n\n12.3.2.2 Use cases\nA while loop is needed when number of repetitions is not known in advance\n\nWhen data structure is dependent on external sources\n\ne.g. user input, web data base, …\n\nRecursive algorithms\n\nComputer science: binary search, merge sort, etc.\nMath:\n\nnumerical methods of approximations\nalgorithm to find greatest common divisor\n\n\n\n\n\n12.3.2.3 Examples\n\n12.3.2.3.1 Infinite loop\n\nto be avoided\nvery easy to create by not modifying the condition in while block\nremember ctrl + c to bail out\n\n\ncondition = True\nwhile condition:\n    # forget to set condition = False\n    print(\"inside infinite loop\")\n\n\n\n12.3.2.3.2 Basic\n\na = 6\nwhile a != 0:\n    a -= 1\n    if a == 2:\n        print(f'break block: {a = }')\n        break\n    if a == 3:\n        print(f'continue block: {a = }')\n        continue\n    print(f'main block: {a = }')\n\n&gt;&gt;&gt;  main block: a = 5\n&gt;&gt;&gt;  main block: a = 4\n&gt;&gt;&gt;  continue block: a = 3\n&gt;&gt;&gt;  break block: a = 2\n\n\n\n\n12.3.2.3.3 GCD algorithm\nBelow is gcd algorithm to find the greatest common divisor of 2 integers using while loop.\n\ngiven 2 numbers a, b\n\nfind remainder of a, b (modulo operator % gives the remainder)\nif remainder is zero then b is the gcd\nreplace a with b and b with remainder (in Python this is 1 step using multiple assignment)\ngoto to step 1\n\n\nSince the number of repetitions needed are based on input, while loop is suitable for this.\n\na, b = 9, 6\nrem = a % b\nwhile rem != 0:\n    print(f'{a = }, {b = }, {rem = }')\n    a, b = b, rem\n    rem = a % b\n\nprint(f'{a = }, {b = }, {rem = }')\nprint(b)\n\n&gt;&gt;&gt;  a = 9, b = 6, rem = 3\n&gt;&gt;&gt;  a = 6, b = 3, rem = 0\n&gt;&gt;&gt;  3\n\n\n\n\n\n\n12.3.3 Looping techniques\n\n12.3.3.1 Iterators and Iterables\nIterator is an object that can be iterated upon its elements only once. It is exhaustible.\nIterable is an object that can be iterated upon its elements repeatedly.\nBoth cannot be viewed directly and have to be converted into a list or tuple to view contents.\n\n\n\n\n\n\n\n\n\n\nBe careful while using iterators since they are consumable or exhaustible.\nDo not store them in variables for re-use.\n\n\n\nsome_tuple = \"a\", \"b\", \"c\", \"d\"\nsome_iterator = enumerate(some_tuple)\n\n\nprint(list(some_iterator))\n\n&gt;&gt;&gt;  [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]\n\n\n\nprint(list(some_iterator))\n\n&gt;&gt;&gt;  []\n\n\n\nPython functions and methods that return iterators and iterables\n\n\nIterators\nIterables\n\n\n\n\nzip\nrange\n\n\nenumerate\ndictionary.keys\n\n\nopen\ndictionary.values\n\n\n\ndictionary.items\n\n\n\n\n\n12.3.3.2 Accessing index of iterables (sequences)\nIt is very common situation where both index and value is needed while iterating over a sequence (sequence is also an iterable).\nPython provides a special function, enumerate(iterable) to access index and value of items in an iterable.\n\nsome_tuple = \"a\", \"b\", \"c\", \"d\"\nlist(enumerate(some_tuple))\n\n&gt;&gt;&gt;  [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]\n\n\n\nfor idx, item in enumerate(some_tuple):\n    print(f'{idx=}, {item=}')\n\n&gt;&gt;&gt;  idx=0, item='a'\n&gt;&gt;&gt;  idx=1, item='b'\n&gt;&gt;&gt;  idx=2, item='c'\n&gt;&gt;&gt;  idx=3, item='d'\n\n\nIt is possible to have access to index without enumerate function, which is lengthier, inconvenient and less efficient, hence not required while using Python.\n\nfor idx in range(len(some_tuple)):\n    print(f'{idx=}, item={some_tuple[idx]}')\n\n&gt;&gt;&gt;  idx=0, item=a\n&gt;&gt;&gt;  idx=1, item=b\n&gt;&gt;&gt;  idx=2, item=c\n&gt;&gt;&gt;  idx=3, item=d\n\n\n\n\n12.3.3.3 Multiple iterables\nPython provides a zip(iterable1, iterable2, ...) function which returns an iterator with tuples of elements of iterables provided until the shortest iterable is exhausted.\nThis is helpful when multiple iterables are needed to be iterated through in some connected way.\n\nsome_list = [1, 2, 3]\nsome_tuple = (4, 5, 6)\nlist(zip(some_list, some_tuple))\n\n&gt;&gt;&gt;  [(1, 4), (2, 5), (3, 6)]\n\n\n\nresult = []\nfor e1, e2 in zip(some_list, some_tuple):\n    result.append(e1 + e2)\nprint(result)\n\n&gt;&gt;&gt;  [5, 7, 9]\n\n\nThis can be achieved without zip but again since it is lengthier and inconvenient, it is not recommended while using Python.\n\nresult = []\nfor idx in range(len(some_list)):\n    result.append(some_tuple[idx] + some_list[idx])\nprint(result)\n\n&gt;&gt;&gt;  [5, 7, 9]\n\n\n\n\n12.3.3.4 Dictionary\nPython provides multiple functions to help iterating over dictionaries.\n\nkeys: d.keys()\nvalues: d.values()\nkeys, values: d.items()\n\nAll of these return a view object which is an iterator. Most commonly used is d.items() as it provides access to both key and value.\n\nsome_dict = {\"key 1\": \"value 1\", \"key 2\": \"value 2\", \"key 3\": \"value 3\"}\nfor k, v in some_dict.items():\n    print(f'key = {k}, value = {v}')\n\n&gt;&gt;&gt;  key = key 1, value = value 1\n&gt;&gt;&gt;  key = key 2, value = value 2\n&gt;&gt;&gt;  key = key 3, value = value 3\n\n\n\n\n12.3.3.5 Mutable collections\nIt is important to remember that while iterating through mutable collections (list, dict, set) it is recommended not to modify the collection as it gets complicated to handle unexpected situations. So best to use the solutions provided when in doubt rather than introducing a bug.\nIf the collection is immutable then modifying is not allowed and generally not used.\nAnother thing to note is modifying the collection in this context refers to changing the structure of collection, e.g. deleting an item. It does not refer to modifying the value of an item within the collection.\nSolutions to this are, if a mutable collection is to be modified then\n\ncreate a new collection\ncreate a copy while iterating\n\n\n12.3.3.5.1 Examples with errors\nBelow are some examples to illustrate when things go wrong when modifying a mutable collection while iterating through it.\n\n12.3.3.5.1.1 List\nIn the list in example all numbers &lt;= 3 were to be removed, but there is bug due to modifying the list while iterating over it.\nNote that 2 is not removed. Figuring out in this case is simple. In the 2nd iteration 1 was already removed from the list and second item was 3 not 2.\nThis is a simple example hence finding the bug is easy, but as programs get larger it becomes difficult and inefficient to find such bugs.\n\nnums = list(range(1, 6))\nprint(nums)\n\n&gt;&gt;&gt;  [1, 2, 3, 4, 5]\n\nfor num in nums:\n    if num &lt;= 3:\n        nums.remove(num)\n\nprint(nums)\n\n&gt;&gt;&gt;  [2, 4, 5]\n\n\n\n\n12.3.3.5.1.2 Dictionary\nIn case of dictionary it gives a run time error.\n\nsome_dict = {\"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\"}\nfor k, v in some_dict.items():\n    if k == \"k2\":\n        del some_dict[k]\n\n&gt;&gt;&gt;  Error: RuntimeError: dictionary changed size during iteration\n\n\n\n\n\n12.3.3.5.2 Solutions\n\n12.3.3.5.2.1 Create a new collection\n\nList\n\nnums = list(range(1, 6))\nnew_nums = []\nfor num in nums:\n    if not num &lt;= 3:\n        new_nums.append(num)\n\n\nprint(nums)\n\n&gt;&gt;&gt;  [1, 2, 3, 4, 5]\n\nprint(new_nums)\n\n&gt;&gt;&gt;  [4, 5]\n\n\n\n\nDictionary\n\nsome_dict = {\"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\"}\nnew_dict = {}\nfor k, v in some_dict.items():\n    if not k == \"k2\":\n        new_dict[k] = v\n\n\nprint(some_dict)\n\n&gt;&gt;&gt;  {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'}\n\nprint(new_dict)\n\n&gt;&gt;&gt;  {'k1': 'v1', 'k3': 'v3'}\n\n\n\n\n\n12.3.3.5.2.2 Create a copy\n\nList\n\nnums = list(range(1, 6))\nprint(nums)\n\n&gt;&gt;&gt;  [1, 2, 3, 4, 5]\n\nfor num in nums.copy():\n    if num &lt;= 3:\n        nums.remove(num)\n\n\nprint(nums)\n\n&gt;&gt;&gt;  [4, 5]\n\n\n\n\nDictionary\n\nsome_dict = {\"k1\": \"v1\", \"k2\": \"v2\", \"k3\": \"v3\"}\nprint(some_dict)\n\n&gt;&gt;&gt;  {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'}\n\nfor k, v in some_dict.copy().items():\n    if k == \"k2\":\n        del some_dict[k]\n\n\nprint(some_dict)\n\n&gt;&gt;&gt;  {'k1': 'v1', 'k3': 'v3'}"
  },
  {
    "objectID": "content/building-blocks/control-flow.html#sec-error-handlers",
    "href": "content/building-blocks/control-flow.html#sec-error-handlers",
    "title": "12  Control Flow",
    "section": "12.4 Error handlers",
    "text": "12.4 Error handlers\n\n12.4.1 Introduction\n\n12.4.1.1 Errors\n\ngiven the number of rules and syntax there are a lot of opportunities for errors\n2 broad categories\n\nSyntax error: caught when the code is being parsed\n\nparsed means interpreter is reading the code to figure out what is to be done\ncommonly referred to as compile time error\n\nException: error detected during execution\n\ncommonly referred to as run time error\n\n\nSyntax error\n\n\na =, 2\n\n&gt;&gt;&gt;  invalid syntax (&lt;string&gt;, line 1)\n\n\n\nException\n\n\n# try:\n#     1/0\n# except Exception as e:\n#     print(e)\neg_num = 1/0\n\n&gt;&gt;&gt;  Error: ZeroDivisionError: division by zero\n\n\nWhen a run time error occurs, program stops and exception messages are printed along with the traceback. Traceback is a track of where the error occurred in the program to which part of the program lead to running of the line which caused the error.\n\n\n12.4.1.2 Exceptions\nPython has some built-in known exceptions or error types. Exceptions are objects built using object oriented programming.\n\nExamples\n\nException: base catch almost all errors\nZeroDivisionError: division by zero\nTypeError: operation not supported by type[s] used in operation\n\nOn run time error, an Exception type object is created which has information regarding\n\nException type\ntraceback\n\n\nBelow figure shows Python’s built-in Exception hierarchy. More details can be found at Python documentation for built in exceptions.\n\n\n\n\n\n\n12.4.1.2.1 raise\nraise statements causes the program to stop with default exception. Optionally a known error can be passed with a custom message, e.g. raise ValueError(\"Invalid input\"). raise statement can be used anywhere in the program but is suited for use with try and while blocks, when an expected error is intercepted and has to handled differently.\nraise ValueError(\"some custom message\")\n\n\n\n12.4.1.3 Examples\nBelow are some examples of common errors which are recommended to be tried and experimented in jupyter notebook cells. See the error messages and map them to the Exception hierarchy. Look at the traceback to see how it is structured.\n\n1/0\n\n&gt;&gt;&gt;  Error: ZeroDivisionError: division by zero\n\n\n\nundefined_var_name\n\n&gt;&gt;&gt;  Error: NameError: name 'undefined_var_name' is not defined\n\n\n\nsome_list = [1, 2, 3]\nprint(some_list[10])\n\n&gt;&gt;&gt;  Error: IndexError: list index out of range\n\n\n\nfloat(\"text\")\n\n&gt;&gt;&gt;  Error: ValueError: could not convert string to float: 'text'\n\n\n\n\"abc\"*\"xyz\"\n\n&gt;&gt;&gt;  Error: TypeError: can't multiply sequence by non-int of type 'str'\n\n\n\n\n\n12.4.2 try blocks\ntry...except blocks are used to intercept and handle expected run time errors differently. It provides many options like\n\nignore the error and continue running the program\ndo some clean up before letting the error stop the program\nrun some code irrespective of error or not\n\nNote that exception handling has a large number of specifications which can be combined in a lot of ways which can lead to complexity in the beginning. This is being covered with the objective of simple usage. All the specifications are for completeness and information.\n\n12.4.2.1 Specifications\ntry...[except]...[else]...[finally]\ntry:\n    # try code block\n[except Exception as e:\n    # except code block\n    [raise]]\n[else:\n    # else code block]\n[finally:\n    #  finally code block]\n\nrequired\n\nthere must be at-least one except or finally block\nelse clause (if present) should be after the except block\n\noptional\n\nthere can be multiple except clauses\nraise statement and else block are optional\n\ntry block statements are always evaluated first\nexcept blocks are run when they trap specified error\n\nif raise statement is hit\n\nfinally block is run\nprogram is stopped with the &lt;Exception type&gt; raised\n\n\nelse block is run in case of no error\nfinally block is run always, error or no error\n\ngenerally used for clean up\n\n\n\n\n\n\n\n\n12.4.2.1.1 except blocks\nexcept statement in a try block is used to declare an except block. They can be used in 2 forms.\n\nexcept &lt;Exception type&gt;\nexcept &lt;Exception type&gt; as &lt;variable name&gt;\n\nexcept block is run if there is a run time error while executing try block and the error matches the &lt;Exception type&gt; specified.\nWhen second form is used, &lt;variable name&gt; is bound to the &lt;Exception type&gt; object.\nThere are 2 concepts involved.\n\nwhich Exception is supposed to be handled, e.g. NameError, TypeError, etc.\nerror object\n\nThe first concept is of using the exception type. Base Exception catches all known errors and is the most generic. In the beginning it should be enough. As the requirements increase there is a need to specify more specific errors. For multiple except blocks, it is recommended to have specific exceptions before generic exceptions\nThe second is the error object. In the beginning it is not of much use as handling the exception should be enough, but as you progress it is this object which helps in dealing different errors differently as it holds a lot of information, like the traceback.\n\n\n\n12.4.2.2 Use cases\nTry blocks are generally used to intercept expected errors and control the outcome if error occurs, use case depends on the context. e.g. \n\navoid stopping program on an expected error\n\nwhen program depends on external sources, e.g. db operations, web requests, …\n\ndo something on an expected error and then raise the error\nhandle different error types differently\n\n\n\n12.4.2.3 Examples\n\n12.4.2.3.1 Ask user input until it is correct\nThis is an example for nesting different control flow techniques.\nThe same problem serves as a use case for using recursive functions which is discussed in Section 13.9.1.3.\n\nwhile True:\n    try:\n        some_int = int(input('Enter an integer...'))\n        print(some_int)\n        break\n    except ValueError:\n        continue"
  },
  {
    "objectID": "content/building-blocks/functions.html#introduction",
    "href": "content/building-blocks/functions.html#introduction",
    "title": "13  Functions",
    "section": "13.1 Introduction",
    "text": "13.1 Introduction\n\n13.1.1 Terminology\nHistorically, as the programming languages were evolving, the terminology reflected the state at the time. The terminology has spilled over loosing its context. Below is what was the terminology with intended context.\n\nSub-routine: any named block of code that can be called (run) using its name\n\nProcedure: any sub-routine that\n\nhas side effects\ndoes not take any input\ndoes not return anything\n\n(Pure) Function: any sub-routine that\n\ndoes not have side effects, does not leave its trace after execution\ntakes inputs and operates only on the inputs\nreturns something\n\n\n\nIn current popular languages there are just functions which can take any of the forms, function is the only term in language specification.\n\n\n13.1.2 Background\nFunctions are a major pillar in any programming language, that help to repeat related tasks with code reuse.\nAt more abstract level, functions provide\n\nmeans of combination\n\nbuild smaller pieces and then join to make a bigger piece\n\nmeans of encapsulation\n\nhide details of implementation during usage\n\nmeans of abstraction:\n\ncreate blueprints of functionality\n\n\nA function can be thought of as a black-box which may takes some input and produces some output or performs a task in background. Black boxes can be combined to create new black boxes.\n\n\n13.1.3 Components of a function\n\n\n\n\nA simple function has following parts\n\nname\nparameters (optional)\nbody (code)\n\ndocstring (optional, beginning)\nreturn statement (optional)\n\n\n\n\n\n\n\n\n\n\n\n13.1.4 Usage\nA function can be\n\ncalled function_name(parameter_1 = argument_1, ...)\nstored variable_name = function_name\npassed function_name_2(variable_name = function_name)\n\nFunctions can be called from any block, e.g. control flow block, body of another function. This allows means of combination, to build smaller functionalities and then join them to create a bigger function or program.\n\n\n13.1.5 Functions are callable\n\nIn simplest form a function call\n\n(optionally) receives arguments (value) for some predefined parameters\n(optionally) runs some code to execute certain operation[s]\n(optionally) returns some object[s]\ne.g. some_func(), len(iterable), add(1, 2), …\n\nA function call can have side effects\n\nit does something in background, e.g. write to a database\nmay or may not return any object\n\n\n\n\n13.1.6 Functions are objects\nIn Python, like many other high level programming languages, functions are objects, therefore they can be\n\nassigned to a variable\nstored in a data structure (such as list, tuple, dictionary, …)\npassed to a function as an argument\nreturned from a function\n\n\n\n13.1.7 Different forms of functions\n\nRegular functions\nAnonymous functions: lambda expressions\nPartials: new function from an existing function with partial set of arguments provided\nHigher order functions: take function[s] as arguments and optionally return function[s]\n\n\n\n13.1.8 Lifetime of functions\nThis section might not be fully understood before going through namespaces and scopes (Chapter 16) in architecture part of the book, where this is covered in more detail.\n\nAt compile time (when the function definition is read)\n\nfunction object is created without evaluation, except\n\nobjects are created for parameters with default values\ndefault values are objects stored in function object\n\ncode is stored in the function object\nvariables are assigned scopes\n\nAt run time (when the function is called)\n\na new local scope is created in the calling environment\nvariable names are looked up in assigned scopes\nfunction code is evaluated"
  },
  {
    "objectID": "content/building-blocks/functions.html#basic-specifications",
    "href": "content/building-blocks/functions.html#basic-specifications",
    "title": "13  Functions",
    "section": "13.2 Basic Specifications",
    "text": "13.2 Basic Specifications\n\n13.2.1 First line\n\n\n\n\nstatement starting with keyword def declares a function definition\ndef must be followed by\n\nfunction name\na pair of parenthesis ending in :\n\nparenthesis on the first line can optionally contain parameters\n\nparameters can optionally be annotated with type\n\ntypes are not evaluated\ne.g. def func(a:int, b:str) -&gt; str:\n\n-&gt; str indicates the function returns a str type object\n\n\ndetailed discussion on parameters separately in parameters section\n\ncolon (:) must be followed by function body\n\nif function body is too short it can be included on the same line\n\n\n\n\n \n\n\ndef function_name(a, b):\n    # code block\n    return result_object\n\n\n\nBelow are examples of some short functions that can be declared on a single line. Last 2 are also example of using functions as placeholders, functions which are declared but have to be implemented later.\ndef some_short_func(x, y): return x + y\ndef some_short_func(): pass\ndef some_short_func(): \"\"\n\n\n13.2.2 Function body\n\n\n\nmust be indented\nfirst line can optionally be a doc string\noptionally contain return\noptionally contain pass\n\n\n\n\ndef function_name(a, b):\n    \"\"\"function description\n    parameter 1: description\n    returns: description\n    \"\"\"\n    # code block\n    return result_object\n\n\n\n\n13.2.3 Doc strings\nDoc strings are used to document functions. They can be multiline strings.\nDoc strings are critical for large projects or packages with a lot of code. Editor help pop ups use the doc strings.\nsphinx is the most popular python framework for automating documentation.\nEven for small projects documentation can be useful for later use. Comments can be used for documentation, but automated doc strings providers help structure the documentation and make the process efficient.\nFor example, VSCode extension, autoDocstring - Python Docstring Generator can be used to assist in creating docstrings.\nUsing such tools help use best practices evolved by experience of developers.\n\n\n13.2.4 pass statement\n\npass statement does not alter control flow\nused as place holder for functions to be implemented\ncan be replaced by a doc string\n\n\ndef some_func(): pass\n\ndef some_func(): \"\"\n\n\n\n13.2.5 return statement\n\nsyntax: return [expression_list]\nexpression_list can be\n\na single object\ncomma separated objects which are turned to a tuple\n\ncontrol flow:\n\nwhen a return statement is hit anywhere in the code block\n\nexpression_list, if present, is evaluated and returned\nNone returned if there is no expression\nfunction call is exited\n\nexception: when return is hit from try..except..else..finally block\n\nfinally block is run before the function call is exited"
  },
  {
    "objectID": "content/building-blocks/functions.html#parameters-and-arguments",
    "href": "content/building-blocks/functions.html#parameters-and-arguments",
    "title": "13  Functions",
    "section": "13.3 Parameters and arguments",
    "text": "13.3 Parameters and arguments\n\n13.3.1 Definitions\n\nParameters: are input variables in context of defining the function\nArguments: are variables or objects passed to parameters in context of calling the function\nExample\n\na and b are parameters of some_func\n10 and x are arguments of some_func\n\n\ndef some_func(a, b):\n  # code block\n  pass\n\nx = \"a string\"\n\nsome_func(10, x) # function call\n\n\n13.3.2 Object passing\nIn Python, the arguments are passed as object references to the parameters. Therefore if the object passed is mutable, changes will be propagated.\n\nan_int = 10; a_string = \"abc\"; a_tuple = (an_int, a_string)\na_list = [*a_tuple]\n\ndef a_func(x1, x2, x3, x4):\n    x4.append(\"xyz\")\n    print('-'*20)\n    print('from within function call')\n    print(x1 is an_int, x2 is a_string, x3 is a_tuple, x4 is a_list)\n    print('-'*20)\n    return x1, x2, x3, x4\n\nret_tuple = a_func(x1=an_int, x2=a_string, x3=a_tuple, x4=a_list)\n\nprint(ret_tuple[0] is an_int, ret_tuple[1] is a_string, \\\n        ret_tuple[2] is a_tuple, ret_tuple[3] is a_list)\n\nprint(f'{a_list=}')\n\n&gt;&gt;&gt;  --------------------\n&gt;&gt;&gt;  from within function call\n&gt;&gt;&gt;  True True True True\n&gt;&gt;&gt;  --------------------\n&gt;&gt;&gt;  True True True True\n&gt;&gt;&gt;  a_list=[10, 'abc', 'xyz']\n\n\n\n\n13.3.3 Argument types\nBased on how parameters are defined arguments can be passed in different ways\n\npositional arguments: are passed to parameters using position during a function call\nkeyword arguments: are passed to parameters using keyword (parameter name) during a function call, also called named parameters\noptional/default arguments: any parameter with default value specified makes the argument optional\n\nwith positional arguments order has to be kept in mind\n\n\n\n13.3.3.1 Examples\ndef some_func(a, b):\n    pass\nsome_func(10, 20) # passed as positional\nsome_func(a = 10, b = 20) # passed as keyword\n\ndef some_func(a, b=20): # b is optional\n    print(f'{a = }, {b = }')\n\n\nsome_func(10)\n\n&gt;&gt;&gt;  a = 10, b = 20\n\nsome_func(10, 30)\n\n&gt;&gt;&gt;  a = 10, b = 30\n\nsome_func(a = 10)\n\n&gt;&gt;&gt;  a = 10, b = 20\n\nsome_func(b = 30, a = 10)\n\n&gt;&gt;&gt;  a = 10, b = 30\n\n\n\n\n\n13.3.4 Specifications\n\nGeneral structures for defining parameters (/, *, **)\n\nfunction_name(&lt;pos or kw&gt;)\nfunction_name(&lt;pos&gt;, /, &lt;po or kw&gt;, *, &lt;kw&gt;)\nfunction_name(&lt;pos&gt;, /, &lt;po or kw&gt;, *args, &lt;kw&gt;, **kwargs)\n\nregular arguments: by default all arguments can be passed as positional or keyword subject to\n\npositional arguments must come before keyword arguments\nonce a keyword argument is given all remaining arguments are keyword\n\nafter one default argument, remaining must be default\n\nexcept for keyword only arguments\n\nseparation\n\n/ is used to separate positional only arguments\n* is used to separate keyword arguments\n\ncollection (variadic arguments)\n\n*args collects all available positional arguments as a tuple\n\nhas to be defined after other positional arguments if present\nargs is just convention, can be name of choice, but recommended\n\n**kwargs can collect all available keyword arguments as a dictionary\n\nhas to be defined at the end\nkwargs is just convention, can be name of choice, but recommended\n\n\n* and *args mark the beginning of keyword arguments, hence cannot precede /\n\n\n\n13.3.5 Use cases\n\nas a user of packages\n\nregular arguments are needed mostly\nwhile using external packages familiarity with the specifications will help\n\npositional only parameters are used when\n\nparameter names have no meaning\nreliance on keyword for passing arguments has to be avoided\ne.g. print function: multiple objects can be passed before any kw arg\n\nkeyword only parameters are used when\n\nnames have special meaning\nreliance on positional arguments has to be avoided\ne.g. print function: end, sep etc. have to be passed after all positional variadic args as kw\n\n\n\n\n13.3.6 Examples\nRegular arguments: by default all arguments can be passed as positional or keyword subject to\n\npositional arguments must come before keyword arguments\nonce a keyword argument is given all remaining arguments must be keyword\n\n\ndef some_func(a, b, c):\n    pass\n\n\n\n\n\n\n\n\n\nAllowed\n\n\n\n\nsome_func(10, 20, 30)\nsome_func(10, 20, c = 30)\nsome_func(10, b = 20, c = 30)\n\n\n\n\n \n\n\n\n\n\n\n\nNot allowed\n\n\n\n\nsome_func(a = 10, 20, 30)\nsome_func(10, b = 20, 30)\nsome_func(a = 10, b = 20, 30)\n\n\n\n\n\n\n13.3.6.1 Separation\n\n/ is used to separate positional only arguments\n* is used to separate keyword arguments\n\n\ndef some_func(pos_1, pos_2, /, pos_or_kw_1, *, kw_1, kw_2):\n    print(f\"{pos_1=}, {pos_2=}, {pos_or_kw_1=}, {kw_1=}, {kw_2=}\")\n\n\nsome_func(1, 2, 3, kw_1=4, kw_2=5)\n\n&gt;&gt;&gt;  pos_1=1, pos_2=2, pos_or_kw_1=3, kw_1=4, kw_2=5\n\nsome_func(1, 2, pos_or_kw_1=3, kw_1=4, kw_2=5)\n\n&gt;&gt;&gt;  pos_1=1, pos_2=2, pos_or_kw_1=3, kw_1=4, kw_2=5\n\nsome_func(1, pos_2=2, pos_or_kw_1=3, kw_1=4, kw_2=5)\n\n&gt;&gt;&gt;  Error: TypeError: some_func() got some positional-only arguments passed as keyword arguments: 'pos_2'\n\n\n\n\n13.3.6.2 Variadic arguments\n\ncollection (variadic arguments)\n\n*args collects all available positional arguments as a tuple\n\nhas to be defined after other positional arguments if present\nargs is just convention, can be name of choice, but recommended\n\n**kwargs can collect all available keyword arguments as a dictionary\n\nhas to be defined at the end\nkwargs is just convention, can be name of choice, but recommended\n\n\n\n\ndef some_func(*args, **kwargs):\n    print(f'{args}')\n    print(f'{kwargs}')\n\n\nsome_func(1, 2, 3)\n\n&gt;&gt;&gt;  (1, 2, 3)\n&gt;&gt;&gt;  {}\n\nsome_func(1, 2, 3, a = 4, b = 5)\n\n&gt;&gt;&gt;  (1, 2, 3)\n&gt;&gt;&gt;  {'a': 4, 'b': 5}\n\n\n\nargs is just convention, can be name of choice, but recommended\nkwargs is just convention, can be name of choice, but recommended\n\n\ndef some_func(*args_tuple, **kw_dict):\n    print(f'{args_tuple}')\n    print(f'{kw_dict}')\n\n\nsome_func(1, 2, 3)\n\n&gt;&gt;&gt;  (1, 2, 3)\n&gt;&gt;&gt;  {}\n\nsome_func(1, 2, 3, a = 4, b = 5)\n\n&gt;&gt;&gt;  (1, 2, 3)\n&gt;&gt;&gt;  {'a': 4, 'b': 5}\n\n\n\n\n13.3.6.3 More Examples\n::: {.cell hash=‘functions_cache/html/unnamed-chunk-13_ffb5c0d9e3072c74f3def0fe69a9bef4’}\n\n\n\n\n\n\n\n\n\n\n\n\ndef func(a, b, *args)\n\n\n\n\n\n2 regular arguments\n\n\narbitrary remaining positional arguments collected in args tuple\n\n\nif any regular argument passed as keyword, args cannot be used\n\n\n\n\n\n\n\ndef func(a, b, *args, kw1, kw2=100)\n\n\n\n\n\n2 regular arguments\n\n\narbitrary remaining positional arguments collected in args tuple\n\n\n2 keyword arguments with one optional\n\n\nif any regular argument passed as keyword args cannot be used\n\n\n\n\n\n\n\ndef func(a, b=10, /, reg1, reg2=100)\n\n\n\n\n\nthis will not work\n\n\nb is positional only + default and there is non default reg1 after it\n\n\n\n\n\n\n\ndef func(a, b=10, *, kw1, kw2=100, **kwargs)\n\n\n\n\n\nthis will work\n\n\norder of default parameters is not important for keyword only arguments\n\n\n\n\n\n\n\ndef func(*args, **kwargs)\n\n\n\n\n\ncollects arbitrary number of positional arguments\n\n\ncollects arbitrary number of keyword arguments\n\n\n\n\n\n:::"
  },
  {
    "objectID": "content/building-blocks/functions.html#examples-2",
    "href": "content/building-blocks/functions.html#examples-2",
    "title": "13  Functions",
    "section": "13.4 Examples",
    "text": "13.4 Examples\n\n13.4.1 Check primes\nPrime is a positive integer greater than 1 which is divisible only by 1 and itself. E.g. 2, 3, 5, …\nGiven a positive integer check if it is a prime. Print a message confirming the result.\n\ndef check_prime(num: int) -&gt; None:\n    \"\"\"\n    check if a number is prime and print the result\n    num: positive integer\n    returns: None\n    \"\"\"\n    if not isinstance(num, int):\n        print(f'{num} is not an integer')\n        return\n    if num &lt;= 1:\n        print(f'{num} is not a positive integer greater than 1')\n        return\n    divisors = []\n    for i in range(1, num + 1):\n        if num % i == 0: divisors.append(i)\n    if divisors == [1, num]:\n        print(f'{num} is a prime')\n    else:\n        print(f'{num} is not a prime')\n\n\ncheck_prime(10)\n\n&gt;&gt;&gt;  10 is not a prime\n\ncheck_prime(23)\n\n&gt;&gt;&gt;  23 is a prime\n\ncheck_prime(1)\n\n&gt;&gt;&gt;  1 is not a positive integer greater than 1\n\ncheck_prime(-2)\n\n&gt;&gt;&gt;  -2 is not a positive integer greater than 1\n\n\n\n\n13.4.2 GCD\nImplement the gcd algorithm using a function that takes 2 numbers as input and returns the greatest common divisor.\nBelow is gcd algorithm to find the greatest common divisor of 2 integers.\n\ngiven 2 numbers a, b\n\nfind remainder of a, b (modulo operator % gives the remainder)\nif remainder is zero then b is the gcd\nreplace a with b and b with remainder (in python this is 1 step using multiple assignment)\ngoto to step 1\n\n\nBelow is what was implemented using while loop in control flow chapter. Note that every time gcd has to be calculated inputs have to be changed and the whole code has to be run.\n\na, b = 9, 6\nrem = a % b\nwhile rem != 0:\n    print(f'{a = }, {b = }, {rem = }')\n    a, b = b, rem\n    rem = a % b\n\nprint(f'{a = }, {b = }, {rem = }')\nprint(b)\n\n&gt;&gt;&gt;  a = 9, b = 6, rem = 3\n&gt;&gt;&gt;  a = 6, b = 3, rem = 0\n&gt;&gt;&gt;  3\n\n\n\ndef calc_gcd(num_1: int, num_2: int) -&gt; int:\n    \"\"\"\n    Calculate and return the greatest common divisor of 2 integers\n    \"\"\"\n    rem = num_1 % num_2\n    while rem != 0:\n        num_1, num_2 = num_2, rem\n        rem = num_1 % num_2\n    return num_2\n\nHaving defined the function, it can be called multiple times with different values without worrying about the implementation. This serves as an example of means of encapsulation.\n\ncalc_gcd(3, 9)\n\n&gt;&gt;&gt;  3\n\ncalc_gcd(12, 45)\n\n&gt;&gt;&gt;  3"
  },
  {
    "objectID": "content/building-blocks/functions.html#caveat-for-default-values",
    "href": "content/building-blocks/functions.html#caveat-for-default-values",
    "title": "13  Functions",
    "section": "13.5 Caveat for default values",
    "text": "13.5 Caveat for default values\nWhen using mutable data types (like list, dictionary or set) as default values for function parameters, the behavior has to be looked out for. Default values are typically used for immutable data types like numbers, strings or bool.\nIt is important to note that default values are created once in memory, when the def statement is executed for creating the function object, i.e. at compile time. Not during a function call.\nCheck the result of below function calls. Trying out python tutor will help understand this more clearly.\n\ndef some_func(num, some_list=[]):\n    some_list.append(num)\n    return some_list\n\nprint(some_func(1))\nprint(some_func(2))\n\n&gt;&gt;&gt;  [1]\n&gt;&gt;&gt;  [1, 2]\n\n\nNote that during second call same list was used. There are situations when this default behavior has to be avoided. Below is an approach to get around this.\n\ndef some_func(num, some_list=None):\n    if some_list == None: some_list = []\n    some_list.append(num)\n    return some_list\n\nprint(some_func(1))\nprint(some_func(2))\n\n&gt;&gt;&gt;  [1]\n&gt;&gt;&gt;  [2]"
  },
  {
    "objectID": "content/building-blocks/functions.html#lambda-expressions",
    "href": "content/building-blocks/functions.html#lambda-expressions",
    "title": "13  Functions",
    "section": "13.6 lambda expressions",
    "text": "13.6 lambda expressions\nLambda expressions are anonymous and short functions, typically used to create very short functions to be passed around or for cleaner syntax.\nGeneric name is anonymous functions. Most languages provide a mechanism to create and pass anonymous functions. In Python, they are called lambda expressions.\n\nSyntax\n\nlambda keyword is used to create lambda expressions\nlimited to a single expression\nreturn keyword is not required, expression is returned\nexample: lambda x, y: x * y\n\n\nf = lambda x, y: x * y\nprint(f)\n\n&gt;&gt;&gt;  &lt;function &lt;lambda&gt; at 0x7f39543672e0&gt;\n\nprint(f(2, 3))\n\n&gt;&gt;&gt;  6"
  },
  {
    "objectID": "content/building-blocks/functions.html#partials",
    "href": "content/building-blocks/functions.html#partials",
    "title": "13  Functions",
    "section": "13.7 Partials",
    "text": "13.7 Partials\nPartials are functions created from other functions by passing a subset of required arguments.\nfunctools module in standard library provides a higher order function partial to create partials.\n\n13.7.1 Use cases\n\nPartials are often used in functional programming where functions are passed around as arguments. e.g. functionals like map, filter and reduce take functions as argument where partials are needed. They are discussed in Section 13.8.1.\nAnother use is when an existing function has to be used multiple times with certain set of arguments specified.\n\nAs an example in an application if print function is needed to be used multiple times with argument sep=\"\\n\" then a partial can be created using original print function.\n\nimport functools as ft\ncustom_print = ft.partial(print, sep=\"\\n\")\nsome_list = [1, 2, 3]\ncustom_print(*some_list)\n\n&gt;&gt;&gt;  1\n&gt;&gt;&gt;  2\n&gt;&gt;&gt;  3"
  },
  {
    "objectID": "content/building-blocks/functions.html#sec-hof",
    "href": "content/building-blocks/functions.html#sec-hof",
    "title": "13  Functions",
    "section": "13.8 Higher order functions",
    "text": "13.8 Higher order functions\nHigher order functions evolved as part of functional programming paradigm where functions are treated as objects.\n\nHigher order functions are functions that\n\ntake function[s] as input\noptionally return function[s]\n\nHigher order functions along with rules of scoping are used to create different types of functions\nDesign patterns created using higher order functions\n\nMap-Reduce: apply some function to elements of a collection\nFactory functions: create new functions based on some input argument\nDecorator functions: add some standard functionality to a function\n\nPython standard library has some modules/packages to help with these\n\nfunctools: Higher-order functions and operations on callable objects\noperators: Standard operators as functions\n\n\n\n13.8.1 Map Reduce\nMap-Reduce is a design pattern to work with collections. These are newer features in high level languages like Python. They provide a better and cleaner alternative to iterative solutions using loops for working with collections.\nFilter is a special case of map. Collectively these are also referred to as functionals.\nFunctionals are a good example of design patterns to improve desired properties of program. All the 3 forms improve code readability as the syntax is concise and it is easier to spot what is being done by isolating it from iteration.\nFor example, map is a generic concept which improves\n\nReadability\n\niteration is isolated from what operation is being done, hence better readability\n\nModularity\n\nmap is responsible for iteration\nfunction passed is responsible for operation to be applied to each element\n\nExtensibility\n\nfunction passed can be anything, so different operations can be applied by defining new functions without impacting the core functionality of iterating and applying the function.\n\nTestability\n\nit is easier to test and debug as the structure is modular\n\nEfficiency\n\nmap is faster than loop but slower than comprehensions\n\n\n\n13.8.1.1 Map\nMap is a generic concept of applying (mapping) a function to all elements of a collection or multiple collections in parallel.\nMap is a better alternative to for loops as code readability is improved as what is being done is isolated from iteration.\n\nSyntax\n\nmap(function, iterable[, iterables]) is the Python implementation\n\nreturns an iterator (consumable, can be used once)\n\nWith single iterable: function applied should take 1 argument which will be elements of the iterable\nWith multiple iterables\n\nfunction applied should take as many arguments as iterables\nmap stops at iterable of shortest length, if lengths are different\n\n\n\n\n\n\n\n\n\nsingle iterable\n\n\n\n\n \n\n\n\n\n\nmultiple iterables\n\n\n\n\n\n\n13.8.1.1.1 Example: Single iterable\nTo find the square of all numbers in a list (container) below are different solutions. Note that underlying operation is simple, apply some operation to elements of a collection. This is a very common situation encountered while programming.\n\nsome_list = list(range(5))\n\n\n13.8.1.1.1.1 Loop\n\nsqrd_list = []\nfor x in some_list:\n    sqrd_list.append(x**2)\n\n\n\n&gt;&gt;&gt;  sqrd_list = [0, 1, 4, 9, 16]\n\n\n\n\n13.8.1.1.1.2 Map\n\ndef sqr(x):\n    return x**2\n\nsqrd_itr = map(sqr, some_list)\n\n\n\n&gt;&gt;&gt;  list(sqrd_itr) = [0, 1, 4, 9, 16]\n\n\n\n\n13.8.1.1.1.3 Map & lambda\n\nsqrd_itr = map(lambda x: x**2, some_list)\n\n\n\n&gt;&gt;&gt;  list(sqrd_itr) = [0, 1, 4, 9, 16]\n\n\n\n\n\n13.8.1.1.2 Example: Multiple iterables\n\nadd numbers in 2 tuples\n\nNote that lengths of iterables is different in example so result is accordingly of length of shortest iterable.\nIf function to map is complex, define a regular function and pass the name to map.\n\ntuple_1 = 1, 2, 3\ntuple_2 = 4, 5\n\n\ntuple(map(lambda x, y: x + y, tuple_1, tuple_2))\n\n&gt;&gt;&gt;  (5, 7)\n\n\n\ntuple(map(lambda x, y: x + y, tuple_2, tuple_1))\n\n&gt;&gt;&gt;  (5, 7)\n\n\n\n\n\n13.8.1.2 Filter\nFilter is a generic concept of filtering values from a collection using certain conditions. Note that it is a special case of map.\n\nSyntax\n\nfilter(function, iterable) is provided in Python\n\nreturns an iterator (consumable, can be used only once)\nfunction should return true or false when acting on an element\nif function is None then all truthy elements are returned\n\n\n\n\n13.8.1.2.1 Example: None\n\nsome_list = [1, 0, None, '', 'abc', tuple()]\n\n\nlist(filter(None, some_list))\n\n&gt;&gt;&gt;  [1, 'abc']\n\n\nBelow is the same task done using iterative solution.\n\nfiltered_list = []\nfor item in some_list:\n    if item: filtered_list.append(item)\nfiltered_list\n\n&gt;&gt;&gt;  [1, 'abc']\n\n\n\n\n13.8.1.2.2 Example\n\nfilter positive integers from a list\n\n\nsome_list = [-2, -1, 0, 1, 2]\n\n\n[*filter(lambda x: x &gt; 0, some_list)]\n\n&gt;&gt;&gt;  [1, 2]\n\n\nBelow is the same task implemented using iterative solution.\n\nfiltered_list = []\nfor item in some_list:\n    if item &gt; 0: filtered_list.append(item)\n\n\nfiltered_list\n\n&gt;&gt;&gt;  [1, 2]\n\n\n\n\n\n13.8.1.3 Reduce\nReduce is a generic concept of aggregating elements of a collection into single result.\nThe actual underlying operation is to apply a function (operation) to 2 items at a time recursively.\nLet a collection of n elements be \\(collection = [e_0, e_1, e_2, e_3, e_4, \\cdots, e_{n - 1}]\\). What reduce does is\n\nresult of step 1: \\(r_1 = f(e_0, e_1)\\)\nresult of step 2: \\(r_2 = f(r_1, e_2)\\)\nresult of step 3: \\(r_3 = f(r_2, e_3)\\)\n…\nresult of step n - 1: \\(r_{n - 1} = f(r_{n - 2}, e_{n - 1})\\)\n\nOptionally an initial value can be given which is used as the base case, step 1 uses this value and the first element. This is also used in case the collection has 0 or 1 element.\nNote that there will be an error if the collection is empty and no initializer is specified.\nFor example, sum of some numbers is applying reduce and cumulative sum of some numbers is the intermediate result of reduce.\nReduce is less often used in comparison to map and filter most often used to create aggregate tables and data.\nPython standard library has tools to apply reduce and accumulate.\n\nfunctools.reduce(function, iterable[, initializer])\nitertools.accumulate(iterable[, func, *, initial=None])\n\n\n13.8.1.3.1 Example\nTo find the sum of numbers in a list using iterative solution and reduce.\n\nsome_list = list(range(10))\nprint(some_list)\n\n&gt;&gt;&gt;  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nsum_itr = 0\nfor num in some_list:\n    sum_itr += num\n\n\nsum_itr\n\n&gt;&gt;&gt;  45\n\n\n\nimport functools as ft\nimport operator as op\n\nsum_red = ft.reduce(op.add, some_list, 0)\n\n\nsum_red\n\n&gt;&gt;&gt;  45\n\n\n\nInstead of defining add_func = lambda x, y: x + y, operator module was used."
  },
  {
    "objectID": "content/building-blocks/functions.html#recursive-functions",
    "href": "content/building-blocks/functions.html#recursive-functions",
    "title": "13  Functions",
    "section": "13.9 Recursive functions",
    "text": "13.9 Recursive functions\n\nRecursion is a generic concept of repeating a smaller well define task to get to a solution using base case[s]\n\ne.g. gcd algorithm\n\nRecursion can be implemented using iterative solution or recursive functions\n\nrecursive functions are not most efficient but better in terms of\n\ncode readability\nmaintainability\n\n\nRecursive functions call themselves from within themselves to terminate when the base case[s] is reached\n\nbase case[s] need to be defined carefully to avoid infinite recursive calls\n\nDo not use recursive functions unless it is unavoidable\n\nmerge sort is an example of recursive algorithm that is efficient\n\n\nTo understand how recursive functions create nested scopes, Python tutor is a good tool. It helps visualize how nested local scopes are created and destroyed at run time during recursive function calls.\nRecursive functions are used in algorithms, specially when normal approaches like iteration become infeasible. Therefore in the beginning there is not much point to spend a lot of time on this, but it is good to understand the concept as it might come handy in some situations. An example would be when there is an expected error that you want to handle and retry.\n\n13.9.1 Examples\n\n13.9.1.1 Factorial\n\\[\n\\begin{aligned}\nn! &= n*(n-1)*(n-2)*\\cdots*1 \\\\\n&= n * (n-1)! \\\\\n0! &= 1\n\\end{aligned}\n\\]\n\n\n\n13.9.1.1.1 Iterative Solution\ndef fact_iter(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result\n\n\n \n\n\n13.9.1.1.2 Recursive solution\ndef fact_rec(n):\n    if n == 0:\n        return 1\n    else:\n        return n*fact_rec(n-1)\n\n\n\nNote that recursive solution can be cleaned further using the ternary operator and lambda expression.\n\nfact_rec = lambda n: 1 if n == 0 else n*fact_rec(n-1)\n\n\n\n13.9.1.2 GCD Algorithm\n\n\n\n\nGiven 2 numbers a, b\n\nfind remainder of a, b (modulo operator % gives the remainder)\nif remainder is zero then b is the gcd\nreplace a with b and b with remainder (in Python this is 1 step)\ngoto to step 1\n\nEarlier this was solved using while\nImplement this using\n\nregular function\nrecursive function\n\n\n\n\n \n\n\na, b = 9, 6\nrem = a % b\nwhile rem != 0:\n    print(f'{a=}, {b=}, {rem=}')\n    a, b = b, rem\n    rem = a % b\n\nprint(f'{a=}, {b=}, {rem=}')\nprint(b)\n\n&gt;&gt;&gt;  a=9, b=6, rem=3\n&gt;&gt;&gt;  a=6, b=3, rem=0\n&gt;&gt;&gt;  3\n\n\n\n\n\n13.9.1.2.1 Regular function\n\ndef find_gcd(a: int, b: int) -&gt; int:\n    \"\"\"\n    find the greatest common divisor of 2 integers a and b\n    \"\"\"\n    rem = a % b\n    while rem != 0:\n        a, b = b, rem\n        rem = a % b\n    return b\n\n\nfind_gcd(35, 28)\n\n&gt;&gt;&gt;  7\n\n\n\n\n13.9.1.2.2 Recursive function\n\ndef find_gcd_rec(a: int, b: int) -&gt; int:\n    \"\"\"\n    find greatest common divisor of 2 integers a and b using recursion\n    \"\"\"\n    rem = a % b\n    if rem == 0:\n        result = b\n    else:\n        result = find_gcd_rec(b, rem)\n    return result\n\n\nfind_gcd_rec(35, 28)\n\n&gt;&gt;&gt;  7\n\n\nNote that above code can be further cleaned as below by simply reorganizing the placement of return statement as only one option is to returned and a function ends if it hits the return statement.\n\ndef find_gcd_rec(a: int, b: int) -&gt; int:\n    \"\"\"\n    find greatest common divisor of 2 integers a and b using recursion\n    \"\"\"\n    rem = a % b\n    if rem == 0:\n        return b\n    else:\n        return find_gcd_rec(b, rem)\n\nThis can be further cleaned by using ternary operator, X if condition else Y.\n\ndef find_gcd_rec(a: int, b: int) -&gt; int:\n    \"\"\"\n    find greatest common divisor of 2 integers a and b using recursion\n    \"\"\"\n    rem = a % b\n    return b if rem == 0 else find_gcd_rec(b, rem)\n\n\n\n\n13.9.1.3 Handling exceptions\nIn the control flow section, the example, Section 12.4.2.3.1, was to ask user input until it is correct. The solution was implemented using while and try blocks.\nThe same thing can be achieved using a recursive function with max number of tries allowed.\n\ndef get_an_integer(max_count=5, count=1):\n    \"\"\"\n    Ask user to input an integer until integer is provided\n    or maximum number of trials expire\n    \"\"\"\n    try:\n        some_int = int(input('Enter an integer...'))\n        return some_int\n    except ValueError:\n        print(f'This was try number {count}, and was not an integer.')\n        if count &lt; max_count:\n            count += 1\n            get_an_integer(count=count)\n        else:\n            print(f\"maximum tries ({max_count}) reached\")"
  },
  {
    "objectID": "content/building-blocks/oop.html#introduction",
    "href": "content/building-blocks/oop.html#introduction",
    "title": "14  OOP",
    "section": "14.1 Introduction",
    "text": "14.1 Introduction\nObject oriented programming, commonly referred to as OOP, is fundamental to how objects are defined and used in a programming language.\nThere are 2 components of OOP\n\nobject definition: aka class definition, type definition\nobject instance[s]: creation of the object[s] of a certain class (type)\n\nFor example int is a class (type) and there can be multiple instances like 1, 2 etc. Note that int is a class and its definition (code) to create int type objects is stored once on RAM. All instances, on creation are stored on RAM separately.\nIn Python, type is the root class of all classes, that is the reason type and class are used interchangeably. type can also be used as a function to check the class of an object.\n\ntype(10), type(int), type(type)\n\n&gt;&gt;&gt;  (&lt;class 'int'&gt;, &lt;class 'type'&gt;, &lt;class 'type'&gt;)\n\n\nClass is the blueprint of a certain type of object, what attributes all instance objects of this type will share\n\nstate: data attributes define the state of an instance\noperations: callable attributes (methods)\n\nFunctions defined in a class are called methods. Methods are regular functions with some differences to provide features related to classes and instances.\nClass instance object is an instance object of certain class (type) created and stored on RAM\n\nmultiple instances can be created\nusually referred to as objects\n\n\n14.1.1 Use cases\nAt a more abstract level, OOP provide\n\nmeans of combination\n\ncombine data and operations\nbuild smaller pieces and then join to make a bigger piece\n\nmeans of encapsulation\n\nhide details of implementation during usage\n\nmeans of abstraction:\n\ncreate blueprints of functionality\nalthough functions can be used, OOP is better for this\n\n\nOOP is generally used by developers for building tools and packages. Almost everything that can be implemented using OOP, can be implemented using functional programming. Functional programming keeps the complexity low. As a user it is recommended to know basics of OOP to use solutions provided by developers efficiently and actually use OOP only if necessary after getting some experience.\n\n\n14.1.2 Namespaces\nClass and instances have their own namespaces. Instance object namespace is searched first then class namespace is searched by the interpreter for variables.\n\n\n14.1.3 Attributes of an object\n\n\n\n14.1.3.1 Data attributes\n\nclass level\n\nbare\nproperties: static or calculated\n\ninstance level\n\nbare\nproperties: static or calculated\n\n\n\n\n \n\n\n14.1.3.2 Methods\n\ninstance methods\nclass methods\nstatic methods\n\n\n\n\n\n14.1.3.3 Data attributes\nClass data attributes are shared across all instance objects. They are suited for data attributes that do not define the state of an object. Main advantage is that they can be configured centrally. If the value is changed all instance objects have access to the new value.\nInstance data attributes define the state of an instance object. If the value is changed in one of the instances, it does not impact the value of the attribute in other instance objects.\nBare data attributes are attributes that can be accessed and modified directly without any pre or post functionality.\nProperties hide bare data attributes behind a property name, which if referenced from any instance object, act upon the bare attribute. Properties are also used to add some pre and post code while accessing or modifying the bare data attribute.\nStatic properties do not calculate the values of the underlying bare data attribute.\nDynamic properties do calculate the values of the underlying bare data attribute based on some other values.\n\n\n14.1.3.4 Methods\nMethods are callable attributes. Methods are simply functions defined in a class and they behave with minor difference compared to regular functions, to provide some basic functionality related to classes and objects.\nBy default methods defined inside a class are instance methods. They can be declared to be class or static using decorator syntax.\nInstance methods are callable attributes intended to be called from instance objects. They are functions with access to the instance object itself. The first parameter is enforced to be the instance object. They cannot be called from the class directly.\nClass methods are callable attributes that are accessible from both class and all instance objects, with access to class attributes. The first parameter is enforced to be the class object.\nStatic methods are callable attributes that are accessible from both class and all instance objects. They are regular functions without any enforced parameter."
  },
  {
    "objectID": "content/building-blocks/oop.html#basics",
    "href": "content/building-blocks/oop.html#basics",
    "title": "14  OOP",
    "section": "14.2 Basics",
    "text": "14.2 Basics\n\n14.2.1 Create a class and access attributes\n\nit is a convention, in Python, to use CamelCase for class names\n\n\nclass BasicClass:\n    data_attr = \"bare class attribute\"\n\n\nattributes are accessed using dot notation (.)\n\n\nBasicClass.data_attr\n\n&gt;&gt;&gt;  'bare class attribute'\n\n\n\n\n14.2.2 Create instance and access attributes\n\ncreate instances by calling the class\n\n\nobj_1 = BasicClass()\nobj_2 = BasicClass()\n\n\naccess attributes using dot notation (.)\n\n\nobj_1.data_attr\n\n&gt;&gt;&gt;  'bare class attribute'\n\nobj_2.data_attr\n\n&gt;&gt;&gt;  'bare class attribute'\n\n\n\ncheck type of any instance object\n\n\ntype(obj_1), type(obj_2)\n\n&gt;&gt;&gt;  (&lt;class '__main__.BasicClass'&gt;, &lt;class '__main__.BasicClass'&gt;)\n\n\n\nclass attributes are shared by instance objects and are useful for data attributes to be changed centrally\n\n\nBasicClass.data_attr = \"new value\"\nobj_1.data_attr, obj_2.data_attr\n\n&gt;&gt;&gt;  ('new value', 'new value')"
  },
  {
    "objectID": "content/building-blocks/oop.html#instance-methods",
    "href": "content/building-blocks/oop.html#instance-methods",
    "title": "14  OOP",
    "section": "14.3 Instance methods",
    "text": "14.3 Instance methods\n\n14.3.1 Incorrect example\n\ndefine the class\n\n\nclass CustomClass:\n  def custom_method():\n    print(\"running custom_method\")\n\n\ncall the method from class directly\n\nthis will work\n\n\n\nCustomClass.custom_method()\n\n&gt;&gt;&gt;  running custom_method\n\n\n\ncreate an instance object and call the method from instance object\n\nthis will not work\n\n\n\nobj_1 = CustomClass()\nobj_1.custom_method()\n\n&gt;&gt;&gt;  Error: TypeError: CustomClass.custom_method() takes 0 positional arguments but 1 was given\n\n\n\n\n14.3.2 self argument\n\nError reason\n\nmethods by default are bound to instance object\nfirst parameter is passed by Python as the instance object itself\n\nIt is a convention to call this first parameter self\n\nIt can be named anything\nit is recommended to use self for consistency\n\nInstance methods are not meant to be called directly from class\n\n\nclass CustomClass:\n  def custom_method(self):\n    print(\"running custom_method\")\n    print(self)\n\n\n14.3.2.1 Calling from class\n\nCall instance method from class directly: this will not work\nThis is because there is no instance object to pass as first argument\nHow class and static methods are defined will be covered later\n\n\nCustomClass.custom_method()\n\n&gt;&gt;&gt;  Error: TypeError: CustomClass.custom_method() missing 1 required positional argument: 'self'\n\n\n\n\n14.3.2.2 Calling from instance\nclass CustomClass:\n  def custom_method(self):\n    print(\"running custom_method\")\n    print(self)\n\nCreate an instance and call the method from instance directly: this will work\n\n\nobj_1 = CustomClass()\nobj_1.custom_method()\n\n&gt;&gt;&gt;  running custom_method\n&gt;&gt;&gt;  &lt;__main__.CustomClass object at 0x7fdcb4166890&gt;"
  },
  {
    "objectID": "content/building-blocks/oop.html#instance-data-attributes",
    "href": "content/building-blocks/oop.html#instance-data-attributes",
    "title": "14  OOP",
    "section": "14.4 Instance data attributes",
    "text": "14.4 Instance data attributes\n\n14.4.1 __init__\n\n__init__ is an instance method called at the time of instance object creation\n\nthis is by Python design\nit is optional\n\nUsed to create instance attributes at the time of instance object creation\n\n\nclass CustomClass:\n    def __init__(self, bare_data_attr_1_val, bare_data_attr_2_val):\n        self.bare_data_attr_1 = bare_data_attr_1_val\n        self.bare_data_attr_2 = bare_data_attr_2_val\n\n    def custom_method(self):\n        print('running custom_method')\n        print(f'with access to {self.bare_data_attr_1 = }')\n        print(f'and {self.bare_data_attr_2 = }')\n\n\n14.4.1.1 Create instances\n\nobj_1 = CustomClass(2, 4)\nobj_1.bare_data_attr_1, obj_1.bare_data_attr_2\n\n&gt;&gt;&gt;  (2, 4)\n\nobj_1.custom_method()\n\n&gt;&gt;&gt;  running custom_method\n&gt;&gt;&gt;  with access to self.bare_data_attr_1 = 2\n&gt;&gt;&gt;  and self.bare_data_attr_2 = 4\n\n\n\ngetattr(obj_1, \"bare_data_attr_1\")\n\n&gt;&gt;&gt;  2\n\nsetattr(obj_1, \"bare_data_attr_1\", \"abc\")\ngetattr(obj_1, \"bare_data_attr_1\")\n\n&gt;&gt;&gt;  'abc'"
  },
  {
    "objectID": "content/building-blocks/oop.html#instance-properties",
    "href": "content/building-blocks/oop.html#instance-properties",
    "title": "14  OOP",
    "section": "14.5 Instance properties",
    "text": "14.5 Instance properties\n\nIn other languages there is a concept of making certain attributes private\n\nin Python properties are used for this\nattribute is still accessible but direct access is discouraged\n\nTo define a property manually use\n\nproperty(fget, fset, fdel, doc)\nfget, fset and fdel are instance methods to get, set and delete property value\n\ndel reserved word is used to delete attributes\nIt is convention to name the underlying attribute name to be _&lt;property_name&gt;\n\nthis is to indicate that attribute is for internal use\n\nUsing methods to access, modify and delete attributes helps with\n\nadding checks and other functionality as needed\nhiding attribute name behind property name\n\nchange in attribute name does not break other code using the class\n\n\n\n\n14.5.1 Example\nBelow example illustrates all aspects of defining a property in a class. Note the difference in names to illustrate different components of the property.\nIt is recommended to experiment in jupyter notebook by creating instance objects and accessing/modifying/deleting property and bare instance attribute.\n\nclass CustomClass:\n    \"\"\"This is CustomClass with a bare data attribute and a property\"\"\"\n    def __init__(self, property_1_val, bare_data_attr_1_val):\n        self.property_1_name = property_1_val\n        self.bare_data_atrr_1_name = bare_data_attr_1_val\n\n    def get_property_1_name(self):\n        print(\"getter called..\")\n        return self._property_1_name\n\n    def set_property_1_name(self, property_1_val):\n        print(\"setter called..\")\n        # required checks or calculations\n        self._property_1_name = property_1_val\n\n    def del_property_1_name(self):\n        print(\"delete method called..\")\n        # required checks or calculations\n        del self._property_1_name\n\n    property_1_name = property(fget=get_property_1_name,\n        fset=set_property_1_name, fdel=del_property_1_name,\n        doc=\"\"\"The property's description.\"\"\")\n\n\n\n14.5.2 Defining property using decorator syntax\nBelow is the same example with Python decorator syntax. It is useful for cleaner syntax which is much easier to read.\n\nclass CustomClass:\n    \"\"\"This is CustomClass with a bare data attribute and a property\"\"\"\n    def __init__(self, property_1_val, bare_data_attr_1_val):\n        self.property_1_name = property_1_val\n        self.bare_data_atrr_1_name = bare_data_attr_1_val\n\n    @property\n    def property_1_name(self):\n        \"\"\"Property description\"\"\"\n        print(\"getter called..\")\n        return self._property_1_name\n\n    @property_1_name.setter\n    def property_1_name(self, property_1_val):\n        print(\"setter called..\")\n        # required checks or calculations\n        self._property_1_name = property_1_val\n\n    @property_1_name.deleter\n    def property_1_name(self):\n        print(\"delete method called..\")\n        # required checks or calculations\n        del self._property_1_name"
  },
  {
    "objectID": "content/building-blocks/oop.html#class-methods",
    "href": "content/building-blocks/oop.html#class-methods",
    "title": "14  OOP",
    "section": "14.6 Class methods",
    "text": "14.6 Class methods\n\nClass methods can be defined using @classmethod decorator\nLike instance methods, first parameter is mandatory and gives access to class\n\nit is bound to the class\nit is convention to name this first parameter as cls\nall instances created have access as well\n\n\n\n14.6.0.1 Example\n\nclass CustomClass:\n    x = 10\n    @classmethod\n    def some_class_method(cls):\n        print(f\"This is a class method bound to class - {cls}\")\n        print(f\"has access to class attributes {cls.x = }\")\n\nCustomClass.some_class_method()\n\n&gt;&gt;&gt;  This is a class method bound to class - &lt;class '__main__.CustomClass'&gt;\n&gt;&gt;&gt;  has access to class attributes cls.x = 10\n\nobj = CustomClass()\nobj.some_class_method()\n\n&gt;&gt;&gt;  This is a class method bound to class - &lt;class '__main__.CustomClass'&gt;\n&gt;&gt;&gt;  has access to class attributes cls.x = 10"
  },
  {
    "objectID": "content/building-blocks/oop.html#static-methods",
    "href": "content/building-blocks/oop.html#static-methods",
    "title": "14  OOP",
    "section": "14.7 Static methods",
    "text": "14.7 Static methods\n\nStatic methods are regular functions defined in a class\nDefined using @staticmethod decorator\nCan be accessed from class and all instances\nThere is no mandatory first parameter\n\n\n14.7.0.1 Example\n\nclass CustomClass:\n  @staticmethod\n  def some_static_method(a=10):\n    print(\"This is a static function\")\n    print(f\"a regular function with parameters, e.g. {a = }\")\n\nCustomClass.some_static_method()\n\n&gt;&gt;&gt;  This is a static function\n&gt;&gt;&gt;  a regular function with parameters, e.g. a = 10\n\nobj = CustomClass()\nobj.some_static_method(a = 100)\n\n&gt;&gt;&gt;  This is a static function\n&gt;&gt;&gt;  a regular function with parameters, e.g. a = 100"
  },
  {
    "objectID": "content/building-blocks/oop.html#full-example",
    "href": "content/building-blocks/oop.html#full-example",
    "title": "14  OOP",
    "section": "14.8 Full example",
    "text": "14.8 Full example\nBelow is a full example to illustrate all the pieces together. There is a Circle class to create circle objects with the following components\n\npi is a class data attribute\n_radius is instance data attribute marked private\n\nthis is only available in instances\nnot recommended for direct use\n\nradius is a static property to access _radius from instances\narea is a dynamic property with no set method\n\nprovides access to attribute _area\nautomatically updated when radius changes\n\ncircumference is an instance method\n\n\nclass Circle:\n    def __init__(self, radius_val):\n        self.radius = radius_val\n\n    pi = 3.141592653589793\n\n    @property\n    def radius(self):\n        return self._radius\n\n    @radius.setter\n    def radius(self, radius_val):\n        print(\"setting radius and calculating area\")\n        self._radius = radius_val\n        self._area = self.pi * (self.radius**2)\n\n    @property\n    def area(self):\n        return self._area\n\n    def calc_circumference(self):\n        print('calculating circumference')\n        return 2*self.pi*self.radius\n\n\nc1 = Circle(1)\n\n&gt;&gt;&gt;  setting radius and calculating area\n\nc1.radius, c1.area, c1.calc_circumference()\n\n&gt;&gt;&gt;  calculating circumference\n&gt;&gt;&gt;  (1, 3.141592653589793, 6.283185307179586)\n\nc1.area, c1.calc_circumference()\n\n&gt;&gt;&gt;  calculating circumference\n&gt;&gt;&gt;  (3.141592653589793, 6.283185307179586)\n\nc1.radius = 2\n\n&gt;&gt;&gt;  setting radius and calculating area"
  },
  {
    "objectID": "content/building-blocks/oop.html#summary",
    "href": "content/building-blocks/oop.html#summary",
    "title": "14  OOP",
    "section": "14.9 Summary",
    "text": "14.9 Summary\n\nclass defines classes which are callable and used to create instance objects\n__init__ method is used to control creation of attributes at instance object creation\nAccess attributes\n\n&lt;obj_name&gt;.&lt;attr_name&gt;[()]\ngetattr(&lt;obj_name&gt;, &lt;attr_name&gt;)\n\nModify attributes\n\n&lt;obj_name&gt;.&lt;attr_name&gt; = &lt;something&gt;\nsetattr(&lt;obj_name&gt;, &lt;attr_name&gt;, &lt;something&gt;)\n\nDelete attributes\n\ndel &lt;obj_name&gt;.&lt;attr_name&gt;\ndelattr(&lt;obj_name&gt;, &lt;attr_name&gt;)\n\nData attributes\n\nclass level\n\nbare: defined directly\nproperties: defined using meta classes (not covered)\n\ninstance level\n\nbare: defined using __init__\nproperties: defined using property() or @property, static or calculated\n\n\nMethods (operations)\n\ninstance: have access to the instance object (self)\n\navailable for use with instances not with class itself\n\nclass methods\n\ncreated using @classmethod decorator\nhave access to the class object (cls)\n\nstatic methods\n\nregular functions\ncreated using @staticmethod decorator\navailable across instance objects and class"
  },
  {
    "objectID": "content/building-blocks/oop.html#advanced-topics",
    "href": "content/building-blocks/oop.html#advanced-topics",
    "title": "14  OOP",
    "section": "14.10 Advanced topics",
    "text": "14.10 Advanced topics\nBelow are some topics needed for advanced usage of programming. Understanding these topics leads to understanding of how much of the functionality provided in Python is implemented.\n\nInheritance\n\nsingle inheritance\nmultiple inheritance\n\nPython special methods\n\ncalled dunder (double underscore) methods\nprovide some default functionality with minimal code\ne.g. __init__, __str__, __repr__, __add__, …\nthis is the reason for convention to avoid __ in variable names to avoid clashes\n\nMeta programming and meta classes\n\n\n14.10.1 Inheritance\nInheritance means classes can inherit attributes from other classes, which allows classes to be structured and joined in efficient ways.\nSingle inheritance refers to case where a class can inherit attributes from a single class. A hierarchy is built when a class inherits from another class. The class that inherits is called the sub class. The class from which the sub class inherits is called the base class.\nMultiple inheritance refers to case when a class can inherit attributes from multiple classes. Attributes are inherited following a recursive algorithm. More details are documented at Python documentation.\nThere are some in-built functions provided to check the class hierarchy.\n\nisinstance(&lt;obj&gt;, &lt;type&gt;)\nissubclass(&lt;sub class&gt;, &lt;base class&gt;)\n\nFor example bool is derived from int therefore isinstance(True, int) and issubclass(bool, int) both return True.\n\nisinstance(True, int), issubclass(bool, int)\n\n&gt;&gt;&gt;  (True, True)"
  },
  {
    "objectID": "content/building-blocks/python-special-features.html#sec-ce",
    "href": "content/building-blocks/python-special-features.html#sec-ce",
    "title": "15  Python special features",
    "section": "15.1 Conditional expressions",
    "text": "15.1 Conditional expressions\nPython has 3 specials concepts related to conditional expressions.\n\ntruthy/falsy: object’s associated truth value\nexecution context: decides evaluation result\nshort circuit\n\nAll 3 concepts can be combined and used in interesting ways which allow some newer cleaner code styles for some common situations that occur while coding.\n\n15.1.1 Truthy and Falsy\n\nEvery object in Python has an associated truth value\n\nreferred to as object’s truth value\nif the object’s truth value is True \\(\\implies\\) truthy\nif the object’s truth value is False \\(\\implies\\) falsy\nhence the object is truthy or falsy\n\nBelow cases are falsy and everything else truthy:\n\nNone\nFalse\n0 in any numeric type (e.g. 0, 0.0, 0+0j, …)\nlen(c) = 0: empty collections\ncustom classes that implement __bool__ or __len__ method that return False or 0\n\nbool(any_object) function returns object’s truth value\n\n\n15.1.1.1 Examples\n\n15.1.1.1.1 Numeric type\n\nnum_1_1 = 1; num_1_2 = 1.0\n\n\n\n&gt;&gt;&gt;  num_1_1 =   1, bool(num_1_1) = True,   type(num_1_1) = &lt;class 'int'&gt;\n&gt;&gt;&gt;  num_1_2 = 1.0, bool(num_1_2) = True,   type(num_1_2) = &lt;class 'float'&gt;\n\n\n\nnum_2_1 = 0; num_2_2 = 0.0\n\n\n\n&gt;&gt;&gt;  num_2_1 =   0, bool(num_2_1) = False,  type(num_2_1) = &lt;class 'int'&gt;\n&gt;&gt;&gt;  num_2_2 = 0.0, bool(num_2_2) = False,  type(num_2_2) = &lt;class 'float'&gt;\n\n\n\n\n15.1.1.1.2 Collections\n\nempty_string = \"\"; empty_tuple = (); empty_list = []; empty_dict = {}\n\n\n\n&gt;&gt;&gt;  bool(empty_string) = False, bool(empty_tuple) = False\n&gt;&gt;&gt;  bool(empty_list) = False, bool(empty_dict) = False\n\n\n\nnon_empty_string = \"abc\"; non_empty_tuple = (1, 2)\n\nnon_empty_list = [\"a\", 1]; non_empty_dict = {\"key 1\": empty_list}\n\n\n\n&gt;&gt;&gt;  bool(non_empty_string) = True, bool(non_empty_tuple) = True\n&gt;&gt;&gt;  bool(non_empty_list) = True, bool(non_empty_dict) = True\n\n\n\n\n\n\n15.1.2 Short circuit\nShort circuit is general optimization strategy used by many languages. Main idea is to avoid evaluating unnecessary condition in an boolean combination.\nFor example in and combination if first condition is false then there is no point checking the second condition. Therefore, second condition of the combination is not evaluated.\nSimilarly for or combination if the first condition is true then the expression is true in both possible cases, therefore second condition is not evaluated.\n\n\n15.1.3 Execution context\nPython treats conditional expressions differently based on where they are used.\nBoolean combinations used in conditional expression, can contain objects directly rather than comparisons. Object’s truth value (bool(&lt;object&gt;)) is used rather than object itself.\n\n15.1.3.1 if/elif conditions\nConditional expression used in if/elif statement’s condition return booleans values (True/False).\nCondition can contain object’s as well, bool(object) is used rather than object’s value.\nIn below code, since x is an empty list it is falsy, bool(x) = False, therefore else block is executed.\n\nx = []\nif x:\n    print(\"x is truthy\")\nelse:\n    print(\"x is falsy\")\n\n&gt;&gt;&gt;  x is falsy\n\n\nIn below code, since x is a string, it is truthy (bool(x) = True), therefore if block is executed.\n\nx = \"abcd\"\nif x:\n    print(\"x is truthy\")\nelse:\n    print(\"x is falsy\")\n\n&gt;&gt;&gt;  x is truthy\n\n\nIn below example, since bool(x) = False, else block is executed without evaluating bool(y).\n\nx = []; y = None\nif x and y:\n    print(\"x and y returned True\")\nelse:\n    print(\"x was false, therefore y was not evaluated\")\n\n&gt;&gt;&gt;  x was false, therefore y was not evaluated\n\n\n\n\n15.1.3.2 Outside if/elif condition\nIf a boolean combination is used outside if statement and contains objects rather than comparison, then the underlying object’s value is returned, it may or may not be boolean data type.\nBelow regular comparisons are used outside if block and they are treated as usual, returning boolean values (True/False).\n\nx = []; y = 2\ny &lt; 5; y == 2\n\n&gt;&gt;&gt;  True\n&gt;&gt;&gt;  True\n\n\nSince boolean combination is used outside if/elif statement, bool(x) is checked and found to be falsy, using short circuit for and, x is returned and y is not evaluated.\n\nx = []; y = 2\nx and y\n\n&gt;&gt;&gt;  []\n\n\nSince boolean combination is used outside if/elif statement, bool(x) is checked and found to be falsy, using short circuit for or, y is evaluated and returned.\n\nx = []; y = 2\nx or y\n\n&gt;&gt;&gt;  2\n\n\n\n\n\n15.1.4 Summary\nTables below summarize the scenarios, where 0 and 1 signify boolean True and False.\n\n\n\n\n\n\n\n\n\n\nx\ny\nx and y\nx and y (outside if/elif)\n\n\n\n\n1\n1\n1\ny\n\n\n1\n0\n0\ny\n\n\n0\n1\n0\nx\n\n\n0\n0\n0\nx\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nx\ny\nx or y\nx or y (outside if/elif)\n\n\n\n\n1\n1\n1\nx\n\n\n1\n0\n1\nx\n\n\n0\n1\n1\ny\n\n\n0\n0\n0\ny\n\n\n\n\nFor x and y, where x and y can be variables, objects or conditions:\n\nevaluate bool(x)\n\nif bool(x) is True\n\nif x and y is part of a condition in if/elif block\n\nevaluate and returnbool(y)\n\nif x and y is not part of a condition in if/elif block\n\nreturn y\n\n\nif bool(x) is False\n\nif x and y is part of a condition in if/elif block\n\nreturn False\n\nif x and y is not part of a condition in if/elif block\n\nreturn x\n\n\n\n\nSimilarly, for x or y, where x and y can be variables, objects or conditions:\n\nevaluate bool(x)\n\nif bool(x) is True\n\nif x and y is part of a condition in if/elif block\n\nreturn True\n\nif x and y is not part of a condition in if/elif block\n\nreturn x\n\n\nif bool(x) is False\n\nif x and y is part of a condition in if/elif block\n\nevaluate and returnbool(y)\n\nif x and y is not part of a condition in if/elif block\n\nreturn y\n\n\n\n\n\n\n15.1.5 Use cases\n\n15.1.5.1 Iterables\nIt is common situation where state of an iterable is not known in advance.\nFor example a list generated by some operation which can result in None or empty list or a list with values. There are some operations to be done only if the list is truthy.\nUsing the 3 concepts the code can be simplified as below. Both the condition are to ensure that the object is truthy.\nNote that len(some_itr) &gt; 0 is used as second condition in and combination. Due to short circuit it is not evaluated if first condition is False, i.e. some_itr is None. If it is used as first condition, it is evaluated always, therefore will give error when the iterable is None.\n\n\n\nsome_itr =  # some iterable object\nif some_itr is not None and len(some_itr) &gt; 0:\n    # code block\nelse:\n    # code block\n\n\n \n\n\nsome_itr =  # some iterable object\nif some_itr:\n    # code block\nelse:\n    # code block\n\n\n\n\n\n15.1.5.2 Assign default\nAnother common situation is to assign a default value in case the expected value is falsy.\nBelow form of assignment will work. If expected_var is truthy, because of short circuit or, it will be returned and assigned to new_var. If it is falsy, default object will be evaluated and returned.\nnew_var = expected_var or default_object"
  },
  {
    "objectID": "content/building-blocks/python-special-features.html#comprehensions",
    "href": "content/building-blocks/python-special-features.html#comprehensions",
    "title": "15  Python special features",
    "section": "15.2 Comprehensions",
    "text": "15.2 Comprehensions\nComprehensions are a newer feature in Python which combine the fundamentals of map and filter in a more concise syntax.\nThey are relevant for iterables, i.e. tuples, lists, sets and dictionaries. Mostly they are used with lists and dictionaries.\nGeneric idea is\n\ntransformation iteration filter or\nexpression loop condition\n\ni.e. map expression to each item in iterable which satisfy the filter.\n\nFilter/condition is optional\nComprehensions can be nested\n\n\n15.2.1 List comprehensions\nFor list comprehension generic syntax is\n\n[expression using item for item in list if condition on item]\nexample without filter: list of squares from a list of integers\n\n\nsome_itr = list(range(10))\nsquared_itr = [item**2 for item in some_itr]\nprint(some_itr, squared_itr, sep=\"\\n\")\n\n&gt;&gt;&gt;  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt;  [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\n\n\n\n\n\n\nexample with filter: list of squares from a list of integers if integer is even\n\n\nsome_itr = tuple(range(10))\nevens_squared_itr = [item**2 for item in some_itr if item % 2 == 0]\nprint(some_itr, evens_squared_itr, sep=\"\\n\")\n\n&gt;&gt;&gt;  (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n&gt;&gt;&gt;  [0, 4, 16, 36, 64]\n\n\n\n\n\n\n\n\nexample with multiple iterables: list of sum of squares of 2 iterables of numbers\n\n\nt_1 = (*range(1,4),); t_2 = (*range(4,7),)\nsum_of_sqrs = [x**2 + y**2 for x, y in zip(t_1, t_2)]\nt_1, t_2, sum_of_sqrs\n\n&gt;&gt;&gt;  ((1, 2, 3), (4, 5, 6), [17, 29, 45])\n\n\n\nexample of nested comprehensions: make all possible combinations of letters of 2 strings if they are not equal\n\n\nstring_1 = 'abc'; string_2 = 'axy'\ncombinations = [l1 + l2 for l1 in string_1 for l2 in string_2 if l1 != l2]\nprint(combinations)\n\n&gt;&gt;&gt;  ['ax', 'ay', 'ba', 'bx', 'by', 'ca', 'cx', 'cy']\n\n\nFor better code readability, this can be written as\n\nstring_1 = 'abc'; string_2 = 'axy'\ncombinations = [l1 + l2 \n                for l1 in string_1\n                    for l2 in string_2\n                        if l1 != l2]\nprint(combinations)\n\n&gt;&gt;&gt;  ['ax', 'ay', 'ba', 'bx', 'by', 'ca', 'cx', 'cy']\n\n\nThis is same as\n\nstring_1 = 'abc'; string_2 = 'axy'\ncombinations = []\nfor l1 in string_1:\n    for l2 in string_2:\n        if l1 != l2:\n            combinations.append(l1 + l2)\nprint(combinations)\n\n&gt;&gt;&gt;  ['ax', 'ay', 'ba', 'bx', 'by', 'ca', 'cx', 'cy']\n\n\n\n\n15.2.2 Tuple, set, dict\nTo return a tuple instead of a list from a comprehension use tuple constructor instead of square brackets.\nFor sets and dictionary just use curly braces instead of square brackets.\n\nexample with multiple iterables: tuple of sum of squares of 2 iterables of numbers\n\n\nt_1 = (*range(1,4),); t_2 = (*range(4,7),)\nsum_of_sqrs = tuple(x**2 + y**2 for x, y in zip(t_1, t_2))\nt_1, t_2, sum_of_sqrs\n\n&gt;&gt;&gt;  ((1, 2, 3), (4, 5, 6), (17, 29, 45))\n\n\n\nexample with set\n\n\nsome_set = set((1, 2, 3))\nprint({e**2 for e in some_set if e &gt; 1})\n\n&gt;&gt;&gt;  {9, 4}\n\n\n\nexample with dictionary\n\n\nimport string\ndict_1 = dict(zip(string.ascii_letters[0:10], list(range(10))))\nprint(dict_1)\n\n&gt;&gt;&gt;  {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9}\n\n\n\ndict_2 = {k: v**2 for k, v in dict_1.items() if k in {'a', 'e', 'i'}}\nprint(type(dict_2))\nprint(dict_2)\n\n&gt;&gt;&gt;  &lt;class 'dict'&gt;\n&gt;&gt;&gt;  {'a': 0, 'e': 16, 'i': 64}"
  },
  {
    "objectID": "content/architecture/arch-overview.html#background",
    "href": "content/architecture/arch-overview.html#background",
    "title": "Overview",
    "section": "Background",
    "text": "Background\nAfter learning about building blocks, the missing piece is the knowledge of higher level specifications of the language implementations which allow combining everything into a complete program. Architecture part covers this. Knowledge of architecture part also helps in understanding and debugging programs.\n\nLanguage specifications\n\nBuilding blocks: specifications for elements and blocks of code\nArchitecture: specifications for writing programs\n\nmeans and specifications to combine elements and blocks to build programs\nmanagement of execution of blocks (under the hood)\n\n\nDesign: knowledge of how to write good programs\nTools: needed to write, test, debug and run programs"
  },
  {
    "objectID": "content/architecture/arch-overview.html#introduction",
    "href": "content/architecture/arch-overview.html#introduction",
    "title": "Overview",
    "section": "Introduction",
    "text": "Introduction\n\nEnvironment = Namespace + Scope: how to isolate and identify (variable) names and objects\nScripts and packages: how to organize and use building blocks in scripts and folders\nExternal packages: overview of external packages available for use\nLanguage engine: overview of workings of Python interpreter\nDebugging: investigating and troubleshooting errors while writing programs"
  },
  {
    "objectID": "content/architecture/arch-overview.html#objectives",
    "href": "content/architecture/arch-overview.html#objectives",
    "title": "Overview",
    "section": "Objectives",
    "text": "Objectives\n\nUnderstand the specifications related to architecture and do experiments in isolation\nTools: use editor and cli to manage installation, scripts and projects"
  },
  {
    "objectID": "content/architecture/namespaces-scopes.html#introduction",
    "href": "content/architecture/namespaces-scopes.html#introduction",
    "title": "16  Namespaces and scopes",
    "section": "16.1 Introduction",
    "text": "16.1 Introduction\nA namespace is a mapping from names (variables) to object references. When python interpreter reads the code it needs to lookup objects referenced by variable names used. As discussed earlier, objects are stored on computer RAM and can be accessed using object’s memory address. Namespaces help find and access the associated objects using variable names. Technically, in Python, they are dictionaries that store this mapping.\nA scope is a textual region of the code which has its own separate namespace. This helps isolate and manage different variable names and objects used in different blocks of code. Many languages do this by keeping track of namespace for all blocks, e.g. control flow blocks (if, for, …). Python restricts this to just function and class/instance object blocks. Control flow blocks like if, for etc. do not have their local scopes.\nThere is a lot of ambiguity in terminology related to this. For example environments and frames are used interchangeably to refer to the concept of namespace and scope discussed here. To avoid this issue, try to understand the underlying concepts and the issue with the terminology will not impact.\nPython tutor is an excellent resource to do small experiments to understand the rules explained in this section. A good starting point would be to try the examples provided in the tool."
  },
  {
    "objectID": "content/architecture/namespaces-scopes.html#specifications",
    "href": "content/architecture/namespaces-scopes.html#specifications",
    "title": "16  Namespaces and scopes",
    "section": "16.2 Specifications",
    "text": "16.2 Specifications\n\n16.2.1 Basic\nBelow are the scopes in the order they are searched\n\nInnermost scope for a function\n\nnamespace contains local names (only if present)\n\nScope of enclosing functions\n\nnamespace contains non local names (only if present)\n\nGlobal scope (scope of the module)\n\nnamespace contains global names\nfor functions: scope of the Python file where the function is defined\n\nBuilt-in scope\n\nnamespace contains built-in names\n\n\n\n\n16.2.2 Creation and destruction times\n\nBuilt-in scope’s namespace\n\ncreated when the interpreter starts up\nnever deleted, exists till interpreter is terminated\n\nGlobal (module) scope’s namespace\n\ncreated at compile time, when the module is read for the first time\nnever deleted, exists till interpreter is terminated\n\nLocal scope’s namespace for a function\n\ncompile time (when the definition is read)\n\nlocal scope’s namespace is not created at this stage\nvariables are tagged scopes\nobjects for default parameters are created and stored in function object\nthe function object is created in the enclosing scope’s namespace\n\nrun time (during function call)\n\nevery time function is called a new local scope’s namespace is created\ndeleted when the call terminates, i.e. on return or error\n\n\n\n\n\n16.2.3 Function scope\n\nScope of variable names used in a function definition\n\nExplicit declaration of scope\n\nglobal: variable is looked up in global name space skipping enclosing functions namespaces\nnonlocal: variable is looked up only in the enclosing function scope\n\nWithout explicit declaration of scope\n\nIf a variable is assigned within a function\n\ncompile time: tagged to local scope\n\nIf a variable is referenced without being assigned within the function\n\ncompile time\n\nthe next level up enclosing scope is searched until builtin scope\ntagged to the first scope it is found in\n\nrun time: error is raised if not found\n\n\n\nOn end of function execution the function scope’s namespace is deleted\nWhen cross referencing functions from other modules\n\nthe global scope for a function is the scope of the module in which it is defined\nthis will become clear after understanding modules and packages discussed in next chapter\n\n\n\n\n\n\nScopes\n\n\n\n\n\n\n\nNested scopes"
  },
  {
    "objectID": "content/architecture/namespaces-scopes.html#examples",
    "href": "content/architecture/namespaces-scopes.html#examples",
    "title": "16  Namespaces and scopes",
    "section": "16.3 Examples",
    "text": "16.3 Examples\n\n16.3.1 global\n\nvar = \"global\"\n\ndef func():\n    print(\"inside func call var = \" + var)\n\nfunc()\n\nprint(\"in global scope var = \" + var)\n\n&gt;&gt;&gt;  inside func call var = global\n&gt;&gt;&gt;  in global scope var = global\n\n\nSince var is not assigned, only referenced in the func definition, it is searched in local namespace then in global namespace. Since global namespace has var defined its value is used.\n\n\n16.3.2 local\n\nvar = \"global\"\n\ndef func():\n    var = \"local\"\n    print(\"inside func call var = \" + var)\n\nfunc()\n\nprint(\"in global scope var = \" + var)\n\n&gt;&gt;&gt;  inside func call var = local\n&gt;&gt;&gt;  in global scope var = global\n\n\nSince var is assigned in func definition, it is tagged to local scope. Therefore there are 2 different var names in 2 different namespaces, global namespace and func’s namespace created during its call.\n\n\n16.3.3 global with nested scopes\n\nvar = \"global\"\n\ndef outer_func():\n\n    def inner_func():\n        print(\"inside inner_func call var = \" + var)\n\n    inner_func()\n\nouter_func()\n\nprint(\"in global scope var = \" + var)\n\n&gt;&gt;&gt;  inside inner_func call var = global\n&gt;&gt;&gt;  in global scope var = global\n\n\n\n\n16.3.4 nonlocal\n\nvar = \"global\"\n\ndef outer_func():\n    var = \"nonlocal\"\n\n    def inner_func():\n        nonlocal var\n        print(\"inside inner_func call var = \" + var)\n\n    inner_func()\n    print(\"inside outer_func call var = \" + var)\n\nouter_func()\n\nprint(\"in global scope var = \" + var)\n\n&gt;&gt;&gt;  inside inner_func call var = nonlocal\n&gt;&gt;&gt;  inside outer_func call var = nonlocal\n&gt;&gt;&gt;  in global scope var = global\n\n\n\n\n16.3.5 Declaring global in nested scopes\n\nvar = \"global\"\n\ndef outer_func():\n    var = \"nonlocal\"\n\n    def inner_func():\n        global var\n        print(\"inside inner_func call var = \" + var)\n\n    inner_func()\n    print(\"inside outer_func call var = \" + var)\n\nouter_func()\n\nprint(\"in global scope var = \" + var)\n\n&gt;&gt;&gt;  inside inner_func call var = global\n&gt;&gt;&gt;  inside outer_func call var = nonlocal\n&gt;&gt;&gt;  in global scope var = global"
  },
  {
    "objectID": "content/architecture/namespaces-scopes.html#use-cases",
    "href": "content/architecture/namespaces-scopes.html#use-cases",
    "title": "16  Namespaces and scopes",
    "section": "16.4 Use cases",
    "text": "16.4 Use cases\nNamespaces and scopes are always getting used by the interpreter while running any piece of code. In the beginning, being aware of the rules is sufficient for regular use in avoiding and resolving errors and understanding code. It is advisable to keep the use of namespaces simple.\nFor example while using functions, do not try to use namespace and scope rules to create complex solutions if the problem can be solved using without them.\nThere are many program design techniques implemented using the rules of namespaces and scopes. For example factory and decorator functions are created using these rules.\n\n\n\n\nBasic use cases\n\navoiding errors\nresolving errors\nunderstand code\n\n\n\n\n \n\n\n\nAdvanced use cases\n\nimplementing design patterns\n\nfactory functions\ndecorators\ngenerators"
  },
  {
    "objectID": "content/architecture/modules-packages.html#module",
    "href": "content/architecture/modules-packages.html#module",
    "title": "17  Modules & Packages",
    "section": "17.1 Module",
    "text": "17.1 Module\nIn Python a module can refer to several different things.\n\nModule commonly is referred to a file type module\nfolder type modules are commonly referred to as packages explicitly\nmodule is also a type or class\nModule also refers to Python object once the module file or a package is loaded using import\nwhich is instance object of type module\n\nCommonly module refers to a file with .py extension.\nThere are 3 cases when module type object is created using import in Python\n\nfile: a file or script containing Python code\npackage: a folder containing sub-folders and scripts\n\nregular package: declared using __init__.py file\nnamespace package\n\n\nFor example, if there is a file abc.py with some code and import abc is run on Python repl. abc is a module object. abc.py is also a file type module.\nA regular package, commonly referred to as package, is also a module type object once loaded into memory by Python interpreter, the only difference is it is a folder containing __init__.py, even if __init__.py is empty.\nFile type and regular packages are covered here. Namespace packages are a newer feature and generally not required, hence are not covered. Information about namespace packages can be found at Python documentation and PEP 420."
  },
  {
    "objectID": "content/architecture/modules-packages.html#regular-package",
    "href": "content/architecture/modules-packages.html#regular-package",
    "title": "17  Modules & Packages",
    "section": "17.2 Regular package",
    "text": "17.2 Regular package\nAny folder with a __init__.py file, even if empty, is treated as a regular package.\nPackages provide a way to organize and exchange code as they can contain packages (sub-packages) and file type modules.\nPackages are generally used to provide some functionality using functions and class definitions, which can be used anywhere in the code.\nOptionally, a regular package can also contain a __main__.py file, this is run when the package is run as the top level environment. This is discussed in detail later in Section 17.4.1.\nOne of the key features of regular packages is that they allow cross referencing between modules in sub packages using relative imports."
  },
  {
    "objectID": "content/architecture/modules-packages.html#naming-convention-and-rules",
    "href": "content/architecture/modules-packages.html#naming-convention-and-rules",
    "title": "17  Modules & Packages",
    "section": "17.3 Naming convention and rules",
    "text": "17.3 Naming convention and rules\nConvention: lower snake case\nRule: names containing special characters other than _ give error, essentially same rules as for variable names\n\n17.3.1 Pep-8 Conventions\n\n\n\n\n\n\n\nObject Type\n\n\n\n\nConvention\n\n\n\n\nExample\n\n\n\n\n\n\nPackages\n\n\n\n\n\nshort\n\n\nall-lowercase names\n\n\npreferably no underscores\n\n\n\n\n\nutilities\n\n\n\n\n\n\nModules\n\n\n\n\n\nshort\n\n\nall-lowercase names\n\n\ncan have underscores\n\n\n\n\n\ndb_utils.py or dbutils.py"
  },
  {
    "objectID": "content/architecture/modules-packages.html#usage",
    "href": "content/architecture/modules-packages.html#usage",
    "title": "17  Modules & Packages",
    "section": "17.4 Usage",
    "text": "17.4 Usage\nThere are 2 main uses of modules and packages.\n\nExecution as top level environment\nPython '__main__' system manages this\nOrganizing and cross referencing objects\nPython import system manages this\n\n\n17.4.1 __main__\nIn Python, the system of __main__ manages the run time behavior of modules and packages, when they are run as top level environment. It helps in differentiating how a module or package is intended to be used.\nTo execute a Python module or package as top level environment from command line, the recommended command is\npython3 -m &lt;module or package name&gt;\nNote that if module name is abc.py the above command needs only abc without the .py extension.\nAnother form of command to run a python module or package is python3 &lt;abc.py&gt; or python3 &lt;some package path&gt;.\n\n17.4.1.1 Modules\nIf a module is run as top level environment, the __name__ attribute of the module object is set to '__main__' by the Python interpreter in background, this is used to isolate code which is run only when module is run directly\n\nthe code is isolated using if __name__ = '__main__' block\nthe code is not run with import\n\nAnother important thing to note is that function and class definitions are bound to the module they are declared in. So it does not matter where you call the function from, the global scope for a function is the module’s global scope in which it is declared.\nFollowing coding exercise will demonstrate these fundamentals.\n\ncreate a Python file with following content and save with some name, e.g. sample_mod.py\n\nprint(\"running sample module\")\nprint(\"__name__ attribute of the current module = \" + __name__)\n\nif __name__ == \"__main__\":\n    print(\"running main block of sample module\")\n\nfrom command line goto the folder containing sample_mod.py and execute the command\npython3 -m sample_mod\n\nnotice that print statement of the if block is executed because __name__ attribute of the module is set to __main__\n\nnow start Python repl by entering the command python3\nin repl enter import sample_mod\n\nnotice that main block is not run because name of the loaded module is set to sample_mod\nimport system is discussed in later section\n\n\n\n\n17.4.1.2 Regular packages\nAny folder containing __init__.py is treated as a regular package by Python. Packages can additionally contain __main__.py.\nFor packages, instead of a if __name__ = '__main__' block, __main__.py is used. If if __name__ = '__main__' block is used in __init__.py, it will give error when the package is called directly as the top level environment.\nIf __main__.py is present in the regular package it is run along with the __init__.py when the package is run as the top level environment. Again this helps isolate code which needs to run only when the package is run directly as top level environment. When calling the same package using import, __main__.py is not run.\nThis is simple to test.\n\nIn a folder in system create below folder structure\n\nmkdir reg_pkg_1 reg_pkg_2\ncd reg_pkg_1; touch __init__.py __main__.py\ncd ../reg_pkg_2; touch __init__.py; cd ..\n\nwrite contents to the files\n\n# reg_pkg_1.__init__.py\n\nprint(\"running regular package 1\")\n# reg_pkg_1.__main__.py\n\nprint(\"running main from regular package 1\")\n# reg_pkg_2.__init__.py\n\nprint(\"running regular package 2\")\n\nif __name__ == \"__main__\":\n    print(\"running main block of regular package 2\")\n\nexperiment\n\nrun each package as top level environment\nimport each package from repl\n\nnote that running reg_pkg_2 as top level environment will give error because it is a regular package and if __name__ = '__main__' does not work\n\n\n\n\n17.4.2 import system\nImport system in Python helps manage using object definitions (variables, functions, classes) from other scripts.\nOnce imported, a module or package is a module type object with attributes. Python adds some special attributes to module type objects.\n\n&lt;module name&gt;.__name__: module’s name or __main__ if run directly\n&lt;module name&gt;.__file__: absolute path to the module location\n&lt;module name&gt;.__package__: is populated if is a regular package or a part of one, else is empty string\n&lt;module name&gt;.__path__: exists if module is a regular package or is part of one, else gives error\n\nAll this is supported using Python’s import system. Detailed documentation can be found at Python language reference: Import system.\n\n17.4.2.1 Modules\nFull module (file or package) can be imported using below statements.\n\nimport &lt;module name&gt;\nimport &lt;module name&gt; as &lt;module alias&gt;\n\n\n\n17.4.2.2 Objects & sub-modules\nWhile importing, only subset of a module or package can be imported. It can be specific objects or modules or sub-packages within a parent package.\n\nfrom &lt;module_name&gt; import &lt;object_name&gt;\n\nfrom &lt;module name&gt; import *\nfrom &lt;module name&gt; import &lt;object name&gt;\nfrom &lt;module name&gt; import &lt;sub module name&gt;\nfrom &lt;module name&gt; import &lt;object name&gt; as &lt;object alias&gt;\nfrom &lt;module name&gt; import &lt;sub module name&gt; as &lt;module alias&gt;\n\nfrom &lt;module name&gt; import * is not recommended when using other packages\n\nit pollutes the namespace\ncreates name clashes\n&lt;module name&gt;.&lt;obj name&gt; is better for code readability\nIt is provides information about source of the object used\n\n\n\n\n17.4.2.3 Runtime behavior\nWhenever a file or package type module is imported the following things happen\n\nPython interpreter checks if the module/package is already loaded into current namespace\n\nif the module/package is loaded\n\nnothing is done\n\nif the module/package is not loaded\n\nPython interpreter runs the code in module or __init__.py for a package\n\nmain code is not run\n\nall the exported objects are loaded\n\n\nWhen only a sub package is imported Python still loads the parent package\n\ntherefore there is no efficiency gain if only a sub package is imported"
  },
  {
    "objectID": "content/architecture/modules-packages.html#applications",
    "href": "content/architecture/modules-packages.html#applications",
    "title": "17  Modules & Packages",
    "section": "17.5 Applications",
    "text": "17.5 Applications\nA Python project might be intended to do one or both type of below tasks.\n\nPerform some task[s] by running a script as top level environment\nCreate a package to define objects (functions, classes, data-objects, …) for re-use and sharing\n\nBelow are the use cases with recommendations.\n\nAdhoc and small projects: jupyter notebooks are sufficient most of the times.\nFor adhoc and large projects modules may be needed.\n\nIf the size of code grows, it is useful to organize the code using regular packages.\n\nFor recurring tasks it makes sense to use modules which can be run from command line.\n\nIf the size of code grows, it is useful to organize the code using regular packages.\n\n\n\n17.5.1 Small projects\nFor small projects where the code can be well structured using 4-5 file type modules kept in a root directory.\nAs an example, root of the project can contain\n\nmain.py to run the task from top level\n\nit refers to function definitions and input objects from other modules as described below\nit is a convention to name this file as app.py or main.py\n\ncategory_1.py, category_2.py, … contain all functions for a category of tasks\ninputs.py contains all inputs required for configuration\n\nFolder structure will be flat in this case. Objects can be cross referenced without need of relative imports.\n\nproject root\n\nmain.py\ninputs.py\ncategory_1.py\ncategory_2.py\n\n\n\n\n17.5.2 Large projects\nFor large projects it is advisable to use regular packages. This allows use of relative imports and using sub-packages, i.e. each sub directory is a regular package in itself with file type modules.\nPackages allow categorizing and storing modules in folders and sub folders, then cross referencing objects as needed using relative imports."
  },
  {
    "objectID": "content/architecture/ext-packages.html#built-in",
    "href": "content/architecture/ext-packages.html#built-in",
    "title": "18  Available Modules & Packages",
    "section": "18.1 Built-in",
    "text": "18.1 Built-in\nThese are built-in objects that are always available. They are loaded by default and do not need the use of import.\n\nBuilt-in functions\nBuilt-in constants\nBuilt-in types\nBuilt-in Exceptions"
  },
  {
    "objectID": "content/architecture/ext-packages.html#sec-std-lib",
    "href": "content/architecture/ext-packages.html#sec-std-lib",
    "title": "18  Available Modules & Packages",
    "section": "18.2 Standard library",
    "text": "18.2 Standard library\nStandard library consists of several modules (files and packages) available with standard installation.\nThese have to be loaded using importand are not loaded by default like the built-in objects.\nSome of these, like math and sys, are written in C for speed.\nFull list of available modules with documentation can be found in Python docs: library reference.\n\n18.2.1 Frequently used modules\n\n\n\n\n\n\nTopic\n\n\nModule\n\n\nDescription\n\n\n\n\n\nPython Runtime Services\n\n\n\n\n\nsys\n\n\n\n\n\nSystem-specific parameters and functions\n\n\n\n\n\n\nGeneric Operating System Services\n\n\n\n\n\nos\n\n\n\n\n\nMiscellaneous operating system interfaces\n\n\n\n\n\n\n\nio\n\n\n\n\n\nCore tools for working with streams\n\n\n\n\n\n\n\ntime\n\n\n\n\n\nTime access and conversions\n\n\n\n\n\n\n\nargparse\n\n\n\n\n\nParser for command-line options, arguments and sub-commands\n\n\n\n\n\n\nFile and Directory Access\n\n\n\n\n\npathlib\n\n\n\n\n\nObject-oriented filesystem paths\n\n\n\n\n\n\n\nos.path\n\n\n\n\n\nCommon pathname manipulations\n\n\n\n\n\n\n\nglob\n\n\n\n\n\nUnix style pathname pattern expansion\n\n\n\n\n\n\n\nshutil\n\n\n\n\n\nHigh-level file operations\n\n\n\n\n\n\nData Persistence\n\n\n\n\n\nsqlite3\n\n\n\n\n\nDB-API 2.0 interface for SQLite databases\n\n\n\n\n\n\nFile Formats\n\n\n\n\n\ncsv\n\n\n\n\n\nCSV File Reading and Writing\n\n\n\n\n\n\nFunctional Programming Modules\n\n\n\n\n\nitertools\n\n\n\n\n\nFunctions creating iterators for efficient looping\n\n\n\n\n\n\n\nfunctools\n\n\n\n\n\nHigher-order functions and operations on callable objects\n\n\n\n\n\n\n\noperator\n\n\n\n\n\nStandard operators as functions\n\n\n\n\n\n\nData Types\n\n\n\n\n\ndatetime\n\n\n\n\n\nBasic date and time types\n\n\n\n\n\n\n\nzoneinfo\n\n\n\n\n\nIANA time zone support\n\n\n\n\n\n\nText Processing Services\n\n\n\n\n\nre\n\n\n\n\n\nRegular expression operations\n\n\n\n\n\n\nNumeric and Mathematical Modules\n\n\n\n\n\nmath\n\n\n\n\n\nBasic math\n\n\n\n\n\n\n\nstatistics\n\n\n\n\n\nStatistics"
  },
  {
    "objectID": "content/architecture/ext-packages.html#python-package-index-pypi",
    "href": "content/architecture/ext-packages.html#python-package-index-pypi",
    "title": "18  Available Modules & Packages",
    "section": "18.3 Python package index (PyPI)",
    "text": "18.3 Python package index (PyPI)\nPyPI handles open source contributions to the language. These are external packages which have to be installed before they can be loaded usingimport.\nAs Python is one of the most popular languages, it is easy to find a package for almost every use case by searching the web or PyPI.\npip is the installer for external packages on PyPI.\n\n18.3.1 Some important packages\n\n\n\n\n\n\n\nTopic\n\n\n\n\nModule\n\n\n\n\nDescription\n\n\n\n\n\n\nInstallation\n\n\n\n\npip: home, doc\n\n\n\n\nPython install package\n\n\n\n\n\n\nJupyter\n\n\n\n\njupyterlab: home, doc\n\n\n\n\nJupyterlab, interactive notebooks\n\n\n\n\n\n\nScientific Computing\n\n\n\n\nnumpy: home, doc\n\n\n\n\nFundamental package for scientific computing with Python\n\n\n\n\n\n\nscipy: home, doc\n\n\n\n\nMathematics, science, and engineering. It includes modules for statistics, optimization, integration, linear algebra, Fourier transforms, signal and image processing, ODE solvers, and more.\n\n\n\n\n\n\nData Analysis\n\n\n\n\npandas: home, doc\n\n\n\n\nData structures and operations helpful for data analysis. Dataframes, series, …\n\n\n\n\n\n\nData Visualization\n\n\n\n\nmatplotlib: home, doc\n\n\n\n\nGeneric visualization\n\n\n\n\n\n\nseaborn: home, doc\n\n\n\n\nBased on matplotlib, for statistical visualizations"
  },
  {
    "objectID": "content/architecture/ext-packages.html#sec-venv",
    "href": "content/architecture/ext-packages.html#sec-venv",
    "title": "18  Available Modules & Packages",
    "section": "18.4 Virtual Environments",
    "text": "18.4 Virtual Environments\nVirtual environments are used to creates separate installation location for external packages, which helps with following\n\nkeep installation of external packages organized for different tasks\nkeep track and manage version requirements for external packages needed for specific projects\n\nAt a high level, virtual environment isolates the use of external packages from built-in and standard library.\n\n18.4.1 Why use a virtual env?\nThe external packages keep releasing new versions for bug fixes, enhancements and new features.\nWhen working on projects which depend on external packages it is critical to keep track of version of external packages as latest version might no longer support a feature that the project code needed.\nWhen installing packages in base installation there might be a conflict between dependencies of different project’s. Some projects might depend on a version of a package while other projects might depend on a different version of the same package.\nSome projects might need a specific version of Python itself.\nThere might be some packages which are needed for one time tasks. This keeps on adding complexity of managing packages which are not needed any more.\nAll these reasons lead to development of virtual environments and its use is recommended.\n\n\n18.4.2 Usage\n\nHow to create a virtual environment?\n\nvenv module is part of standard library and can be used with bash commands\nunix/mac: python3 -m venv &lt;path to new venv&gt;\nwin: py [-v] venv &lt;path to new venv&gt;\n\n\nThis creates a folder with the name in the given path. Usually it is helpful to name virtual environments starting with ., e.g. .py-venv. This helps identify that this is a Python virtual environment folder. This dot keeps the folder hidden which is helpful in keeping the folder view clean as the venv folder is seldom used directly.\n\nIt is recommended to use Python version in bash commands, while creating and restoring venv.\n\n\nhow to activate venv using bash?\n\nLinux/Mac:\n\nsource &lt;venv path&gt;/bin/activate\n\nWindows:\n\nsource &lt;venv path&gt;/Scripts/activate\n\nEditors, like VSCode, allow to select Python interpreter for running a project\n\nvenv can be set to be activated by default\n\n\n\nOnce the venv is activated, the associated Python version and external packages installed in the virtual environment are used. Installing packages using pip installs them into the activated virtual environment.\n\nResources\n\nPython docs: venv\n\n\n\n\n18.4.3 Project dependencies\n\nvenv along with pip can be used to manage project dependencies\nvenv keeps installed packages isolated in a virtual environment\npip is used to create a list of required external modules installed in venv\n\nwindows: py [-v] -m pip freeze &gt; py-requirements.txt\nunix/mac: python3 -m pip freeze &gt; py-requirements.txt\nversion dependencies can be managed as well\n\npip is used to re-create venv by installing required external modules contained in &lt;py-requirements.txt&gt; file in venv\n\nwindows: py [-v] -m pip install -r py-requirements.txt\nunix/mac: python3 -m pip install -r py-requirements.txt\n\nresources: pip user guide\n\nWhile using pip or venv it is advisable to use full command with specific Python version. This ensures that the associated pip and venv is used.\npip records &lt;package/module name&gt;==&lt;version number installed&gt;. pip documentation has more details how to manage packages for a project using pip.\n\n\n18.4.4 Structuring venv’s\nThere are a couple of commonly used strategies for organizing and structuring virtual environments.\n\nCentralized approach: keep all virtual environments in a central location\n\nrelated projects can share virtual environments\ntypically location is $HOME/.venvs/&lt;name of venv&gt;\n\nDe-centralized approach: each project has its own virtual environment\n\nsimple but effective as there is no need to manage conflicts\nsimilar projects can be grouped in a root directory with a common venv if needed\n\n\n\nGiven the amount of memory used by virtual environments and simplicity of management, de-centralized approach makes more sense unless there is a specific reason.\n\nA sample small project’s folder structure with venv and git could look like below.\n\nproject root\n\n.git/\n.py-venv/\ndocs/\nmain.py\ninputs.py\ncategory_1_funcs.py\ncategory_2_funcs.py\npy-requirements.txt\n.gitignore"
  },
  {
    "objectID": "content/architecture/engine.html#overview",
    "href": "content/architecture/engine.html#overview",
    "title": "19  Language engine",
    "section": "19.1 Overview",
    "text": "19.1 Overview\nAs discussed in Chapter 2, overview of programming languages, there are 2 distinct aspects related to a programming language, specification and implementation. This book refers to the official implementation of Python which is an interpreter written in C, and therefore also referred to as CPython.\nTherefore below terms usually refer to the default Python implementation.\n\nPython interpreter\nCPython\nCPython interpreter\n\nWhen a Python script is run, Python interpreter does a lot of things in the background. Below diagram is a representation of major steps to help understand the mechanics of run time behavior.\n\n\nThe interpreter checks the conditions for .py file\n\nis .py file a new file\nis .py file modified since last compilation\nwas .pyc file written using an older Python version\n\nIf any of the conditions is true then .py file is compiled to .pyc file (byte code)\nByte code is converted to machine code and sent for processing\n\nThis is an simple representation to help understand run time behavior of interpreter, but under the hood there is much more going on.\nSince Python is a very high level language, there are more number of things kept under the hood, the programmer does not need to deal with them directly. In relatively lower languages like C/C++ some of these have to be dealt with by the programmer. Even in Python, some of the features can be turned off and dealt with directly for some advanced use cases.\nBelow is an introductory overview of things that happen under the hood which interpreter handles.\n\nmanaging execution: sending and receiving of operations and data, to and from the processor\ngarbage collection: clearing un used objects created during execution\nthreads and processes: python interpreter uses single thread and single core at a time by default"
  },
  {
    "objectID": "content/architecture/engine.html#hardware-management",
    "href": "content/architecture/engine.html#hardware-management",
    "title": "19  Language engine",
    "section": "19.2 Hardware Management",
    "text": "19.2 Hardware Management\nTo understand this with full context requires a lot of effort and is beyond the scope until you pursue computer scientist or developer paths, but understanding all this at a high level will help.\nThe first step is to understand the high level map of layers making the computer do what it does.\n\nHardware: CPU controls all the different components. It understands only machine code (binary).\nOperating system (OS): is the first major layer on top of hardware that controls all programs or applications interacting with the hardware.\nPrograms: also referred to as computer applications or just applications. This is the final layer offering specific interactions with the hardware. These have to go through the OS to finally send and receive instructions to and from hardware. Some examples include\n\nfile explorer: provides a graphical interface to interact with the file system stored on hard disk. It displays the information on monitor and provides interaction through mouse and keyboard events.\nbrowser: provides a graphical user interface (gui) to interact with the data on the web. In the background it sends and receives data through network adapter and displays it on monitor.\nnetwork: there are network processes always running in the background to keep the machine connected to web and internal networks\n\n\nThe OS runs some default processes in background to provide the default functionality. In addition to this any application run, is run through the OS, it can create 1 or more independent process[es]. OS allocates space on RAM for each process. An application or program is stored on hard disk as executable or machine code. Once the executable is run, the OS allocates a dedicated space on RAM to the process, which holds the instructions and data to execute. The data and instructions are sent to CPU through OS. The OS manages data and instructions from all running processes.\nFor example when a Python program is run,\n\nOS\n\nstarts process[es] requested by Python interpreter\nallocates space on RAM for these process[es] using some algorithm\nmanages sending/receiving data and instructions to/from CPU received from all running processes\n\nPython interpreter\n\nsends/receives data and instructions to/from CPU through OS\nloads all the resources needed to run the program from hard disk to RAM\nmanages the usage of allocated space on RAM\n\nCPU\n\ndoes all the processing\nmanages all the data and instructions received from OS\nsends back the results to OS\n\n\nThere are 2 critical resources that a program has to manage:\n\nMemory (RAM)\nProcessor (CPU)\n\nPython being a very high level language, manages both these automatically in background, unless programmer specifies not to, in which case there is manual configuration possible.\nLanguages, mostly compiled, like C/C++ provide minimal management and programmer has almost complete control over these aspects, which increases complexity. These are required when developing applications and require a lot of effort to learn them correctly. Typically as a beginner and for light usage of programming, this is not required, general purpose language like Python is sufficient.\n\n19.2.1 Memory (RAM)\nThe space on RAM allocated by the system is used by the program as below representative diagram suggests. The space is broken into components for certain types of data.\nThis is a rough representation and almost all languages follow similar structure, even compiled programs in languages like C/C++.\n\n\n\n\n\nStack and heap are parts which can be accessed from the program.\n\nStack Vs Heap\n\n\n\n\n\n\nStack\nHeap\n\n\n\n\n\nused to store smaller data like references\nrelatively smaller in size\nsize does not grow during execution\n\n\nused for storing larger objects\nsize grows as the need of the program\ngarbage collection is used to clear space automatically\n\n\n\n\n\n19.2.1.1 Stack\nStack is the component of memory used for program execution. It is modeled as stack data structure, like a book stack, where the last book added is removed first, also called last in first out principle or LIFO.\nThe code instructions and variable names are sent to the stack as the program is read and deleted when the instruction completes.\nTerms like stack trace, stack overflow relate to this portion of programs memory allocation.\nStack overflow is self explanatory. It is easy to test, when you run an infinite recursive function with minimal data the stack gets full at around 3000 function calls and you get error as the stack gets full.\nn = 0\ndef inf_rec():\n    global n; n += 1; print(n)\n    while True: inf_rec()\ninf_rec()\nStack trace is the history of instructions sent to stack which helps in debugging and is used to print messages on errors.\n\n\n19.2.1.2 Heap\nHeap is the part of allocated memory which is used for storing data objects. Heap functions like RAM, random memory addresses can be accessed.\nFor example, in Python if code has statement, x = [1, 2, 3, 4, 5], x is stored on stack and the list object is stored on heap.\nHigh level languages like Python have garbage collection which clears heap memory by using internal algorithms.\n\n\n\n19.2.2 Processor management\nManaging the CPU through program is considered as one of the most complex topics in programming as it involves understanding multiple topics\n\nCPU: how CPU processes data and instructions sent to it\nOS: how does OS schedules and manages tasks from all running processes\nProgram: what features the programming language provides to handle execution of different tasks in a program\n\nAll these parts have a lot of details to be understood and then applied together during design of a large program.\nFor regular use of programming there is not much requirement to increase performance by designing the program. This is needed when building large and advanced applications.\nPython interpreter, by default, starts a single process with 1 main thread while running a program. Python has Global interpreter lock (GIL) which limits execution of one thread at a time."
  },
  {
    "objectID": "content/architecture/debug.html#error-types",
    "href": "content/architecture/debug.html#error-types",
    "title": "20  Error handling (debugging)",
    "section": "20.1 Error types",
    "text": "20.1 Error types\nWhile writing a program below are possible types of errors.\n\nLexical and syntax errors: these are easily caught by the editor tools like linter and style checkers\nSemantic errors: when some rules of implementation details are violated\n\ne.g. passing a string to function when number was required\nsome common type of errors are caught by the editor tools, but not all\n\nIncorrect logic: No error but the solution is incorrect\n\ne.g. while using nested loops the order of loop matters"
  },
  {
    "objectID": "content/architecture/debug.html#tools",
    "href": "content/architecture/debug.html#tools",
    "title": "20  Error handling (debugging)",
    "section": "20.2 Tools",
    "text": "20.2 Tools\nMost editors provide support for integrating tools for editing as discussed in tools section (Chapter 9). Related to debugging while writing code there are 2 main relevant parts\n\nEditing tools: syntax highlighting, auto completion, refactoring, etc.\nLint tools\n\nThese are preventive tools that help in avoiding errors at run time. These help avoid lexical and syntax errors. Semantic errors are caught by lint tools to some extent.\nPython interpreter, like most language implementations, provides 2 main tools.\n\nExceptions & trace back\nDebugger: useful for Semantic errors and incorrect logic errors\n\n\n20.2.1 Exceptions & trace back\nExceptions were discussed in Section 12.4. They contain 2 key information\n\nException type\nTrace back: also called stack trace, stack traceback, stack backtrace etc.\n\nThe stack trace is like history of execution instructions sent which caused the error.\nWhen the error is raised, message printed contains both these to help identify\n\nWhere the error occurred\nType of error if it is a known type\n\nIt is useful to note the order of stack trace information. Starting from the bottom, it tells where the error occurred and then traces back where the call to this error originated from.\nBelow is a simple example to illustrate the point. Exception information is displayed at top and bottom and rest is traceback.\n\nsome_list = [1, 2]\n\ndef f1(): some_list.pop()\ndef f2():\n    for i in range(3):\n        f1()\n\nf2()\n\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[1], line 8\n      5     for i in range(3):\n      6         f1()\n----&gt; 8 f2()\n\nCell In[1], line 6, in f2()\n      4 def f2():\n      5     for i in range(3):\n----&gt; 6         f1()\n\nCell In[1], line 3, in f1()\n----&gt; 3 def f1(): some_list.pop()\n\nIndexError: pop from empty list\n\n\n20.2.2 Debugger\nPython interpreter, like most languages, provides a set of tools for debugging, collectively referred to as debugger. These special set of commands which can interrupt the interpreter at given point saving the state of stack and heap and provide interactive execution options.\nVSCode, like most editors, integrates this functionality in the editor. The respective section in VSCode: Python tutorial: Debugging provides a good walkthrough of the functionality.\nNote that almost everything related to debugging can be done manually by writing breakpoints in code and running the script through command line, but editors provide a useful user interface around it.\nDebugger is useful in case of\n\nRuntime errors where error message cannot provide enough information\n\ne.g. Exception is too generic to spot the error\n\nProgram is running correctly but with unintended results\n\nit is not uncommon to get into this situation"
  },
  {
    "objectID": "content/design/design-overview.html#design-patterns",
    "href": "content/design/design-overview.html#design-patterns",
    "title": "Overview",
    "section": "Design patterns",
    "text": "Design patterns\nDesign patterns are abstraction of ways to organize building blocks using the language specifications and architecture to improve properties of a program. Typically a given pattern improves a subset of properties.\nDesign patterns can be specific to a domain within software development or generic.\nThere are 2 distinct dimensions\n\nabstraction of tasks\nabstraction of patterns to implement those tasks\n\nAs the size and number of programs grow, there is progress in both these dimensions. Some patterns emerge as good solution for certain tasks. A certain type of task might be solved using multiple patterns.\nMap reduce is a design pattern which is covered with functions (Section 13.8) using functional programming paradigm. Filter is just a special case of map.\nPython provides many more such design patterns which have not been included to keep the volume and complexity low for an introduction to programming. These topics are suited for an intermediate course, where these can be covered in more detail, like learning to implement these.\n\nMap-reduce\nIterators\nGenerators\nDecorators\nContext managers\nAdvanced OOP\nMeta-programming"
  },
  {
    "objectID": "content/design/dsa.html#introduction",
    "href": "content/design/dsa.html#introduction",
    "title": "21  DSA",
    "section": "21.1 Introduction",
    "text": "21.1 Introduction\nData structures and algorithms, referred to as DSA, is an advanced topic in computer science.\n\nAt macro level, data and correspondingly requirement for data analysis is growing exponentially, different use cases get created with this in every domain. It is thus a requirement to store and operate on data efficiently. Storage has become cheap hence efficiency/speed is more important now.\nEfficiency in context of speed is one of the most needed property of a computer program. Managing storage and operations is a major factor on which efficiency of a program depends.\nThere are multiple ways to increase performance.\n\nHardware: faster CPU, which is hitting a boundary\nProgram Design: concurrency, multi-threading, multi-processing, async-io\nDSA: has been instrumental in increased performance of applications\n\n\nAt micro level, a program instructs CPU to perform operations which take time.\n\nload data into RAM\nfetch data from RAM\noperate on data\nwrite data onto RAM\n\nAll these operations happen at very large scale even in simple programs, e.g. basic data analysis. Therefore designing how the data is structured (data structure) and operated upon (algorithms) allows reducing these operations to improve performance.\n\nComputer scientists are involved in rigorous study of the topic, including math involved, to come up with new data structures and algorithms. There are 2 main challenges\n\nfind optimal solutions in terms of speed and design to the ever expanding field of data\nprove and communicate the solutions\n\nAs a user, the problem is to match the right data structure if it exists with the use case.\nAs an advanced user or developer there might be a need to implement needed data structures.\nSome languages like Python provide implementation of basic data structures as default while others like C leave it to the users to implement.\nIn Python, sequence types like list and tuple, mapping types like set and dictionary are all end result of this field of study, and are implemented and provided by default.\nThe choice of data structure decides available algorithms for different operations implemented for a data structure.\nChoosing the data structure depends on use case\n\nhow data is to be structured?\nwhich type of operations are to be performed?\nhow frequently?\n\n\nThis section of the course aims to present and introduce some of the core results which are used currently, along with context and intuition behind the developments in the field. This should help\n\neveryone\n\nduring usage of these concepts in writing programs\n\nsomeone whose target is to get into software development\n\nlay foundation for advanced study of the topic\n\n\n\nThe study of data structures and algorithms can be summarized as below.\n\nproblem specification: interface\n\nspecification for structure of data\nspecification for operations needed to be performed on data\n\nsolution/implementation\n\ndata structure: implementation of how to store the data with given structure\nalgorithms: implementation of how to perform operations for a given data structure\n\nmeasuring efficiency\n\nasymptotic notation\ncomputation model: WordRAM model\n\n\n\n21.1.1 Interface vs data structure\n::: {.cell hash=‘dsa_cache/html/unnamed-chunk-2_a7710c95af39b94bdb9f703d727abc35’}\n\n\n\n\n\n\nInterface\n\n\n\n\nData structure & Algorithms\n\n\n\n\n\n\nInterface is a specification of structure of data and operations that should be supported\n\n\n\n\nData structure is a implementation to store data with specified structure\n\n\nAlgorithms for a given data structure are the implementation of operations\n\n\n\n\n\n\nInterface is a specification\n\n\n\n\nData structure with Algorithms is an implementation\n\n\n\n\n\n\nInterface is the problem definition\n\n\n\n\nData structure with algorithms is a solution\n\n\n\n\n\n\nThere could be multiple data structures for the same interface, performance will be different\n\n\n\n\nA data structure might solve multiple interfaces, performance will be different\n\n\n\n\n:::"
  },
  {
    "objectID": "content/design/dsa.html#measuring-efficiency",
    "href": "content/design/dsa.html#measuring-efficiency",
    "title": "21  DSA",
    "section": "21.2 Measuring efficiency",
    "text": "21.2 Measuring efficiency\nThere are 2 major costs involved while using a data structure\n\ntime taken to perform operations\nmemory (space) used on RAM\n\nMeasuring time and memory usage depends on 2 factors\n\ncomputation model (hardware)\nhow the data structure uses this model\n\nTypically time is more critical as memory is considered cheap in the context of present day computer hardware.\n\n21.2.1 Computation model\nComputational model refers to abstracting hardware performance in general terms to study the behavior of different operations to be performed. Typically word RAM model is used in theoretical studies. In practice it may differ.\nImplication of assumptions in word RAM model are that all elementary operations take constant amount of time\n\nread, write, delete in RAM for a location\nmathematical operations\nlogical operations\n\n\nRAM =&gt; Random access memory\n\n\n\n21.2.2 Measuring time\n\n21.2.2.1 Context\nTime complexity of an algorithm can be measured in different ways based on different contexts.\n\nhow the time complexity is measured?\n\nmeasure time to run the algorithm\nmeasure operations performed and how they grow with size of data structure\n\nwhat time is captured?\n\nbest case time\naverage time\nworst case\n\n\nMeasuring time directly has following disadvantages\n\nit depends on the quality of machine\n\ntests can be run on various machines but that is inefficient\ntesting a slow algorithm on very fast machine leads to false conclusions\n\nit depends on size of data\n\ntests can be run on different data sizes but it is difficult to test for very large sizes\n\n\nIt is more useful to measure time in terms of operations performed and then see how they grow with size of data. Using this approach isolates dependency on machine.\nUsing best case time for deciding time complexity might give false results as an algorithm might be fast on small data size but perform slow on large data size.\nUsing average time will give more information, but for that the probability distribution is needed to decide which data sizes will be used more frequently. It is very difficult to get an accurate distribution hence this option is not feasible.\nWorst case time is used as it ensures bound on performance and reduces noise in comparing performance of different algorithms.\n\n\n21.2.2.2 Solution\nTime complexity is measured for worst case performance, using asymptotic notation for number of operations performed depending on data size, usually represented with \\(n\\).\n\n\n21.2.2.3 Asymptotic notation\nAsymptotic notation is used to get an idea of asymptotic growth ignoring scaling factors and constants. More formally, asymptotic notation represents a set of functions.\nAsymptotic growth simply means how the growth of a function behaves when the underlying variable grows too large. For example, if the the performance of an algorithm for a data structure takes the form \\(T(n) = 3n^2\\), what is the growth in value of \\(T(n)\\) as \\(n \\to \\infty\\), where \\(T(n)\\) is the time the algorithm takes and \\(n\\) is the size of data structure.\nBelow are the set of asymptotic notations.\n::: {.cell hash=‘dsa_cache/html/unnamed-chunk-3_f636423a2aacb57c7ba399c947ebee67’}\n\n\n\n\n\n\n\nName\n\n\n\nNotation\n\n\n\nDescription\n\n\n\n\n\n\nAsymptotically Equal\n\n\n\n\\(f \\sim g\\)\n\n\n\n\n\n\n\n\nBig O\n\n\n\n\n\\(f \\in O(g)\\)\n\n\n\n\nupper bound\n\n\n\n\n\n\n\nOmega\n\n\n\n\\(f \\in \\Omega(g)\\)\n\n\n\nlower bound\n\n\n\n\n\n\n\nTheta\n\n\n\n\n\\(f \\in \\Theta(g)\\)\n\n\n\n\nboth upper and lower bound\n\n\n\n\n\n\n\nSmall O\n\n\n\n\\(f \\in o(g)\\)\n\n\n\nstrictly larger\n\n\n\n\n\n\nLittle Omega\n\n\n\n\\(f \\in \\omega(g)\\)\n\n\n\nstrictly smaller\n\n\n\n\n:::\nTheta and Big O are mostly used in measuring complexity.\nThe notation is some times used as \\(f(n) = O(g(n))\\) but it is more accurate to use \\(f(n) \\in O(g(n))\\) as \\(O(g(n))\\) denotes a collection of functions.\n\nDefinition 21.1 (O Notation) A non-negative function \\(f(n)\\) is in \\(O(g(n))\\) if and only if there exist constants \\(c, n_0 \\in \\mathbb{R}\\) such that \\(f(n) \\le c \\cdot g(n) \\quad \\forall \\ n &gt; n_0\\).\n\n\nDefinition 21.2 (Omega Notation) A non-negative function \\(f(n)\\) is in \\(\\Omega(g(n))\\) if and only if there exist constants \\(c, n_0 \\in \\mathbb{R}\\) such that \\(f(n) \\ge c \\cdot g(n) \\quad \\forall \\ n &gt; n_0\\).\n\n\nDefinition 21.3 (Theta Notation) A non-negative function \\(f(n)\\) is in \\(\\Theta(g(n))\\) if and only if \\(f(n) \\in (O(g(n)) \\cap \\Omega(g(n)))\\).\n\nFor example, if it is concluded that number of operations in an algorithm is given by the function \\(T(n) = 3n^2 + 4n+ 2\\) then \\(T(n) \\in \\Theta(n^2)\\). Theta notation allows for stating complexity in simpler terms ignoring scaling and constant factors.\nBelow plots show how the \\(n^2\\) term dominates as n grows larger.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn terms of efficiency of algorithms it is often desired to keep the complexity low. Below are the common functions which complexity takes in increasing order. Anything below linear is considered good.\n::: {.cell hash=‘dsa_cache/html/theta order_1b2cc2dc34fcf53acac03363de6d8dc1’}\n\n\n\n\n\n\n\n\n\nConstant\n\n\nLogarithmic\n\n\nLinear\n\n\nQuadratic\n\n\nPolynomial\n\n\nExponential\n\n\n\n\n\\(\\Theta(1)\\)\n\n\n\\(\\Theta(log(n))\\)\n\n\n\\(\\Theta(n)\\)\n\n\n\\(\\Theta(n^2)\\)\n\n\n\\(\\Theta(n^c)\\)\n\n\n\\(2^{\\Theta(n^c)}\\)\n\n\n\n:::"
  },
  {
    "objectID": "content/design/dsa.html#interfaces",
    "href": "content/design/dsa.html#interfaces",
    "title": "21  DSA",
    "section": "21.3 Interfaces",
    "text": "21.3 Interfaces\nInterface provides the abstract or theoretical requirements of storing and operating on certain type of data. For example, tuple, list or dictionary is used depending on the use case. Abstraction and generalization of use cases is interface. Tuple, list and dictionary are the implementation or data structures.\nInterfaces are also referred to as\n\nApplication programming interface (API): by developers\nAbstract data type (ADT): by computer scientists\n\nThere are 2 main types of interfaces.\n\nsequence\n\nextrinsic order: order of items provided externally is preserved\nspecial sequence types\n\nstack: insert last and delete last (LIFO: last in first out)\nqueue: insert last and delete first (FIFO: first in first out)\ndequeue (aka deque, double-ended queue)\n\n\nmapping (also referred to as set, associative array)\n\nintrinsic order: items identified by unique keys, keys can optionally be stored in order\ntypes of mapping types\n\nset: items are keys themselves\ndictionary: items are associated with keys\n\n\n\n\n21.3.1 Operations\nOperations on major interfaces can be categorized into 3 basic types\n\ncontainer operations: operations on container itself\n\ne.g. build, length\n\nstatic operations: operations on elements that do not alter the container\n\ne.g. search (query) operations on elements by index (sequence) or value (mapping)\n\ndynamic operations: operations on elements that alter the container itself\n\ne.g. inserting, deleting elements\n\n\nBelow tables summarize the common operation specifications for sequence and mapping interfaces.\n\n21.3.1.1 Sequence interface\n::: {.cell hash=‘dsa_cache/html/unnamed-chunk-6_eac6892efbcf55c21b5c01252ee0c7e4’}\n\n\n\n\n\n\n\nCategory\n\n\n\n\nMethod\n\n\n\n\nDescription\n\n\n\n\n\n\nContainer\n\n\n\n\nbuild(I)\n\n\n\n\nbuild a sequence from items in iterable\n\n\n\n\n\n\n\n\nlen(x)\n\n\n\n\nreturn number of items\n\n\n\n\n\n\nStatic\n\n\n\n\niter_seq(x)\n\n\n\n\nreturn stored items one at a time in sequence order\n\n\n\n\n\n\n\n\nget_at(i)\n\n\n\n\nreturn the item at index i\n\n\n\n\n\n\n\n\nset_at(i, x)\n\n\n\n\nreplace the item at index i with x\n\n\n\n\n\n\nDynamic\n\n\n\n\ninsert_at(i, x)\n\n\n\n\nadd x as i^th item\n\n\n\n\n\n\n\n\ndelete_at(i)\n\n\n\n\nremove and return i^th item\n\n\n\n\n\n\n\n\ninsert_first(x)\n\n\n\n\nadd x as the first item\n\n\n\n\n\n\n\n\ndelete_first()\n\n\n\n\nremove and return 1^st item\n\n\n\n\n\n\n\n\ninsert_last(x)\n\n\n\n\nadd x as the last item\n\n\n\n\n\n\n\n\ndelete_last()\n\n\n\n\nremove and return last item\n\n\n\n\n:::\n\n\n21.3.1.2 Map interface\n::: {.cell hash=‘dsa_cache/html/unnamed-chunk-7_ed4d2d5e8b648e6dad5aa6ad6fa7be77’}\n\n\n\n\n\n\n\nCategory\n\n\n\n\nMethod\n\n\n\n\nDescription\n\n\n\n\n\n\nContainer\n\n\n\n\nbuild(I)\n\n\n\n\nbuild a sequence from items in iterable\n\n\n\n\n\n\n\n\nlen(x)\n\n\n\n\nreturn number of items\n\n\n\n\n\n\nStatic\n\n\n\n\nfind(k)\n\n\n\n\nreturn stored item with key k\n\n\n\n\n\n\nDynamic\n\n\n\n\ninsert(x)\n\n\n\n\nadd x to set with key x.key, replace if key exists\n\n\n\n\n\n\n\n\ndelete(k)\n\n\n\n\nremove and return the item with key k\n\n\n\n\n\n\nOrder\n\n\n\n\niter_order()\n\n\n\n\nreturn the stored items one by one in key order\n\n\n\n\n\n\n\n\nfind_min()\n\n\n\n\nreturn the item with smallest key\n\n\n\n\n\n\n\n\nfind_max()\n\n\n\n\nreturn the item with largest key\n\n\n\n\n\n\n\n\nfind_next(k)\n\n\n\n\nreturn the item with key larger than k\n\n\n\n\n\n\n\n\nfind_prev(k)\n\n\n\n\nreturn the item with key smaller than k\n\n\n\n\n:::"
  },
  {
    "objectID": "content/design/dsa.html#data-structures",
    "href": "content/design/dsa.html#data-structures",
    "title": "21  DSA",
    "section": "21.4 Data structures",
    "text": "21.4 Data structures\nData structures are the actual implementations of interfaces. There is no single data structure that solves all operations required in an interface efficiently. Different data structures solve a subset of operations efficiently.\nBelow are main types of data structures\n\narray based: static array, dynamic array\npointer based: linked list (w[/o] tail), doubly linked list (w[/o] tail)\nhash table (array and pointer mixed)\ngraph based: binary search tree, AVL tree, …\n\n\n21.4.1 Static array\nRandom access memory (RAM) of computer hardware is like a giant continuous slots of memory addresses.\nA static array finds and stores data in contiguous slots of equal size, depending on the size of data elements. The order is extrinsic, i.e. the items are stored in the order provided.\nThe static array object then needs to contain only the start memory address and length of the array.\n\nstatic operations: constant time (\\(\\Theta(1)\\))\n\nmemory address(i) = memory address(0) + i * item storage size\n\ndynamic operations: linear time (\\(\\Theta(n)\\))\n\n\nPython tuples are approximately static array, one main difference is tuples are immutable, i.e. modification operations are not supported, a new object is created on modification.\nBelow are tables for performance of static array for sequence and map operations. Static arrays are efficient for sequences with static operations only.\nFor dynamic operations, in the worst case new contiguous slot of free memory has to be looked and container has to be build, therefore it is \\(O(n)\\) operations.\n\n\n\n\n\n\n\n\nSequence interface operations - \\(O(\\cdot)\\)\n\n\n\n\n\n\n\n\nBuild\n\n\n\n\nStatic\n\n\n\n\nDynamic\n\n\n\n\n\nData Structure\n\n\nbuild(X)\n\n\nget_at(i) set_at(i)\n\n\ninsert_first(x) delete_first()\n\n\ninsert_last(x) delete_last()\n\n\ninsert_at(i, x) delete_at(i)\n\n\n\n\n\n\narray\n\n\nn\n\n\n1\n\n\nn\n\n\nn\n\n\nn\n\n\n\n\n\n\nNote: \n\n\n\n\n \\(\\cdot_{(a)}\\) implies amortized, \\(\\cdot_{(e)}\\) implies expected, h is height of the tree\n\n\n\n\n\n\n\n\n\n\n\n\n\nMap interface operations - \\(O(\\cdot)\\)\n\n\n\n\n\n\n\n\nBuild\n\n\n\n\nStatic\n\n\n\n\nDynamic\n\n\n\n\nOrder\n\n\n\n\n\nData Structure\n\n\nbuild(X)\n\n\nfind(k)\n\n\ninsert(k) delete(k)\n\n\nfind_min() find_max()\n\n\nfind_prev(k) find_next(k)\n\n\n\n\n\n\narray\n\n\nn\n\n\nn\n\n\nn\n\n\nn\n\n\nn\n\n\n\n\n\n\nNote: \n\n\n\n\n \\(\\cdot_{(a)}\\) implies amortized, \\(\\cdot_{(e)}\\) implies expected, h is height of the tree\n\n\n\n\n\n\n\n21.4.2 Linked list\n\n21.4.2.1 Singly linked list without tail\n\n\n\n\nrandom slots alloted\nobject stores the\n\nhead memory address\nlen\n\neach node stores\n\nitem\nlink to next nodes memory address\n\n\n\n\n \n\n\n\nstatic operations: linear time (\\(\\Theta(n)\\))\ndynamic operations\n\ninsert/delete first: constant time (\\(\\Theta(1)\\))\nother: linear time (\\(\\Theta(n)\\))\n\n\n\n\n\n\n\n\n\n\n\n\n\nSequence interface operations - \\(O(\\cdot)\\)\n\n\n\n\n\n\n\n\nBuild\n\n\n\n\nStatic\n\n\n\n\nDynamic\n\n\n\n\n\nData Structure\n\n\nbuild(X)\n\n\nget_at(i) set_at(i)\n\n\ninsert_first(x) delete_first()\n\n\ninsert_last(x) delete_last()\n\n\ninsert_at(i, x) delete_at(i)\n\n\n\n\n\n\nlinked list\n\n\nn\n\n\nn\n\n\n1\n\n\nn\n\n\nn\n\n\n\n\n\n\nNote: \n\n\n\n\n \\(\\cdot_{(a)}\\) implies amortized, \\(\\cdot_{(e)}\\) implies expected, h is height of the tree\n\n\n\n\n\n\n21.4.2.2 Doubly linked list with tail\n\n\n\n\nrandom slots alloted\nobject stores the\n\nhead memory address\ntail memory address\nlen\n\neach node stores\n\nitem\nmemory address of previous node\nmemory address of next node\n\n\n\n\n\nstatic operations: linear time (\\(\\Theta(n)\\))\ndynamic operations\n\ninsert/delete first: constant time (\\(\\Theta(1)\\))\ninsert/delete last: constant time (\\(\\Theta(1)\\))\nother: linear time (\\(\\Theta(n)\\))\n\ngood for implementing stack and queue with unknown length\n\ninsert/delete first/last\naka push/pop/queue/dequeue\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSequence interface operations - \\(O(\\cdot)\\)\n\n\n\n\n\n\n\n\nBuild\n\n\n\n\nStatic\n\n\n\n\nDynamic\n\n\n\n\n\nData Structure\n\n\nbuild(X)\n\n\nget_at(i) set_at(i)\n\n\ninsert_first(x) delete_first()\n\n\ninsert_last(x) delete_last()\n\n\ninsert_at(i, x) delete_at(i)\n\n\n\n\n\n\nlinked list\n\n\nn\n\n\nn\n\n\n1\n\n\nn\n\n\nn\n\n\n\n\ndoubly linked list w/ tail\n\n\nn\n\n\nn\n\n\n1\n\n\n1\n\n\nn\n\n\n\n\n\n\nNote: \n\n\n\n\n \\(\\cdot_{(a)}\\) implies amortized, \\(\\cdot_{(e)}\\) implies expected, h is height of the tree\n\n\n\n\n\n\n\n\n21.4.3 Dynamic array\n\nProvides faster insert/delete first/last operations\nExtra space is alloted at beginning/end\nIdea is to amortize the cost of operations by providing extra space\n\nwhen list is full, it is extended by a target fill ratio\nwhen list is empty, the size is reduced to target delete ratio\n\nPython list is a dynamic array, with extra slots alloted both in the beginning and end of container\n\ninserting or deleting at first or last position takes \\(O(1)\\) time (averaged over \\(n\\) operations)\n\n\n\n\n\n\n\n\n\n\n\nSequence interface operations - \\(O(\\cdot)\\)\n\n\n\n\n\n\n\n\nBuild\n\n\n\n\nStatic\n\n\n\n\nDynamic\n\n\n\n\n\nData Structure\n\n\nbuild(X)\n\n\nget_at(i) set_at(i)\n\n\ninsert_first(x) delete_first()\n\n\ninsert_last(x) delete_last()\n\n\ninsert_at(i, x) delete_at(i)\n\n\n\n\n\n\ndynamic array\n\n\nn\n\n\n1\n\n\n\\(1_{(a)}\\)\n\n\n\\(1_{(a)}\\)\n\n\nn\n\n\n\n\n\n\nNote: \n\n\n\n\n \\(\\cdot_{(a)}\\) implies amortized, \\(\\cdot_{(e)}\\) implies expected, h is height of the tree\n\n\n\n\n\n\n\n21.4.4 Hash tables\n\n21.4.4.1 Overview\nHash tables are used to implement set interface: sets and dictionaries.\n\nRequirement: find items based on keys efficiently\n\narrays find item by looking up memory address based on index\nin set interface the keys can be strings or other objects\nsearch based on item value in array is not fast\n\nKey idea is to associate/map the keys with non negative integers (index)\n\nintegers map to memory address\ngiven the key, find the associated integer with the key\ngiven the integer, find the associated key\n\nKeys can be numeric, strings or other objects\n\ngenerally, they must be unique\n\n\n\n\n21.4.4.2 Hashing numbers\nTaking example of a phone book where the requirements are\n\nstore names and phone numbers\nsearch by phone number: hashing numbers\nsearch by name: hashing strings\n\n\n\nassuming phone numbers are 15 digit numbers\n\\(u\\) is the set of all possible 15 digit numbers\n\nsize of universe is \\(|u| = 10^{15} = 1,000,000,000,000,000\\)\nnot possible to store array of this size\nthis makes use of direct access array (\\(|m| = |u|\\)) impractical\n\nlet \\(n\\) be the set of numbers to be stored \\(|n| = ?\\), e.g. \\(|n| \\le 1000\\)\n\\(m\\) is the array of reduced size that you can store\n\nchoose \\(|m|\\) such that \\(|n| \\le |m|\\)\nsize of the array is \\(|m|\\), assume \\(|m| = 1000\\)\n\nhash function maps the key from \\(u \\to m\\)\nhash table is the map of key from \\(u \\to m\\)\nto search any key takes \\(\\Theta(1)\\) time\n\nconvert the key to array index using hash function\naccess the returned index\n\n\n\n\n21.4.4.3 Collisions and chaining\n\n\nassuming \\(n = 4\\) contacts have to be stored in array of size \\(|m| = 7\\)\nsince \\(|u| &gt;&gt;&gt;&gt; |m|\\) (\\(|u| = 10^{15}\\)) there will be collisions\n\ncollisions: hash function will give same integer for multiple inputs \\(h(k_1) = h(k_2)\\), where \\(k_1 \\ne k_2\\)\nthis is by pigeon hole principle\n\nthere are 2 methods to resolve the issue of collisions\n\nchaining: store collisions in a linked list\nopen addressing: store collisions in next free slot\n\n\n\n\n21.4.4.4 Hashing strings\n\nconvert characters into integers using ascii or unicode\nthere are many methods to combine the codes to form an integer\nthen rest of the problem is similar to hashing numbers\nthere are many good solutions available\nto maintain the phone book by both name and number use 2 hash tables\none hash table with hash of numbers, other with hash of strings\n\n\n\n21.4.4.5 Key requirements for a good hash function\n\ndeterministic: returns same integer for a given key always\nfast to compute: \\(\\Theta(1)\\)\nkeep the array size (\\(|m|\\)) low to minimize space\nkeep number of collisions low\n\n\n\n21.4.4.6 Use cases\n\nHash tables have revolutionized searching and can be found everywhere in technology\nSets and dictionaries are generally implemented using hash table\n\nPython dict and set\n\nLanguage interpreter does fast lookup for keywords\nContact list in phones\nWeb and other text searches use hashing\nApplications use hash table for configuration files to search settings\n\n\n\n\n21.4.5 Summary\n\n21.4.5.1 Sequence interface\n\n\n\n\n\n\n\n\nSequence interface operations - \\(O(\\cdot)\\)\n\n\n\n\n\n\n\n\nBuild\n\n\n\n\nStatic\n\n\n\n\nDynamic\n\n\n\n\n\nData Structure\n\n\nbuild(X)\n\n\nget_at(i) set_at(i)\n\n\ninsert_first(x) delete_first()\n\n\ninsert_last(x) delete_last()\n\n\ninsert_at(i, x) delete_at(i)\n\n\n\n\n\n\narray\n\n\nn\n\n\n1\n\n\nn\n\n\nn\n\n\nn\n\n\n\n\nlinked list\n\n\nn\n\n\nn\n\n\n1\n\n\nn\n\n\nn\n\n\n\n\ndoubly linked list w/ tail\n\n\nn\n\n\nn\n\n\n1\n\n\n1\n\n\nn\n\n\n\n\ndynamic array\n\n\nn\n\n\n1\n\n\n\\(1_{(a)}\\)\n\n\n\\(1_{(a)}\\)\n\n\nn\n\n\n\n\nbinary tree\n\n\nn\n\n\nh\n\n\nh\n\n\nh\n\n\nh\n\n\n\n\navl tree\n\n\nn\n\n\nlog n\n\n\nlog n\n\n\nlog n\n\n\nlog n\n\n\n\n\n\n\nNote: \n\n\n\n\n \\(\\cdot_{(a)}\\) implies amortized, \\(\\cdot_{(e)}\\) implies expected, h is height of the tree\n\n\n\n\n\n\n\n21.4.5.2 Map interface\n\n\n\n\n\n\n\n\nMap interface operations - \\(O(\\cdot)\\)\n\n\n\n\n\n\n\n\nBuild\n\n\n\n\nStatic\n\n\n\n\nDynamic\n\n\n\n\nOrder\n\n\n\n\n\nData Structure\n\n\nbuild(X)\n\n\nfind(k)\n\n\ninsert(k) delete(k)\n\n\nfind_min() find_max()\n\n\nfind_prev(k) find_next(k)\n\n\n\n\n\n\narray\n\n\nn\n\n\nn\n\n\nn\n\n\nn\n\n\nn\n\n\n\n\nsorted array\n\n\nn log n\n\n\nlog n (binary search)\n\n\nn\n\n\n1\n\n\nlog n\n\n\n\n\ndirect access array\n\n\nu\n\n\n1\n\n\n1\n\n\nu\n\n\nu\n\n\n\n\nhash tables\n\n\n\\(n_{(e)}\\)\n\n\n\\(1_{(e)}\\)\n\n\n\\(1_{(e)(a)}\\)\n\n\nn\n\n\nn\n\n\n\n\nbinary tree\n\n\nn log n\n\n\nh\n\n\nh\n\n\nh\n\n\nh\n\n\n\n\navl tree\n\n\nn log n\n\n\nlog n\n\n\nlog n\n\n\nlog n\n\n\nlog n\n\n\n\n\n\n\nNote: \n\n\n\n\n \\(\\cdot_{(a)}\\) implies amortized, \\(\\cdot_{(e)}\\) implies expected, h is height of the tree"
  },
  {
    "objectID": "content/design/dsa.html#algorithms",
    "href": "content/design/dsa.html#algorithms",
    "title": "21  DSA",
    "section": "21.5 Algorithms",
    "text": "21.5 Algorithms\nAlgorithm is a procedure to solve a problem.\nStudy of algorithms involves study of finding correct and efficient procedures to solve problems.\nSome classical algorithms are listed below along with their efficiency.\n\n\n\n\n\n\n\n\nApplication\n\n\n\n\nName\n\n\n\n\nPerformance\n\n\n\n\nComments\n\n\n\n\n\n\nSearch\n\n\n\n\nLinear search\n\n\n\n\\(O(n)\\)\n\n\n\n\nIterative\n\n\n\n\n\n\n\n\n\nBinary search\n\n\n\n\\(O(Log_2 \\ n)\\)\n\n\n\n\nRecursive\n\n\nWorks on sorted arrays\n\n\n\n\n\n\n\nSort\n\n\n\n\nInsertion Sort\n\n\n\n\\(O(n^2)\\)\n\n\n\n\nIn-place\n\n\nUnstable\n\n\n\n\n\n\n\n\n\nSelection Sort\n\n\n\n\\(O(n^2)\\)\n\n\n\n\nIn-place\n\n\n\n\n\n\n\n\n\nMerge Sort\n\n\n\n\\(O(n Log_2 \\ n)\\)\n\n\n\n\nCreates new collection\n\n\nRecursive\n\n\n\n\n\nAn algorithm is a solution to implementing operations like search and sort for a data structure.\nAn operation for a implementation of a data structure can use any of the compatible algorithms, but not all will be efficient. For example, for sorting an array merge sort is much quicker than most algorithms.\nThe algorithms provided here should also serve as mini projects to research and implement the algorithm. This should be a good practice to apply combining basic building blocks in previous sections."
  },
  {
    "objectID": "content/design/regex.html",
    "href": "content/design/regex.html",
    "title": "22  Regular Expressions",
    "section": "",
    "text": "Regular expressions, commonly referred to as “regex”, are an abstract specification of creating patterns to do advanced search and replace operations on strings. They are like specification for a mini language for string (text) operations.\nThere are multiple implementations of this abstract specification with many common features but subtle differences for different use cases.\nPython itself has multiple different flavors/implementations of regular expressions.\n\nGeneric pattern matching in Python\n\nre module in standard library: simple tutorial, exhaustive documentation\nregex package in PyPI, extension of re module: homepage\n\nUnix style pathname pattern matching, used in bash commands\n\nglob module\npathlib module in standard library provides Path.glob()\n\n\nThe key idea is to provide much more powerful pattern searching than regular string methods provide. For example, to search all pdf files in a folder you can use *.pdf pattern to do a search on all file names. Or, ^project pattern to find all files starting with the word project.\nRegular expressions provide much more advanced features but are slower compared to regular string methods. The python tutorial has a section dedicated to describe the issue with choice between using string methods and regular expressions.\nRegular expressions can get very messy very fast. So in the beginning use only basics of regex, when it is clear that string method is not available or will be too complex. The most common situation is to use regex for path related operations."
  },
  {
    "objectID": "content/design/workflow.html#overview",
    "href": "content/design/workflow.html#overview",
    "title": "23  Workflow",
    "section": "23.1 Overview",
    "text": "23.1 Overview\nDesigning workflow in context of programming can be split into 2 dimensions.\n\nProgram: micro level, workflow while writing code\nProject: macro level, workflow of overall project"
  },
  {
    "objectID": "content/design/workflow.html#program",
    "href": "content/design/workflow.html#program",
    "title": "23  Workflow",
    "section": "23.2 Program",
    "text": "23.2 Program\nWhile writing code there are 2 major dimensions.\n\nEditing tools: like prediction, linting etc.\n\nthese only help with basic checks and completion\nthese are managed at project level through editor settings\n\nElements of code related to properties of a good program\n\nThis part of workflow design is related to the 2nd dimension and is dealt with refactoring.\n\n23.2.1 Refactoring\nRefactoring means reviewing and changing code to attain properties of a good program, without changing the actual output.\nRecommended properties of a good program are: readable, testable, modular, extensible, efficient\nSome practical aspects of writing programs are\n\nThere are multiple ways to solve the same problem\nIt is a cyclical process of writing code and refactoring\nMore often than not, refactoring opportunities become apparent only while reviewing code\n\n\n\n23.2.2 Recommendations\n\nFollow naming conventions\nUse doc strings\nUse and follow type annotations\n\nmake exceptions only if necessary\n\nUse comments where necessary\nAny task repeated more than a couple of times can be considered to be put into a function\nFunctions should have minimum possible responsibilities, ideal is single responsibility\nUse appropriate data types\n\n\n\n23.2.3 Sample workflow\nBelow is a workflow for writing code, to cover aspects that editing tools cannot cover.\n\nStep 1: focus on getting the the code to produce the correct result using recommended practices\nStep 2: review the code for opportunities for refactoring\nStep 3: refactor code\nStep 4: goto step 1\n\nNote that the process given is an infinite recursion, the base case is when there is no further refactoring needed and it depends on size of the project, skills and experience. For small projects 2 to 3 recursions should be enough. For larger projects the requirements expand quickly."
  },
  {
    "objectID": "content/design/workflow.html#projects",
    "href": "content/design/workflow.html#projects",
    "title": "23  Workflow",
    "section": "23.3 Projects",
    "text": "23.3 Projects\nLearning and practising project workflow management from the very start and for smallest of projects is recommended as it has many advantages like\n\nWorkflow becomes operationally more\n\norganized\nefficient\n\nReduces errors\nAllows more time on design and thought\n\nSection 23.3.2 contains discussions on some key considerations while managing programming projects in general from a user of programming perspective. Python related solutions are discussed at respective places.\nSection 23.3.3 illustrates a Python specific sample project structure which can work as a starter template.\nPython documentation has a section dedicated to this for structuring Python projects specifically. Although Python documentation aims at developers who need to publish their packages on PyPI, still it gives good background to Python project management in general.\n\n23.3.1 Tools: Settings\nWhile programming, most of the interaction is with editor. Through editor all the underlying tools, like terminal, Python, git etc., are accessible.\nManaging the tools and related settings, including extensions, is an essential part of project workflow.\nVSCode related settings can easily be managed through use of workspaces and profiles.\nTasks in VSCode provide automation related to projects.\nSync can be used to keep the settings in the cloud, which makes it easy to switch between computers.\n\nVSCode: workspaces\nVSCode: profiles\nVSCode: tasks\nVSCode: sync\n\n\n\n23.3.2 Components\n\n23.3.2.1 Dependencies\nThere are 2 key dependencies of a Python project.\n\nPython version used: document using a pyproject.toml file\nExternal packages and their version used in the project\n\nvirtual environments provide solutions\n\n\n\n23.3.2.1.1 Python version\nPython, once installed, is machine and os independent. Python is available for most of the used computer system and operating system combinations.\nIf a project runs on a Python version on a pc then it will run on a different pc with a different architecture and operating system if the same Python version can be installed on it.\nAs one starts to use programming, recording the Python version should be sufficient, to be able to reproduce the project later. To be extra safe machine and operating system can be documented too if needed.\npyproject.toml file is used currently by Python developers for storing metadata about a Python project for creating and distributing packages, which can be used for storing Python version details and some other basic metadata about the project in a structured way. Note that the name is required to be pyproject.toml in case automation tools are used later as they check for a file with this specific name.\nMore details can be found at Python Docs: Packaging: pyproject.toml\n\n\n23.3.2.1.2 External packages\nAs a user in programming most of the projects will use external modules and packages to find solution to a problem.\nDependencies and solutions related to this have been discussed in Section 18.4 related to virtual environments.\n\n\n\n23.3.2.2 Documentation\nDocumentation is a critical part of any code project as it helps the author and users throughout the lifecycle of the project. The most common situation is when looking at the code written by self after some time becomes hard to understand. Documentation helps in this situation too.\nThere are 3 key areas of documentation.\n\nDoc strings: document functions, classes\nComments: in the code itself to explain key concepts and logic applied\nreadme.md: documentation for the project at high level\n\nVSCode extension, autoDocstring - Python Docstring Generator can be used to assist in creating docstrings. Using such tools help use best practices evolved by experience of developers.\nThere are tools like Sphinx to automate parts of documentation of Python projects. These are generally needed for large coding projects.\nOne of the most important aspect is to structure the code so that it documents itself. For example naming objects, files and folders well so that they are self explanatory. Organizing function definitions and calls such that they self explain the flow of logic implemented. Giving thought to these aspects complements documentation.\n\n\n23.3.2.3 Version control\nUses of version control systems has been discussed in Chapter 6. While using git below are some things that should be part of the workflow.\n\nRegularly maintain .gitignore file\n\n.py-venv folder is large and need not be tracked as it can be restored using requirements file\nanticipate and add directory and file patterns at the start of the project, it is inefficient to untrack files/folders later\n\nDo regular structured commits with helpful messages\n\n\n\n\n23.3.3 Sample structure\n\nproject root\n\n.git/\n.py-venv/\ndocs/\nsrc/\n\ninputs.py\ncategory_1_funcs.py\ncategory_2_funcs.py\n\nmain.py or app.py\npyproject.toml\npy-requirements.txt\nreadme.md\n.gitignore\n\n\nSince the main.py (or app.py) can directly call functions from directories beneath it, e.g. import src.category_1_funcs as &lt;category_1&gt; and use functions as &lt;category_1&gt;.&lt;function_name&gt;(), there is no need for using packages with __init__.py for very small projects.\nThe only drawback is you cannot cross reference objects from files across folders, unless they are in flat hierarchy below.\nFunctions can further be put into subdirectories."
  },
  {
    "objectID": "content/applications/app-overview.html#background",
    "href": "content/applications/app-overview.html#background",
    "title": "Overview",
    "section": "Background",
    "text": "Background\nThis section covers the How? part of the puzzle.\n\nWhy do you learn computer programming? \\(\\to\\) Use cases\nWhat is computer programming? \\(\\to\\) Theory: Building blocks, Architecture, Design\nHow do you do computer programming? \\(\\to\\) Practical experience: Tools, Application"
  },
  {
    "objectID": "content/applications/app-overview.html#objectives",
    "href": "content/applications/app-overview.html#objectives",
    "title": "Overview",
    "section": "Objectives",
    "text": "Objectives\nThe key aim is to provide exposure to\n\nApplication of theoretical concepts of specifications to solve practical problems\nPractice of writing programs\nIllustrate some common use cases"
  },
  {
    "objectID": "content/applications/app-overview.html#use-cases",
    "href": "content/applications/app-overview.html#use-cases",
    "title": "Overview",
    "section": "Use cases",
    "text": "Use cases\nIn context of use cases, some of the basic areas of day to day operations are covered through projects to demonstrate the following benefits\n\nAutomate repetitive manual tasks to\n\nincreases efficiency\nreduces errors\n\nCreate new solutions using programming, which standard tools do not offer"
  },
  {
    "objectID": "content/applications/app-overview.html#process",
    "href": "content/applications/app-overview.html#process",
    "title": "Overview",
    "section": "Process",
    "text": "Process\nAs a user of programming for basic applications, some of the key steps are\n\nFinding relevant existing solutions from standard library or PyPI\nUnderstanding\n\nhow they are structured\nwhat are the different ways they can be used\n\nIntegrating them with the building blocks and architecture of Python to solve simple tasks\nFor getting help on specific topic,\n\nrefer to the documentation\nsearch the web\n\ncurrently stackoverflow is a popular place for tech related QnA\n\n\n\nWorking with individual packages will serve as mini projects and which will be used in a major project.\nSolutions are not provided for all projects. There are very less projects and most of them are small. Rest of the material provides solved examples. Consider these to be open book exam where main objective is to apply the concepts without seeing solutions to seal the concepts.\nSome recommendations and reminders:\n\nRemember to refactor code\nDo not try to memorize everything, remember where to look for information. This is important because in programming there is a lot and it keeps changing at very fast pace compared to other areas."
  },
  {
    "objectID": "content/applications/automation.html#overview",
    "href": "content/applications/automation.html#overview",
    "title": "24  Automation",
    "section": "24.1 Overview",
    "text": "24.1 Overview\n\n24.1.1 Introduction\nProgramming languages, like Python, provide access to lower level system properties like file system and processes, through functions and classes. This leads to many opportunities to use these in multiple scenarios based on use case.\nThis is specially useful for situations where a certain task have to be repeated regularly. Doing it manually using applications with gui and mouse is slow and error-prone. Automation through programming not only makes the process faster and robust, but also provides opportunity to create new and custom solutions based on situation, which gui application might not be able to provide.\n\n\n24.1.2 Use cases\nBelow are some examples to illustrate the usage.\n\nProject templates: Consider a situation where certain folder structure needs to be created regularly with timestamps and some prefilled content and structure in certain files. There is significant part of the process that can be automated.\nSystem operations like creating backups.\nPdf operations like merging and splitting documents with custom index operations.\nand many more …"
  },
  {
    "objectID": "content/applications/automation.html#system-operations",
    "href": "content/applications/automation.html#system-operations",
    "title": "24  Automation",
    "section": "24.2 System Operations",
    "text": "24.2 System Operations\n\n24.2.1 Date time\nDate time is a data structure required for many tasks related to programming. Python standard library provides datetime module for this and related operations.\nIt is very common to use a needed data structure implemented through standard library and external packages in PyPI.\n\nDocumentation\n\nFormatting\n\n\n\n24.2.1.1 Exercise\nUsing Jupyter notebook\n\nread the system time\ncreate strings in following format\n\ndate stamp: “yyyy-mm-dd”\ndate-time stamp: “yyyy-mm-dd-h-m-s-ms”\ntime stamp: “h-m-s-ms”\n\nprint time stamps\n\nThis is useful when creating any types of logs. Date or time stamps need to be inserted in names for files and folders or even text content into files.\n\n\n\n24.2.2 Path manipulations\nPython standard library provides pathlib and os.path modules for path manipulations. For most of the operations pathlib should be enough. If a solution does not exist in pathlib, then os.path can be used.\n\n24.2.2.1 Mini project\nUsing Jupyter notebook\n\nStore source and destination paths in a variable\nCreate a function that\n\ntakes source path as input\nchecks if source path is\n\nempty: continue\nnon empty: prompt the user with message and confirm whether to continue\n\ncreates the below folder structure in the source path\n\n.logs\nsub_folder_1\n\nfile_1.py\n\nsub_folder_2\n\nfile_2.py\n\n.gitignore\npyproject.toml\n\n\nCreate a function that\n\ntakes source and destination paths as input\nchecks if the destination path is\n\nempty: continue\nnon empty: prompt the user with message and confirm whether to continue\n\ncopies the contents of source in destination without overwriting\n\nchecks if any file exists before copying\n\ncopies only if file in source is newer than in destination\n\nhint: os.path has getmtime (last modified), getctime (created), getatime (last access)\n\n\n\n\ncall the functions to test everything works\n\nNotes:\n\nBefore creating functions you can try small pieces to check how they work. This is typical of write-refactor cycles.\nThis is an example of how to\n\ncreate your own templates for creating boiler plate for repetitive projects and tasks\ndo basic file/folder operations like getting attributes and performing operations\n\n\n\n\n\n24.2.3 File read/write\nPython provides open as part of built-in functions to perform read/write operations on files.\nFor actual usage refer to the tutorial on Python i/o tutorial. Note the use of with statement which is an implementation of design pattern known as context managers.\nThere are multiple ways to write to file, as illustrated in the tutorial:\n\nwrite plain text to file\nwrite and read python objects through json or pickle package\n\nFor performing read/write operations on csv, excel and database formats:\n\nResources\n\nPython standard library: csv\npandas\n\nFor most basic stuff csv module is sufficient\n\n\n24.2.3.1 Mini-project\nIn the previous mini project, Section 24.2.2.1, add below functionalities using the work done in mini project, Section 24.2.1.1.\n\ncreate a current date time stamp\ncreate a file in the .logs folder with name as the current date time stamp\n\nopen the file and write details\n\nnumber of files copied\nnumber of files ignored\n\n\ncopy the file to destination path .log folder\nnote: creating and copying log file is dependent on order of placement in code, number of files will have to be adjusted for the new log file created. Plus care has to be taken to ensure copying the new log file to destination path.\n\n\n\n\n24.2.4 Creating CLI’s\nPython scripts can be invoked from shell with Python CLI, e.g. python -m &lt;name&gt;. To create system utilities, it easier to pass input arguments directly from CLI rather than opening and running script to edit the inputs and then run the script.\nFor this there are multiple options available in Python.\n\nBasic: sys.argv\nAdvanced: argparse package in standard library\n\ntutorial\ndetails\n\n\nargparse is recommended as it is simple to use but can be extended to advanced use cases.\nOnce the script can take arguments, an alias can be added in .bashrc or .bash_aliases to refer to the python script. e.g. alias cmd1=\"python3 -m ~/utils/cmd1.py\". Then cmd1 can be directly used from terminal like any other bash command, and inputs can be passed as well through cli.\nNote that these projects cannot use Jupyter notebooks.\n\n24.2.4.1 CLI Project - 1\nProject templates\nCreate a python package which can be called from CLI using arguments to create a project template for a certain regular task at a specified path.\n\nuse regular package for the project\nname can be for example &lt;create_data_analysis_template&gt;\nwhen called it will create a folder with certain predefined structure and files\n\nthe template structure can be stored within package folder and copied to any destination required\n\ninput arguments from CLI\n\ndestination: required, -d or --destination\nsource: optional, -s or --source\n\nif not provided use the default template folder path within package\n\nadd time stamp: -t or --timestamp, optional bool and defaults to true\n\nwhen true: add date time stamp to the destination path name\n\n\n\nTemplate folder can contain anything, actual files, folder structure and details will depend on the use case, but the design will be similar.\n\n\n24.2.4.2 CLI Project - 2\nMirroring Software\nCreate a mirroring software implemented as a python cli package with the below features. The idea is to keep a mirror of a folder in a different location.\n\nNote: This is a bigger project so can be done at relaxed pace, in 2 to 4 weeks.\n\n\ncli arguments\n\nsource: optional with default value, -s or --source\ndestination: optional with default value, -d or --destination\nverbosity: optional with default, -v or --verbosity with values from a list\ndry run flag: optional bool defaulting to false, -r or --dry-run\n\nmake 2 nested dictionaries for source and destination with below features\n\nfile path\nfile path if it exists in corresponding location else None\nmodified time for both source and destination if exists\nflags\n\nboth dictionaries: file present in corresponding location\nin source dictionary: modified time of source is greater than file in destination if present\n\n\noperations\n\nsource dictionary: file copied from source to destination if\n\nfile is not present in destination, create parent path as required\nmodified time in source is greater than in destination\n\ndestination dictionary: delete file from destination if it is not in source\n\ndelete the containing directory if the file is the last file"
  },
  {
    "objectID": "content/applications/automation.html#documentation",
    "href": "content/applications/automation.html#documentation",
    "title": "24  Automation",
    "section": "24.3 Documentation",
    "text": "24.3 Documentation\nAutomating documentation can be most rewarding in all setups. The recommended tool for this is Quarto which is recommended because of reasons mentioned below. It is difficult to find all these features together in any other option at this time (2023).\n\nEasy to use, seems intimidating but for simple usage it is as easy as writing in Word or Powerpoint\nA lot of options in terms of document export (html, pdf, latex, word, ppt, etc.)\nGood default aesthetics in output with minimal configuration\nGood isolation of aesthetics, structure and content\nSupport for table rendering is very advanced, using R packages like huxtable, kableExtra, GT\nCan be used for advanced usage\n\nCan include automated calculations, tables, figures\nCan include dynamic content in websites\n\n\nThis and many other websites and books are published using Quarto.\nSome other alternatives are listed below for completeness.\n\nAsciiDoc\nSphinx"
  },
  {
    "objectID": "content/applications/data-analysis.html#background",
    "href": "content/applications/data-analysis.html#background",
    "title": "25  Data Analysis",
    "section": "25.1 Background",
    "text": "25.1 Background\nData analysis skill is a necessity in current time independent of the domain. Even if you do not do it yourself, once you learn, it will help understand what are the possible options. It is a skill that can be applied in any professional or personal setup.\n\nFor all domains knowing basic data analysis using programming is essential.\nFor engineering and science domains the requirements are higher but the first step is the same.\nTherefore, learning to do basic data analysis using programming is a common subset.\n\nThe data science section tries to give a simple overview of everything related to data, which should help identify the common subset and how it fits in the broader context of data science.\nThe objective is to provide an overview and then point to resources for learning more. Data analysis in itself requires a separate course in itself which fits in overall learning path related to programming and its applications.\n\n25.1.1 Data Science\n\n25.1.1.1 Terminology\nSince the field of data is relatively new at this time and evolving very fast, the terminology is not consistent. The reasons for this rapid change are\n\nadvancement in computing capacities\nadvancement in storage capacities\nadvancement in scope of data collection\n\nBelow are some key terms with an attempt to define them.\nData science is the field of study which is dedicated to studying data, scientifically. This includes all aspects of the data cycle which includes several subjects related to each stage in cycle, which may require applying knowledge of several other supporting subjects like math, computer science (software and hardware), domain specific knowledge, process and operations, etc.\nData Analytics is the skill to apply advanced math techniques, like statistics, machine learning and artificial intelligence, to model data to do predictive and prescriptive analysis using data.\nData analysis is the skill to do basic static analysis using data which answers questions related to past and present. This involves very basic math.\n\n\n25.1.1.2 Data cycle\nData science is a new and very vast field with no consistent formalization of structure. The data cycle presented in this section will try to summarize and give an overview of different components of data science.\nAny project related to data, irrespective of scale or domain, has some core elements.\n\n\n\n\n\nAt small scale, one person might work on all elements. e.g. college projects requiring some analysis in which all stages can be performed using spreadsheets and programming.\nAt large scale, there might be multiple teams working on a single element. e.g. in a bank\n\nDesign: All teams involved contribute to discussions\nCollection: All customers and several departments have access to corresponding applications which feed data to bank’s database servers\nStorage & Processing:\n\nThere are multiple teams to perform validations and adjustments for loaded data coming in from different sources\nThere are separate teams for managing database servers\n\nAnalysis: There are multiple teams across multiple functions analyzing data\nReporting: There are multiple reporting teams\nDecision: Business teams\n\n\n25.1.1.2.1 Design\nDesign stage involves using knowledge of all the components, the target is to capture every aspect preemptively. For a large recurring project it might mean involvement of a large number of teams specialized in specific areas of the the data cycle.\nEvery data related project starts with designing decision stage, framing good questions that drive the project, but then it is an iterative process.\n\n\n\n\n25.1.1.2.2 Collection\n\nSpreadsheets\nWeb interface\nDesktop application\n\n\n\n \n\n\n25.1.1.2.3 Storage & Processing\n\nStorage: excel, text files, database\nProcessing\n\nExtract Transform Load (ETL) processes\npre processing\n\nresolving duplicates\nbad data values\nmissing data values\n\n\n\n\n\n\n\n25.1.1.2.4 Analysis\n\nLevels of analysis\n\nStatic: answers simple questions using historical data\n\nwhat has happened in the past?\nwhat is the current state?\nwhat is driving the current state?\n\nPredictive: answers more complex questions using math (probability and statistics)\n\nwhat would happen in future given a scenario?\nstatic models\n\nPrescriptive: answers more complex questions using math (probability and statistics)\n\npredict various scenarios\nanswer, what should be done to ensure desired results?\nstatic models, more advanced than predictive models\n\nMachine learning, Artificial intelligence: come up with models based on data\n\nmodels train themselves based on data\n\n\nOperational Process\n\nExtract\nClean\nAnalyze\nModel\n\nVisualization is part and key component of data analysis\n\n\n\n25.1.1.2.5 Communication\n\nComponents\n\ntables\nvisualization\ntheory: how you arrived at the results\nanalysis: key findings\nrecommendations\n\nTools: documentation using programming\n\n\n\n25.1.1.2.6 Decision\n\nCheck if results are satisfactory, if not re-design in next cycle\nIf there are new questions or findings, re-design in next cycle\n\n\n\n\n\n25.1.2 Learning paths\n\n25.1.2.1 Data analysis\nData analysis is generic and applicable to all domains. It requires to learn the basic usage of\n\nData storage technologies: spreadsheets, comma separated files, databases\nData analysis using programming\n\nimport data in to a data structure on heap (RAM)\noperate on data\nvisualization\ndocumentation of analysis and results\n\n\nSteps involved in data analysis using programming\n\nImport data from excel, csv or txt files, database\nClean data\nAnalyze data by performing operations and visualization\nDocument analysis and results\n\n\n\n25.1.2.2 Data analytics\nData analytics is relevant for science and engineering fields. Data analysis is a pre-requisite for this. Additionally it requires learning more about below topics for coming up with models for prediction, prescription or machine learning and artificial intelligence.\n\nMath: statistics, machine learning, neural networks, etc.\nAdvanced knowledge of technologies used, including programming"
  },
  {
    "objectID": "content/applications/data-analysis.html#data-analysis-in-python",
    "href": "content/applications/data-analysis.html#data-analysis-in-python",
    "title": "25  Data Analysis",
    "section": "25.2 Data analysis in Python",
    "text": "25.2 Data analysis in Python\nData analysis in python is mostly supported through pandas, which is one of the most popular packages on PyPI for data science.\nBelow are some resources to get started with data analysis using python.\n\npandas documentation\nPython4DS\nPython for Data Analysis, 3E\n\nNote that the resources are meant for the STEM audience so not everything will be in scope for generic audience. Still some initial chapters that focus on basic data analysis should be useful."
  }
]