---
title: "Introduction to Programming"
subtitle: "Using Python"
format: 
    beamer: 
        top-level-division: part
---

```{r}
#| include: false
source(here::here("resources/scripts/content/source-all.R"))
```


# Overview of programming

## Background

### Definition

- **Program** in context of computers
    - A set of instructions for the computer to follow
    - Also called software

- **Programming**: Configuring the computer hardware to do certain tasks to solve a problem.

### Hardware

#### Introduction

- Computers are based on binary arithmetic
- Comprise of a large number of electronic circuits
- Communicate with each other through electrical signals
- Understand different sequences of binary signals to perform different tasks
- 1 bit is the atomic unit of storage, 0 or 1
- Data and instructions are stored in binary
- Instructions are also binary data but "data" generally refers to static data

#### Components

#####

- **CPU**: central processing unit or processor
- **RAM**: random access memory
- **Hard drive**: long term storage
- **Input/output devices**: keyboard, mouse, monitor

##### 

- **CPU**: central processing unit or processor
    - **ALU** (Arithmetic logic unit): operates on very small amount of binary data to perform arithmetic and logical operations
    - **Controller unit**: controls the input/output signals from/to different parts of the computer
    - **Registers**: smallest memory, closest to processing
    - **Cache (L1, L2, L3)**: next level memory for preprocessing

#####

- **RAM**: random access memory
    - larger than CPU cache but smaller than hard disk
    - slower than CPU cache but faster than hard disk
    - all data slots are equally accessible in same time
- **Hard drive**: long term storage
    - largest in size but slowest
- **Input/output devices**: keyboard, mouse, monitor
    - also referred to as peripheral devices

#### Architecture

#####

![](../../../resources/diagrams/architecture/hardware-cpu-ram.png)

##### Key config parameters

2 main parameters related to design of instructions

- **Instruction set architecture (ISA)**
    - **x86-64**: Intel, AMD processors for desktop, server
    - **ARMv8-64**: Mobile phones
- **Width**: maximum number of bits the processor can process at a time
    - currently most CPU's support 64 bit, earlier it was 32 bit
    - the 64 in x86-64, ARMv8-64 is 64 bit width

### Programming hardware

#### Key idea

- **Map**: Natural language code $\to$ Machine code

- e.g. `beep` $\to$ `010011001010...`
## Programming languages

### Introduction

#### Basic idea

- **Map**: Natural language code $\to$ Machine code
    - e.g. `beep` $\to$ `010011001010...`
- Multiple ways to create the mapping
    - $\implies$ multiple programming languages

#### Programming language

##### Terminology

- Typically a programming language refers to 2 distinct parts
    - **Specification**
    - **Implementation**

##### Terminology

- **Specification**: rules for writing code
    - **lexicon**: allowed keywords, symbols, characters
    - **syntax**: rules of arranging lexicons and creating new names (variables)
    - **semantics**: rules to assign meaning to different combinations of lexicons and syntax

##### Terminology

- **Implementation**: A system application that implements the specification, like Compiler or Interpreter, to convert the natural language code into machine code and execute.
    - Referred to as '**language engine**' henceforth.

##### Language engines

- **Assembler**
- **Compiler**
- **Interpreter**

##### Python

- Python has many implementations
- The official is an hybrid interpreter written in C
    - Known as CPython
    - CPython = Specifications + Interpreter
    - Names are used inter changeably
- Other implementations: Jython (Java) etc.
    - Link available in notes for other [implementations](https://wiki.python.org/moin/PythonImplementations)

#### Types

- _low level languages_
    - **assembly languages**
- _high level languages_
    - **compiled languages** (_compiler_): C, C++, Go
    - **interpreted languages** (_interpreter_): shell (bash, etc.)
        - **hybrid**: Python, Java, JavaScript

##### Assembly

- Very few instructions
    - $\implies$ long code
- Usually one to one mapping of natural language short code and instruction
- The engine that converts the instructions is called the **Assembler**

##### High level languages

- Lot of specifications in natural language than assembly
    - $\implies$ lot more features
    - $\implies$ shorter code
- Types of high level languages
    - compiled: e.g. C, C++
    - interpreted: e.g. shell languages like Bash
        - hybrid: e.g. Python, Java

##### Compiled languages

- **Compiler**: reads the whole program and converts it to machine code
    - referred to as **Ahead of Time Compilation (AOT)**
- There are some dependencies for a compiler
    - **CPU architecture**
        - **instruction set**: x86, ARM, ...
        - **processing width**: 64 bit or 32 bit
    - **Operating system (OS)**
- Compilers resolve this for common CPU & OS combinations

###### Compiled languages {.smaller}

- **Pros**
    - **fast**
        - machine code is generated as standalone output
- **Cons**
    - **Portability**
        - have to be compiled for different OS + Hardware combinations
        - this is more of an inconvenience, as compilers for most popular combinations are available
    - **Difficulty**
        - compared to hybrid interpreter languages which are higher level with more features towards ease of use
        - have higher development time, takes more time to code

##### Interpreted languages

- **Interpreter**: reads the program line by line to produce the machine code during execution
- If interpreter can be installed it can run the program on any CPU-OS combination
- e.g. Bash

##### Hybrid languages

- The implementation of interpreter has evolved
- e.g. CPython
- The interpreter for these languages
    - **compilation step**: source code is checked and compiled into intermediate **bytecode**
    - **interpreter step**: the bytecode is interpreted into machine code and run at runtime

##### Hybrid languages with JIT

- Some languages have engine which is a hybrid interpreter with JIT
- JIT $\implies$ Just in time compilation
- JIT step stores optimized machine code for some parts of the program during runtime
- e.g. Java, C#, JavaScript

###### Pros and Cons for Hybrid languages {.smaller}

- **Pros**
    - **Portability**
        - same program can be run on different machines by just installing the language interpreter
    - **Ease of use**
        - generally these languages are higher than compiled languages than C, C++
        - time to write code is reduced
- **Cons**
    - **Slower**
        - program is converted to machine code at run time
        - this depends on the use case, specially considering the increase in hardware capacity, for most of common tasks this can be ignored

### Examples

#### Overview {.fragile .smaller}

```{r}
#| echo: false
#| output: asis
#| cache: false

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "languages" # name or number
package <- "hux"

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet=sheet)

tbl_out <- create_table(tbl_df, package = package, apply_theme = TRUE) |>
    huxtable::set_bold(col = 1, value = TRUE) |>
    huxtable::set_align(col = c(2:7), value = "center") |>
    huxtable::set_col_width(c(.2, rep(.8/6, 6))) |>
    huxtable::set_all_padding(1) |>
    huxtable::set_text_color(row = c(2:(nrow(tbl_df) + 1)),
        col = 1, value = "#2c6297")

print_tbl_out(tbl_out, package)
```

#### Desktop & Mobile applications {.fragile .smaller}

```{r}
#| echo: false
#| output: asis
#| cache: false

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "langs-app" # name or number
package <- "hux"

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet=sheet)
tbl_df <- tbl_df[1:4]

tbl_out <- create_table(tbl_df, package = package, apply_theme = TRUE) |>
    huxtable::set_bold(col = 1, value = TRUE)

print_tbl_out(tbl_out, package)
```

##### Framework

Framework = pre-written code for components of an application with means to combine them

#### Web {.fragile .smaller}

```{r}
#| echo: false
#| output: asis
#| cache: false

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "langs-web" # name or number
package <- "hux"

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet=sheet)

tbl_out <- create_table(tbl_df, package = package, apply_theme = TRUE) |>
    huxtable::set_bold(col = 1, value = TRUE)

print_tbl_out(tbl_out, package)
```

#### General purpose

##### C and C++ {.smaller}

- C and C++ are very popular compiled languages for writing high performance code.

- They provide access to most of the functionality hardware has to offer.

- Most of the critical applications like operating systems, compilers, virtual machines are written in C/C++.

- Steep learning curve

- C is the older among the two with lesser features available.

- C++ is a newer version of C with OOP, few changes in syntax and a lot more features.
    - C++ is under active development.

##### Python

- Python is a general purpose programming language.

- The official and most common version of Python that is used and covered in this course is implemented in C, and therefore also referred to as CPython.

- Python is very popular language with applicability in most of the application areas.

- It has a lot of pre built code available for majority of the regular tasks.

### Programming paradigms

#### Introduction

::: {.block data-latex="{}"}
A programming paradigm defines the approach or style of solving problems through programming.
:::

- Related to design and historical evolution programming languages

#### Overview

Programming paradigms are grouped into 2 main categories.

- **Imperative**: _focusses on how to solve the problem_
    - **Procedural programming**
    - **Object oriented programming**
    - **Structured programming**
- **Declarative**: _focusses on what to solve_
    - **Logic programming**
    - **Functional programming**
    - **Data driven programming**

#### Applications

- A language, through design of specifications and implementation, can support one or more of paradigms.

- Almost all popular programming languages support multiple paradigms and hence the term **multi-paradigm** is used.
    - e.g Python, C, C++, Java, Javascript etc.

- For example, in Python, a problem can be solved using loops, functional programming or OOP.
    - Python provides most of the options.
    - In the beginning avoid using OOP.

### General structure

#### Overview

- **Language specifications**
    - **Building blocks**: _specifications for elements and blocks of code_
    - **Architecture**: _specifications for writing programs_
        - means and specifications to combine elements and blocks to build programs
        - management of execution of blocks (under the hood)
- **Design**: _knowledge of how to write good programs_
- **Tools**: _needed to write, test, debug and run programs_

#### Detailed

#####

:::::: {.callout-note icon="false"}
#### Language specification

::::: {layout="[[-5,35,-5,55]]"}

::: {.callout-note icon="false"}
##### Building blocks

- [Basic specifications]{color="black"}
    - [Lexicons]{color="black"}
    - [Variables]{color="black"}
    - [Comments]{color="black"}
- [Data types and operations]{color="black"}
- [Control flow blocks]{color="black"}
- [Functions]{color="black"}
- [OOP]{color="black"}
- [Special features]{color="black"}
:::

::: {.callout-note icon="false"}
##### Architecture

- [Environment = Namespace + Scope]{color="black"}
- [Scripts and packages]{color="black"}
- [External packages]{color="black"}
- [Language engine]{color="black"}
- [Debugging]{color="black"}
:::
:::::
::::::

#####

:::::: {layout="[[-5,45,-5,45]]"}
::: {.callout-note icon="false"}
##### Design

- [Components]{color="black"}
    - [Design patterns]{color="black"}
        - [Map reduce]{color="black"}
    - [DSA]{color="black"}
    - [Regular expressions]{color="black"}
- [Frameworks]{color="black"}
- [Workflow]{color="black"}
:::

::: {.callout-note icon="false"}
##### Tools

- [Command line interface]{color="black"}
- [Version control system]{color="black"}
- [Language installation]{color="black"}
    - [Engine]{color="black"}
    - [External packages]{color="black"}
    - [Virtual environments]{color="black"}
- [Editor]{color="black"}
:::
::::::

#### Comments

- Almost all programming languages can be fitted to this generic structure/framework

- [Wiki link](https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(basic_instructions))

### Underlying Concepts

#### Overview

::: {.block .callout-note icon="false" data-latex="{}"}

- means of **abstraction**
    - building blueprints of data, operations, functionality, ...
- means of **encapsulation**
    - hiding details of implementation
- means of **combination**
    - using basic data structures to create compound data
    - combine basic functions to build bigger functionality
:::

#### Means of Abstraction

::: {.block data-latex="{}"}
Abstraction in general means to isolate ideas or concepts from actual physical reality.
:::

##### Programming language

::: {.block data-latex="{}"}
**Programming language** is itself built on this idea where abstract specification is isolated from actual implementation.

- For example C++ language specification is provided and maintained by a group of people.

- The actual implementation of the compiler can be done by anyone using those specifications.

- Therefore there are many C++ compilers available like [GCC](https://gcc.gnu.org/), [LLVM](https://llvm.org/) etc.
:::

##### Data types

::: {.block data-latex="{}"}
**Data types** have evolved by isolating the specification and implementation.

- Interfaces, or abstract data types (ADT), define general desired properties a certain data type should possess.

- Data structure with algorithms provide a concrete implementation for an interface.

- For example, dictionary is an ADT while Python `dict` is a data structure with algorithms for different operations.

- The performance of a dictionary in CPython might differ from a dictionary in C++ or even JPython (Implementation of Python VM using Java).
:::

##### Functional programming

::: {.block data-latex="{}"}
**Functional programming** uses this idea in many different ways.

- Example 1, map, filter and reduce are general concepts related to a collection of items, the actual output depends on the function supplied while using the concept.

- Example 2, factory functions provide a blueprint of functionality, the arguments supplied decide the actual function created.
:::

##### Object oriented programming (OOP)

::: {.block data-latex="{}"}
**Object oriented programming (OOP)** is built around this idea where class is an abstract blueprint of an object and instance is the actual object which depends on the data it holds.
:::

#### Means of Encapsulation

::: {.block data-latex="{}"}
Encapsulation in general means hiding the details of implementation.
:::

##### Programming language

::: {.block data-latex="{}"}
**Programming language**: hides the details of mapping problem, which is the actual implementation of the engine, and lets the programmer create new solutions using natural language, rules and syntax without worrying about details of implementation of compiler, hardware management etc.
:::

##### Data types

::: {.block data-latex="{}"}
**Data types**: Once a data type is implemented you can create multiple instances without worrying about the details of implementation.

- For e.g. most languages provide way of defining numbers and strings by directly entering them without worrying about implementation details of how and where to store the data.
:::

##### Functional programming

::: {.block data-latex="{}"}
**Functional programming**: Once a function is created you can use them as and when required without worrying about the implementation details during usage.
:::

##### Object oriented programming (OOP)

::: {.block data-latex="{}"}
**Object oriented programming (OOP)**: Classes provide a way to define blue prints of objects with certain attributes.

- After that multiple instances of the data type can be created and operated upon without worrying about the implementation details during usage.
:::

#### Means of Combination

::: {.block data-latex="{}"}
Combining in general means joining. In programming it means the same, ways to combine simple parts to make a more complex part and make it simple using encapsulation.
:::

##### Programming language

::: {.block data-latex="{}"}
**Programming language** is built around the same concept, smaller pieces are the elements of specification like lexicons and syntax, then semantics and architecture defines ways to combine them to make more complex programs.
:::

##### Data types

::: {.block data-latex="{}"}
**Data types**: Data structures like tuple, list, dictionaries etc. provide means of combining different data types to create arbitrarily larger and more complex data.
:::

##### Functional programming

::: {.block data-latex="{}"}
**Functional programming**: Using the rules of scopes and namespaces functions can be joined and nested in many interesting ways to create more complex functions.
:::

##### Object oriented programming (OOP)

::: {.block data-latex="{}"}
**Object oriented programming (OOP)**: Class itself allows combining data and operations to create arbitrarily large and complex data types as needed.

- Further more rules of inheritance provide ways of relating class definitions to create and structure even more complex data types.
:::

## Applications

### Embedded Devices

- Across industries more and more robotic devices are in use for automation of manual tasks.

- Most of this is done using assembly languages and C/C++ by embedding the final machine code in the robotic device itself.

### Operating Systems

- Major operating systems like Microsoft Windows, Apple Mac, Linux distributions are built with C/C++.

- Mobile devices have their own operating systems like Google's Android and Apple's IOS.
    - These are written in multiple languages but use C heavily.

- OS provides a default set of operations to interact with the hardware.

####

- There are several smaller applications to interact with components of hardware
    - input devices: keyboard, mouse, camera, microphone
    - output devices: display, speakers
    - network devices
    - hard disk: file system

- All the smaller applications are glued by the operating system and a graphical user interface is provided to interact with the hardware.

- This is done through desktop applications like file manager, text editor, photo viewer etc.

### CLI = Terminal + Shell

- Terminal is the first layer of interaction provided by the os.

- Terminal is a tui application which hosts a shell program.

- Shell program is an interpreter running the commands written in shell language.

- Terminal and shell programs are mostly written in C/C++ too.

- Terminal and shell together provide the command line interface or CLI.

### Desktop applications

- Examples of desktop applications are the file manager, media viewer etc.

- A desktop application is simply a program that can run on the os and provide means to perform certain tasks.

- Some are provided by the os as default applications while others like Adobe's Acrobat, Photoshop etc. are provided by companies.

####

- In addition individual developers and group of developers can provide desktop applications through Windows app store or Apple store. Linux distributions have their own app stores.

- Microsoft Office applications (word, excel, powerpoint, access database) are written in C/C++.

- [LibreOffice](https://www.libreoffice.org/discover/libreoffice/) is the free version of Microsoft Office which is developed using multiple languages like C++, Java, XML, Bash, SQL, etc.

### Databases

Databases are applications which specialize in storage, maintenance and operations on data. Most of them are built using C or C++.

#### {.fragile .smaller}

```{r}
#| echo: false
#| output: asis
#| cache: false

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "databases" # name or number
package <- "pander"

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet=sheet)

tbl_df <- tbl_df[c(1,3:5)]

tbl_out <- create_table(tbl_df, package = package, apply_theme = TRUE)

print_tbl_out(tbl_out, package)
```

### Websites

Web technologies have become popular with the creation and development of browsers and web networks.

- Front end (GUI) is based on HTML, CSS and JavaScript
- Backend functionalities: like databases, analytics can be developed in language of choice

In practice there are many frameworks available for development which provide standard templates of pre built code for different functionalities.

#### {.fragile}

```{r}
#| echo: false
#| output: asis
#| cache: false

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "langs-web" # name or number
package <- "pander"

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet=sheet)

tbl_out <- create_table(tbl_df, package = package, apply_theme = TRUE)
    # huxtable::set_bold(col = 1, value = TRUE)

print_tbl_out(tbl_out, package)
```

####

**How do browsers run code?**

Browsers are primarily running **JavaScript** using their own set of mapping engines.

Earlier the browser JavaScript engines were using interpreter approach but now have shifted to JIT approach like Java.

- Google Chrome: V8 engine
- Mozilla Firefox: SpiderMonkey
- Apple Safari: JavaScriptCore
- Microsoft Edge: Chakra

### Mobile Applications

- Mobile applications for Android and IOS are like desktop applications but designed to use limited resources of mobile.

- These are primarily oriented to use touch input.

- Google play and Apple store host applications developed by companies, individuals and group of developers.

### Data Analysis

- With the continuous increase in volume of data collected, data analysis & visualization, artificial intelligence, machine learning are getting developed and used heavily for analysis and decision making.

- Python and R are the languages used in this field as there is a lot of dependence on scientific computing, statistics and math.

- Basic data analysis is helpful for everyone using technology across all domains.

### Automation

#### Documentation

- There are tools like [Quarto](https://quarto.org/) available to automate documentation in multiple output formats.

- Quarto is based on [Pandoc](https://pandoc.org/) which is an application written in Haskell programming language for conversions between different markup languages.

- Quarto uses Pandoc's markdown syntax which makes writing documents as easy as writing text in a word processor or notepad.

- Content once written can be exported to different formats, html based website, pdf, word etc. This book has been written using Quarto.

#### System tasks

- Shell and Python scripts are used to automate a large number of system tasks both for personal and official work.

- Task can be as simple as creating a backup of your important files to more complex tasks to create templates of a project or task which you can create with automatic time and date stamps and other content pre-filled.

- This book therefore introduces system task automation later as an application of programming.


## Learning Map
### Introduction

####

Acquiring knowledge of any subject involves answering 3 fundamental questions.

- **Why**? _Most fundamental question that teaches the motivation_
- **What**? _Declarative knowledge that teaches the definition_
- **How**? _Imperative knowledge that teaches ways to apply the knowledge_

####

Similarly to learn computer programming you can use the below map.

- _**Why** do you learn computer programming?_ $\to$ **Use cases**
- _**What** is computer programming?_ $\to$ **Theory**: **Building blocks**, **Architecture**, **Design**
- _**How** do you do computer programming?_ $\to$ **Practical experience**: **Tools**, **Application**

####

- Learning theory equip you with knowledge about the subject
- **Skill** of **writing good programs** needs **practical experience** of **applying** _theory_ **using** _tools_

#### Career paths

- **Generic** $\iff$ **Basic**
- **STEM** (minus CSE) $\iff$ **Intermediate**
- **CSE** $\iff$ **Advanced**

_STEM $\implies$ Science, Technology, Engineering & Math_

_CSE $\implies$ Computer Science & Engineering_

### Basic

There are some common elements of programming which can be the starting point for all career paths.

- Introduction to programming with basic applications (this book)
- Basics of data analysis

#### Theory

#####

:::::: {.callout-note icon="false"}
#### Language specification

::::: {layout="[[-5,35,-5,55]]"}

::: {.callout-note icon="false"}
##### Building blocks

- [Basic specifications]{color="blue"}
    - [Lexicons]{color="blue"}
    - [Variables]{color="blue"}
    - [Comments]{color="blue"}
- [Data types and operations]{color="blue"}
- [Control flow blocks]{color="blue"}
- [Functions]{color="blue"}
- [OOP]{color="brown"}
- [Special features]{color="brown"}
:::

::: {.callout-note icon="false"}
##### Architecture

- [Environment = Namespace + Scope]{color="brown"}
- [Scripts and packages]{color="brown"}
- [External packages]{color="brown"}
- [Language engine]{color="brown"}
- [Debugging]{color="brown"}
:::
:::::
::::::

#####

:::::: {layout="[[-5,45,-5,45]]"}

::: {.callout-note icon="false"}
##### Design

- [Components]{color="black"}
    - [Design patterns]{color="black"}
        - [Map reduce]{color="brown"}
    - [DSA]{color="brown"}
    - [Regular expressions]{color="brown"}
- [Frameworks]{color="black"}
- [Workflow]{color="brown"}
:::

::: {.callout-note icon="false"}
##### Tools

- [Command line interface]{color="brown"}
- [Version control system]{color="brown"}
- [Language installation]{color="brown"}
    - [Engine]{color="brown"}
    - [External packages]{color="brown"}
    - [Virtual environments]{color="brown"}
- [Editor]{color="brown"}
:::
::::::

#### Applications

- Automation
    - system operations
    - documentation
- Basics of data analysis (including visualization)
- Domain specific basic applications

### Intermediate

- Theory
    - programming (intermediate level): design
    - data science (intermediate level)
    - math: probability & statistics to model data
- Application
    - data analytics
    - building domain specific packages
    - building basic applications using frameworks

### Advanced

####

In terms of theory there will be advanced coverage of topics depending on the choices.

- Math for computer science
- Language specification, implementation & design
- Data structures & Algorithms
- Design patterns
- Frameworks

####

In terms of application the path will depend on the choices.

- Embedded devices
- Operating systems
- Desktop applications
- Mobile applications
- Databases
- Websites
- Network applications
- Media
- ...

# Tools
## Overview
###### {.smaller}

- **Operating system**
  - **Command line interface** (**CLI**)
      - manage files
      - build and run files and projects
      - manage system installations and updates
  - **Version control system** (**VCS**): manage history of changes
  - **Python**:
      - **CPython installation**: interpreter, built-ins, standard library
      - **External packages**
  - **Editor**: compilation of tools needed in one place

######

![](../../../resources/diagrams/tools/tools-timeline.png)

## Command Line Interface (CLI)
### Overview

#### Terminology

#####

- There is a lot of ambiguity in terminology
- **Terminal** is an old term which refers to a physical interface to access the system
- **Console** and **TTY** are also used in similar context
- **Terminal emulator** is a generic term for an application to provide text input/output environment
- **Shell** is a generic term for an interpreter that provides commands to interact with the system
- **Command Line Interface (CLI)** = **Terminal Emulator** + **Shell**

##### {.c}

::: {layout="[[-1], [1], [-1]]"}
![](../../../resources/diagrams/tools/cli.png)
:::

#### Terminal Emulator

Every operating system gives a default and often is called **terminal**.

- **Linux**: default depends on the version
- **Windows**
  - **Windows Console Host**: old
  - **Windows Terminal**: latest
- **Mac**: has its own default terminal emulator referred to as terminal

#### Shell

*Shell* is the program, usually an interpreter, that runs inside a terminal emulator to give access to the system using text based commands.

- **Linux**: **bash**, zsh, fish, ...
- **Windows**: command prompt (cmd), powershell
- **Mac**: earlier it was bash, now it is zsh

##### bash

`bash` is the default shell on most linux based operating systems and is available across all operating systems.

- **Linux**: default on most distributions
- **Windows**: easily accessible through wsl, cygwin, git/gitbash
- **Mac**: earlier bash was default, latest is zsh, extension of bash

##### What do shell programs do?

Shell provides commands and scripts to manage system.

- Hardware (monitor, keyboard, mouse, network, camera, ...)
- Processes (logon, startup, users, security, ...)
- Applications (browser, file explorer, ...)
- File system (create/delete/rename/move files and folders)

##### Use cases {.smaller}

- Managing Workflow
    - Files and directory operations
    - Installation, update, maintenance of applications (software)
    - Automation
- System Administration
    - Files and directory operations
    - Installation, update, maintenance of applications (software)
    - Automation
    - Security: Group and user access
    - Managing databases, servers, processes

##### Note

:::::: {.callout-note icon="true"}
Most of the tasks that can be done from command line can be done with Python but understanding command line will help use Python better.
::::::

:::::: {.callout-warning icon="true"}
##### Caution

Command line can be dangerous as one wrong command can destroy a large chunk of your work or even bring the system down.
::::::

:::::: {.callout-important icon="true"}
##### Important
... and this happens more frequently with experienced users
::::::

### Bash

#### Resources

- [Homepage](https://www.gnu.org/software/bash/)
- [Bash manual](https://www.gnu.org/software/bash/manual/)

#### Setup

Installation depends on operating system.

- Linux distributions: `bash` is available and default on most distributions
- MacOS: `zsh` is the default but `bash` is available
- Windows: `git` comes with `gitbash` which should be enough
    - other options: [`msys2`](https://www.msys2.org/), [`cygwin`](https://www.cygwin.com/), [`wsl`](https://learn.microsoft.com/en-us/windows/wsl/install).

#### Configuration

##### What to configure?

Bash configurations involve

- **Environment**: What are the default variables like `$PATH`, `$HOME` etc. available
- **Prompt**: What information does the prompt show
- **History**: How and where history is saved
- **Aliases**: Short codes for frequently used commands

##### How to configure?

- Configuration files kept at prescribed locations containing configuration options
- `.bashrc`, `.bash_profile`, `.bash_aliases`
- Configuation and placement of files depends on operating system

#### Commands

##### General format {.smaller .shrink}

`<command name> [-flag[s]] [-option[s][=/ ]value[s]] [<argument[s]>]`

- **Command name**: are scripts containing code to perform tasks
    - e.g. `ls` prints files and folders contained in a folder
    - comes first
- **Flags (Switches)**: are short codes to alter the behavior of the program
    - multiple flags can be combined
    - it is safer to combine and provide all flags before any options and arguments
    - e.g. `ls -al` changes the way `ls` command lists the files and folders
        - note that `a` and `l` are 2 flags combined
        - `ls -a -l` works as well

###### {.smaller .shrink}

- **Options**: are codes that take value
    - e.g. `head -n=15 <file path>` prints starting 15 lines of the given file
    - options can use `=` or space, e.g. `head -n 15 <file path>` works
- The flags and options additionally have **long** and **short** forms. e.g.
    - `ls -l --all` $\iff$ `ls -al`
- **Arguments**: inputs to the command interpreted based on position
    - e.g. `cp <src> <dst>`: first argument is provided to source to be copied from and second to destination where to copy

###### Recommendations

- *Beginning* (after command name): combine **flags** using short forms
- *Middle*: **options**
- *End*: **arguments**

##### Types {.smaller}

- **built-ins**: present by default
    - `man`, `less`, `ls`, `cp`, `mv`, `mkdir`, `rm`, `find`, `grep`, ...

- **command line utilities**
    - many applications give command line utility commands
    - e.g. create a Python virtual environment
      - `python3 -m venv <path to virtual environment>`

- **custom scripts**: create your own
    - run using
        - `bash <custom_script_name>.sh`
        - `<custom_script_name>.sh` (needs permission config)

##### Summary

- help: `man`, `<cmd_name> --help`
- list and print: `ls`, `pwd`, `echo`, `| less`
- change directory: `cd`
- create file/directory: `touch`, `mkdir`
- remove file/directory: `rm`
- move/rename file/directory: `mv`
- search path using regex: `find`
- search content using regex: `grep`

##### Getting help

- search web by use-case
- within terminal: `man <command name>`
  - `man man`
  - **to sroll and search** `man man | less`
- on windows/git-bash `man` will not work
  - `<command name> --help`
- check installation location
  - `which <app name>`

##### List and Print

- list files and folders: `ls`
- list **all** files and folders: `ls -a`
- list **all** files and folders in **long format**: `ls -al`
- print current directory: `pwd`
- print to console: `echo "content"`

### File & Folder: Change directory

- change directory 1 level up: `cd ..`
  - change directory 2 level up: `cd ../..`

- `cd <relative dir path>`
- `cd <absolute dir path>`
- tab completion

### File & Folder: Create

- create file: `touch <file-path>`
  - directory should exist

- create directory: `mkdir <dir-path>`
- create directory and intermediate directories if does not exist:
  - `mkdir -p <dir-path>`

### File & Folder: Remove

- remove file: `rm <file path>`
- remove empty directory: `rm -r <dir path>`
- remove non-empty directory: `rm -rf <dir path>`

### File & Folder: Copy

- copy file:

  `cp <src file path> <dst file path>`

- copy source dir with its content recursively:

  `cp -r <src dir path> <dst dir path>`

- copy only contents of source dir to destination recursively:

  `cp -r <src dir path>/. <dst dir path>`

### File & Folder: Move (rename)

- move/rename: `mv <src> <dst>`
  - `src` = old file/directory name
  - `dst` = new file/directory name
  - if the `src` and `dst` path are
    - different => move
    - same => rename

#### Keyboard shortcuts

::::: {.columns}

:::: {.column width=49%}

::: {.callout-note icon="false" .fragment .highlight-current-red}
#### Main

- clear: `ctrl-l` (L)
- quit: `ctrl-d`
- copy: `ctrl-shift-c`
- paste: `ctrl-shift-v`
:::

::: {.callout-note icon="false"}
#### Delete

- delete till end (from cursor): `ctrl-k`
- delete till start (from cursor): `ctrl-u`
:::

::::

:::::: {.column width=2%}

::::::

:::: {.column width=49%}

::: {.callout-note icon="false"}
#### Movement

- move to start: `ctrl-a`
- move to end: `ctrl-e`

:::

::: {.callout-note icon="false"}
#### Processes

- cancel (kill) running jobs: `ctrl-c`
- put current process in background: `ctrl-z`

:::

::::
:::::

##### 

::: {.callout-note icon="false"}
#### History

- view history: `history`

- run command from history: `!<#>`

- put command from history: `!<#>:p`

- search previous command: `ctrl-r`

  - *keep pressing `ctrl-r` to go through search list*

:::


## Version control system: Git
### Introduction

#### Definition

::: {.block .div data-latex=""}
Version control system, aka **VCS** or **source control**, is a software to maintain history of changes to a project, in context of folders, files and content of files.
:::

#### Use cases

- **Track**: history of changes with related information
- **Rollback**: in case needed
- **Collaborate**: changes to different parts can be made in parallel and merged

#### Options

- **Git**
- **Apache Subversion**
- **Mercurial**

#### Objectives

- Basic usage of vcs without branching
- Introduce how basic things work without gui
    - Understand and use gui tools better
- There are few complex tasks that can only be done from cli, when needed

#### Resources

- [Pro Git](https://git-scm.com/book/en/v2)

#### Cloud Options

- **SourceForge**: supports multiple VCS
- **GitHub**: supports git only
- **GitLab**: supports git only
- **BitBucket**: supports multiple VCS

### Key ideas behind Git

#### Snapshots, not differences {.shrink .smaller}

![](../../../resources/images/git/deltas.png)

![](../../../resources/images/git/snapshots.png)

[Source: Pro Git](https://git-scm.com/book/en/v2)

#### 3 states {.shrink}

![](../../../resources/images/git/areas.png)

[Source: Pro Git](https://git-scm.com/book/en/v2)

#### Lifecycle

![](../../../resources/images/git/lifecycle.png)

[Source: Pro Git](https://git-scm.com/book/en/v2)

### Git CLI

#### Config

- Check Git config

```bash
git config --list --show-origin
```

- Setup username and email for Git
  - mandatory after fresh installation
  - these are stamped for each commit to track who made changes

```bash
git config --global user.name "name"
```

```bash
git config --global user.email "email@example.com"
```

#### Initialize repository

```bash
git init
```

- The above command is run from the folder to be version controlled.

- When a repository is initialized
    - `.git` folder is created which is the repository
    - All files and sub-folders are tracked by default
    - Add `.gitignore` to ignore tracking certain files and folders

#### Check status and logs

```bash
git status --short
```

```bash
git log --oneline
```

#### Add changes to staging area

```bash
git add <file or dir path>
```

#### Commit

##### Using text editor

```bash
git commit
```

- Opens the default text editor to enter message and commit the staged changes
    - in this case first line will be the short message
    - remaining typed lines will form the detailed message

##### Quick commit

```bash
git commit -m "message text"
```

##### Stage all changes and commit

```bash
git commit -am "message text"
```

- Stage all changes
- Commit the staged changes with short message
- In the -a option no need to add files separately

#### Check differences

##### Since last commit

```bash
git diff
```

#### Undo changes from last commit

```bash
git restore <file name>
```
- Discard changes to file in working directory

## Python
### Installation

#### Resources

- [Download installer](https://www.python.org/downloads/)
- Instructions
    - [Unix](https://docs.python.org/3/using/unix.html)
    - [Mac](https://docs.python.org/3/using/mac.html)
    - [Windows](https://docs.python.org/3/using/windows.html)

#### Components

- CPython interpreter
- Pre built Python scripts with additional functionality
    - Built-ins
    - Standard library

#### Check Python installation from bash

- Windows

```bash
py --list-paths
```

- Linux/Mac: there are several methods one of which is given below

```bash
ls -ls /usr/bin/python*
```

### Ways to run/interact with Python

- Repl
    - IPython repl: enhanced version of default Python repl
- Jupyter notebooks
- Run scripts from command line
- Run scripts from editor

### Python repl

*repl = read evaluate print loop*

####

- `repl` is a tool to interact with the interpreter.

- To start a `repl`
    - `python3`/`py`

####

- `repl` is rarely used directly, instead editors use it under the hood 
    - `repl` does not save work
    - not designed write large programs as it does not have all the tools needed
    - useful in conjunction with editor, to
        - test code short pieces of code
        - while debugging

#### 

- [IPython repl](https://ipython.org/) is newer modern repl
    - has to be installed separately
    - additional configuration is needed to use it from editor

### `pip`

#### Introduction

- [The Python Package Index (PyPI)](https://pypi.org/) is a repository of packages

- `pip` is one of the listed packages

- `pip` is the package installer for Python which manages the installation and maintenance of other external packages contributed by developers

- [`pip` website](https://pip.pypa.io/en/stable/)

#### Check installation

::: {layout-ncol="3"}

```bash
pip -V
```

```bash
pip -h
```

```bash
pip --help
```

:::

#### Installation

[Installation guide](https://pip.pypa.io/en/stable/installation/#ensurepip)

#### Usage

- Basic but not recommended, does not work as expected in edge cases

```bash
pip install jupyterlab
```

- For system Python installation

```bash
python3 -m pip install jupyterlab
```

- For use with virtual environments

```bash
<venv path>/bin/python3 -m pip install jupyterlab
```
## Jupyter Notebooks

### Overview

#### Introduction

Jupyter is an independent project that provides

- **Jupyter Notebooks**: interactive code cells, markdown text, tables, plots, latex math formulas
- **Jupyter Lab**: web-based interactive development environment (editor)
- **Jupyter Hub**: multi-user version of notebooks

Jupyter notebook is new version of interactive python notebook that have extension `.ipynb`, which is still used.

#### Objectives

- Get started with jupyter notebooks using jupyter lab
- Jupyter notebook is independent from jupyter lab
    - can be run from other editors which support jupyter notebooks
    - e.g. VSCode, RStudio, etc.

#### Resources

[Jupyter project's website](https://jupyter.org/)

### Installation

- Can be installed independently
- [Link to help page](https://jupyter.org/install).

```bash
<python installation path> -m pip install jupyterlab
```

### Features

- Run code interactively
- Mix rich text, code and results using markdown and code cells
- Export results in different formats like html, pdf, word etc.

### Use cases

- **Interactive programming** for quick trials or learning with annotation

- **Reproducible Research**: quick and easy sharing of ideas/analysis with code and results

### Keyboard Shortcuts

::::: {.columns}
::: {.column width=50%}
- add cell
  - below: `b`
  - above: `a`

- change cell type
  - markdown: `m`
  - code: `y`

:::
::: {.column width=50%}

- cut cell: `x`

- copy cell: `c`

- paste cell below: `p`

- enter/exit cell edit mode: `enter/esc`
:::
:::::

- run cell: `Ctrl + Enter`

- run cell and move to cell below: `Shift + Enter`

### Markdown

Markdown is a markup language which provides simple syntax for text to be converted to different formats.

- Tools for automating documentation use it
    - Quarto
    - Pandoc
    - GitHub
    - Jupyter notebooks

- Markdown syntax is easy and quick to learn

#### Syntax cheat sheet

```{r}
#| echo: false
#| output: asis
#| cache: false

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "md-part-1" # name or number
package <- "pander"

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet=sheet)
tbl_df_1 <- tbl_df[1:4,-3]
tbl_df_2 <- tbl_df[5:7,-3]
tbl_df_3 <- tbl_df[8:nrow(tbl_df),-3]
```

```{r}
#| echo: false
#| output: asis
#| cache: false

tbl_out <- create_table(tbl_df_1, package = package, set_hux_md = TRUE)

print_tbl_out(tbl_out, package)
```

##### 

```{r}
#| echo: false
#| output: asis
#| cache: false

tbl_out <- create_table(tbl_df_2, package = package, set_hux_md = TRUE)

print_tbl_out(tbl_out, package)
```

##### 

```{r}
#| echo: false
#| output: asis
#| cache: false

tbl_out <- create_table(tbl_df_3, package = package, set_hux_md = TRUE)
print_tbl_out(tbl_out, package)
```

## Editor
### Overview

#### Introduction

Editor combines most of the tools and functionality needed for programming in one interface. Therefore, it is the tool which is used most while programming.

#### Background

- Text editors
    - e.g. Emacs, Vim, Nano, Atom
- Integrated development environments (IDE)
    - Visual Studio, IntelliJ Idea
- Plugins or Extensions

#### Features {.shrink .smaller}

:::: {layout="[[-5,45,-5,45]]"}

::: {.callout-note icon="false" data-latex=""}
#### Common features

- User interface
    - themes
    - windows
    - frames
- Editing
    - tabs/spaces
    - folding
    - multiple cursors
    - keybindings
- Outline
    - project files
    - vcs
    - extensions
- Terminal
- Projects & Workspaces
- Version control
:::

::: {.callout-note icon="false" data-latex=""}
#### Language specific features

- Syntax highlighting
- Auto
    - completion
    - formatting
    - linting
    - refactoring
    - snippets
    - help/documentation
- Object browser
- Debugger
- Compile/build/run
- Testing
:::
::::

#### Options

##### Python Specific

- [PyCharm](https://www.jetbrains.com/pycharm/)
- [Spyder](https://www.spyder-ide.org/)
- [RStudio](https://posit.co/products/open-source/rstudio/)

##### Generic

###### Vim {.smaller}

- [Homepage](https://www.vim.org/)
- Plain text editor
- Steep learning curve
- Modal key bindings are powerful
- Useful for quick changes directly from terminal
- Extensions are available for additional functionality
- [NeoVim](https://neovim.io/) is based on Vim
    - advanced features
    - offers extensibility with Lua programming language
    - neorg, inspired by Emacs org mode, under development
- Faster than most other editors
- Works from cli

###### Emacs

- [Homepage](https://www.gnu.org/software/emacs/)
- Very powerful and hackable using `emacs lisp` language
- Steep learning curve
- [Spacemacs](https://develop.spacemacs.org/) (a modified distribution of Emacs) is a good blend of vim keybindings and emacs
- Extensions are available for additional functionality
- `org` mode system

###### VSCode

- Works out the box
- Easy to configure
- Easy to use
- Supports Jupyter notebooks
- Highly configurable
- Light weight
- Supports most of the languages
- Supports most of functionality required
- Extensions available for additional functionality

### Recommendation

- VSCode is recommended to begin programming with
    - ease of use in getting started

- Keybindings in VSCode can be configured
    - Vim keybindings are recommended
    - [VSpaceCode](https://vspacecode.github.io/docs/): Vim keybindings++

### Resources

- [VSCode docs](https://code.visualstudio.com/docs/)
    - [Setup](https://code.visualstudio.com/docs/setup/setup-overview)
        - [Keybindings](https://code.visualstudio.com/docs/getstarted/keybindings#_keymap-extensions)
    - [Introductory video series](https://code.visualstudio.com/docs/getstarted/introvideos)
    - [Python setup](https://code.visualstudio.com/docs/python/python-tutorial)
    - [Profiles](https://code.visualstudio.com/docs/editor/profiles)


# Building Blocks
## Overview

### Background

Learning a programming language starts with learning the specifications of elemenatary pieces or building blocks.

- **Language specifications**
    - [**Building blocks**: _specifications for elements and blocks of code_]{color="brown"}
    - **Architecture**: _specifications for writing programs_
        - means to combine elements and blocks to build programs
        - management of execution of blocks behind the scenes
- **Design**: _knowledge of how to write good programs_
- **Tools**: _needed to write, test, debug and run programs_

### Introduction

- _Basic specifications_
    - **Lexicons**: allowed symbol
    - **Variables**: mechanism of storing and re-using information
    - **Comments**: annotating code
- **Data types and operations**: storing and operating on numbers, strings, collections
- _Control flow blocks_
    - **Conditional exectution blocks**: `if-elif-else`, `match-case`
    - **Loops (Iteration)**: `for`, `while`
- **Functions**: re-use code with configurable inputs
- **Object Oriented Programming** (**OOP**): re-use predefined type of data and associated operations
- _Special features_: Python specific extra features
    - **Conditional expressions**: short-circuit, context aware evaluation
    - **Comprehensions**: special short syntax to combine `transformation iteration filter`

### Objectives

- Learn specifications (lexicons, syntax, semantics) for the building blocks
- Understand semantic specifications and their implications
    - do experiments in isolation
- Introduce basic examples of combining different building blocks
- Tools: Jupyter notebook in editor (VSCode or Jupyter lab)

### Basics


#### Objects

- In Python, everything is an **object** stored on RAM
- Can be looked up using object reference that is a memory address on RAM
- Object stores information in attributes
    - data attributes
    - operations (methods)
- **data = noun** and **operation = verb**
- **data = state** and **operation = behavior**

#### Variables

##### Introduction to variables

- Variables are named references that provide a handle to the object
- Namespaces are mapping between variable names and reference to objects
- Note that memory address is not constant

- Variables provide handle to objects for
    - reuse and passing around objects
    - performing operations

###### Name binding

- Variable are defined using the `=` operator.

- When a variable is defined for example
    - `some_var = "some text"`

- a string type object `"some text"` is created in RAM which has `some_id`
- `some_var` variable name is bound to `"some text"` object created
    - this is referred to as **name binding**
- variable name `some_var` is mapped to `some_id` in namespace

###### 

![](../../../resources/diagrams/data-types/var-obj-namespace.png)

##### Deciding variable names

###### Must-follow

- **case sensitive**
- **start** with `_` or `letter` (a-z A-Z)
- **followed by** any number of `_`, letters or digits
- **cannot** be one of **reserved words**

Below code can be used to check keyword list in Python.

```python
import keyword
print(keyword.kwlist)
```

###### Keywords {.fragile .shrink .smaller}

```{r}
#| echo: false
#| output: asis

library('reticulate')
kwp  <- reticulate::import('keyword')
kws <- kwp$kwlist
kws <- paste0("`", kws, "`")
l_kws = length(kws)
breaks <- seq.int(1, length(kws), 7)
cns <- paste0("x_", 1:7)
df <- setNames(data.frame(matrix(ncol = 7, nrow = 5)), cns) |>
  tibble::tibble()
for (i in 1:5) {
  for (j in 1:7) {
    df[i, j] <- kws[breaks[i] + j - 1]
  }
}
caption <- paste0("Python keywords (", l_kws, ")")
col_names <- rep("", ncol(df))
package <- "hux" # hux, pander, kable

create_table(df, caption = caption, package = package, col_names = col_names) |>
    huxtable::theme_grey() |> 
    print_tbl_out(package = package)
```

###### Should-follow

- `_my_var`: names starting with single underscore
  - used for `private` or `internal` objects

- **avoid using names with dunder**
    - `__my_var`: names starting with double underscore
    - `__my_var__`: names starting and ending in double underscore

###### PEP-8 Conventions

- [**PEP**](https://peps.python.org/pep-0000/#): Python enhancement proposals

- [**PEP-8**](https://peps.python.org/pep-0008/): Python code styles

###### PEP-8 Conventions {.fragile .shrink .smaller}

```{r}
#| output: asis
#| echo: false
#| cache: false

tables_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "pep-8-conventions"
package <- "pander" # hux, pander, kable

df <- readxl::read_excel(here::here(tables_file_path), sheet=sheet)

tbl <- create_table(df, package = package)

print_tbl_out(tbl, package)
```

##### Python features

###### Dynamic `type`

- In Python, variables are typed dynamically
    - variable `type` do not need to be declared
    - Variable can be bound to different type of objects

- Opposite is **strict type**, e.g. `C`

```{python}
some_var = 10
some_var = "some text string"
```

```{python}
print(f'{some_var=}')
```

###### `type` annotation

- Variable type can be declared for assistance and code readability
    - Optional

- It is not recommended to declare type and then use different type of object

- [PEP-487](https://peps.python.org/pep-0483/) has more detailed discussion around this

```{python}
some_var:str = "some text string"
some_var:int = 10
```

```{python}
print(f'{some_var=}')
```

###### Multiple assignment

To exchange values of a set of variables you do not need temporary assignments. Below examples illustrates this.

```{python}
a = 10; b = "some text"; c = ["this", "is", "a", "list"]
```

```{python}
print(f'{a=}, {b=}, {c=}')
```

```{python}
a, b, c = c, a, b
```

```{python}
print(f'{a=}, {b=}, {c=}')
```

#### Commonly used syntax

##### Comments (`#`)

Comments are text within code which is not evaluated and is used for documentation and code readability.

There are 2 basic rules related to comments.

- Python does not evaluate the content after `#` on a line

- cannot use `#` just after assignment operator `=`

###### Example 1

Below is simple usage to document the code.

```python
### Enter the value of inputs below
x = 10
y = 20

### Calculate sum
z = x + y
```

###### Example 2

```{python}
#| error: true
### num_in_comment = 10
print(num_in_comment)
```

###### Example 3

```{python}
#| error: true
some_num = # value on next line
10
print(some_num)
```

##### Newline

- New lines can be introduced in multiple ways
    - explicit method
        - break lines using `\`
        - join lines using `;`
    - implicit method: Expressions within `()`, `[]`, `{}`
        - can be broken into multiple lines
        - can contain comments
        - can have trailing commas
- New line syntax can be used to enhance code readability

###### Explicit method example

```python
some_var_1 = 10
some_var_2 = 20
some_var_3 = 30
some_var_4 = 40
if some_var_1 > 5 and some_var_2 > 10 and some_var_3 > 20 and some_var_4 > 30:
    print('yes')
```

```python
some_var_1 = 10; some_var_2 = 20
some_var_3 = 30; some_var_4 = 40

if some_var_1 > 5 and some_var_2 > 10 \
    and some_var_3 > 20 and some_var_4 > 30:
    print('yes')
```

###### Implicit method example

::: {layout-ncol="2"}

```python
a = (
    "item 1",
    "item 2",
    "item 3"
)
```

```python
a = [
    1, # first item
    2, # second item
    3, # third item
    ]
```
:::

##### Blocks (indentation)

- Python uses indentation to isolate distinct blocks
    - e.g. control flow blocks (`if`, `while`), functions (`def`), classes (`class`)
    - improves code readability

- `tab` vs `space` ([Editor configuration](https://code.visualstudio.com/docs/editor/codebasics#_indentation))

```python
import math
def calc_circle_area(r=1, pi=math.pi):
    if r < 0:
        print("radius should be >= 0")
    else:
        return pi*(r**2)
```

#### Functions

- Objectives
    - understand at high level what information the function provides
    - getting a hang of running code in jupyter notebooks
    - using variable assignment
    - functions and f-strings will be covered later in detail

##### type

- `type(_o)`: returns object type

```{python}
var_1 = 10
var_2 = 10.0
var_3 = "string"
```

```{python}
type(var_1), type(var_2), type(var_3), type(10.2)
```

##### id

- `id(_obj)`: returns object memory reference id
  - `hex(_number)` just converts a number to hexadecimal format for better readability

```{python}
_string_1 = "some text"
```

```{python}
id(_string_1), hex(id(_string_1))
```

##### is

- `a is b`: check if `a` and `b` refer to same object
- checks if memory addresses are same not just value

```{python}
a = b = [10]
```

```{python}
print(f'{a is b = }\n{hex(id(a))=}\n{hex(id(b))=}')
```

###### `is` examples

```{python}
a = [10]
b = a
```

```{python}
print(f'{a is b = }\n{hex(id(a))=}\n{hex(id(b))=}')
```

###### `is` examples

```{python}
c = [10]
d = [10]
```

```{python}
print(f'{c is d = }\n{hex(id(c))=}\n{hex(id(d))=}')
```

##### dot operator

- dot operator `.`
    - `.` operator gives access to object's data attributes and operations

```{python}
_num_1 = 1.5
```

```{python}
_num_1.as_integer_ratio()
```

## Data types

### Introduction

- Data types are the most critical part of any language
- They are used to **store**, **access** and **operate** on data (information)
- Numbers and text are the fundamentals
- Collections provide ways to combine data types: `tuple`, `list`, `set`, `dict`
- **Data Structures and Algorithms (DSA)** used to design data types and operations (methods)

##### Overview {.shrink}

![](../../../resources/mindmaps/python-dataobject-types.png)

::: {.notes}
- move to mind map
- do not try to remember all operations quickly
  - just refer whats needed, gradually it will stick
:::

##### Terminology

- **Collection** is generally used for collection of objects, and it can be compounded, collection of collection of objects.

- **Sequence type** is a collection of objects with preserved order. In base Python, strings, tuples and lists are sequence type.

- Sequences can be **mutable** or **immutable**.

- **Iterable** is any collection of objects from which objects can be retrieved one at a time and hence can be looped through. `str`, `tuple`, `list`, `dict`, `set` are all iterables.

- **Sequence** is a subset of **collections**. All sequences are iterables.

##### Objectives

- **Creation and syntax**
- **Operations**: understand how operations are **structured** across data types
- **Indexing** and **slicing** for sequence types
- **Implications**: understand the usage and implications using example use cases given
    - **Mutable** vs **Immutable** data types
- **Choosing data types**: understand **when to use which data type**

### None type

- `None` signifies absence of value
- used in 
  - conditionals
    - to avoid error when value is absent
  - function calls
- will be covered later

### Numeric types {.noframenumbering}

#### Numeric data types {.fragile .smaller}

```{r message=FALSE, warning=FALSE, eval=TRUE}
#| output: asis
#| echo: false

tables_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "num-dt-list"
df <- readxl::read_excel(here::here(tables_file_path), sheet=sheet)

package <- "pander"

create_table(df, package = package) |>
    print_tbl_out(package = package)
```

::: {.block  data-latex=""}
- numeric data types are **immutable**
- for basic calculations `int` and `float` are sufficient
  - others are listed for completeness
- **boolean** and **comparison operations** are discussed separately
:::

#### Operations on numeric data types {.fragile .smaller}

```{r message=FALSE, warning=FALSE, eval=TRUE}
#| output: asis
#| echo: false

tables_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "num-dt-ops-list"
df <- readxl::read_excel(here::here(tables_file_path), sheet = sheet)

package <- "pander"

create_table(df, package = package) |>
    print_tbl_out(package = package)
```

::: {.block  data-latex=""}
- using `division` always returns `float`
- when using `int` and `float`, `float` is returned
- Other operations
    - `round(x[, n])` is a builtin function provided
    - Standard library has more options for [numeric operations](https://docs.python.org/3/library/random.html#module-random)
        - [`math` module](https://docs.python.org/3/library/math.html#module-math), e.g. `math.floor(x)`, `math.ceil(x)`, `math.trunc(x)` etc.
        - [`random` module](https://docs.python.org/3/library/random.html#module-random) for pseudo random number generations

:::

###### Increment/Decrement

- `x += n` is same as `x = x + n`
- `x -= n` is same as `x = x - n`

- Extended syntax in Python
    - `x *= n` is same as `x = x * n`
    - `x /= n` is same as `x = x / n`
    - `x **= n` is same as `x = x ** n`

#### Examples


- basic example of assigning int and float

::: {.block data-latex=""}
```{python}
num1 = 10; num2 = 10.0
```
:::

::: {.block data-latex="{}"}
```{python}
print(f'{num1 = }, {type(num1) = }')
print(f'{num2 = }, {type(num2) = }')
```
:::

- if decimal is present then, even if number is integer, it is stored as float


- Operations with `int` and `float` return `float`.

::: {.block data-latex=""}
```{python}
num1 = .25; num2 = 100
num3 = num2 * num1
```
:::

::: {.block data-latex="{}"}
```{python}
print(f'{num1 = }, {type(num1) = }')
print(f'{num2 = }, {type(num2) = }')
print(f'{num3 = }, {type(num3) = }')
```
:::


- Objects of type `int` (-5 to 256) are not **duplicated**

::: {.block data-latex="{}"}
```{python}
some_int_1 = 10; some_int_2 = 10
```
:::

::: {.block data-latex="{}"}
```{python}
some_int_1 is some_int_2
```
:::


- Numeric data types are immutable

::: {.block data-latex="{}"}
```{python}
some_int = 10
print(hex(id(some_int)), f'{some_int=}')
```
:::

::: {.block data-latex="{}"}
```{python}
some_int += 1
print(hex(id(some_int)), f'{some_int=}')
```
:::

### String {.noframenumbering}

Collection > Sequence > Immutable

#### Overview {.smaller}

- `str` type object is an **immutable** **sequence** of unicode code points
    - generally: characters, numbers, symbols

- **sequence type**
  - like mathematics, order has meaning in sequences
    - `string` is not same as `trgins`
  - this helps enable support for **indexing** and **slicing**

- **immutable**
  - a **new object** is created in memory on modification
    - referred as **copy-on-modify**
  - adding/deleting/changing elements is not provided by default

#### Specifications {.noframenumbering}

##### Overview {.shrink .smaller}

- Strings can be created using
    - **single quotes**: `'some string'`
    - **double quotes**: `"some string"`
    - **multi-line** strings
        - **triple single quotes**: `'''some string'''`
        - **triple double quotes**: `"""some string"""`
    - **raw** strings just need a preceding `r` character for any method
        - `r"string with \"`, `r'string with \'`

- Special string types
  - **multiline strings**
  - **raw strings**
  - **formatted string literals**

- `print` changes the way results are displayed

##### Basic strings

::: {.block data-latex=""}
```{python}
#| eval: false
string_1 = 'using single quotes'
```
:::
::: {.block data-latex=""}
```{python}
#| eval: false
string_2 = "using double quotes"
```
:::
::: {.block data-latex=""}
```{python}
#| eval: false
string_3 = "including \"double quotes\" using double quotes"
```
:::
::: {.block data-latex=""}
```{python}
#| eval: false
string_4 = 'including "double quotes" using single quotes'
```
:::

##### Multiline strings {.shrink}

- **multiline strings** are created using triple quotes (single/double)

::: {.block data-latex=""}
```{python}
string_1 = """This is a multiline string
with no tabs using triple double quotes"""
string_2 = '''This is a multiline string
              with tabs using triple single quotes'''
```
:::

::: {.block data-latex="{}"}
```{python}
print(string_1)
```
:::

::: {.block data-latex="{}"}
```{python}
print(string_2)
```
:::

##### Using backslash (`\`) {.shrink}

- newline: `\n`
- tabs: `\t`
- escape quote symbol: `\'` or `\"`

::: {.block data-latex=""}
```{python}
string_1 = "Line 1\nLine 2"
string_2 = "text 1\ttext 2"
```
:::

::: {.block data-latex="{}"}
```{python}
string_1; print(string_1)
```
:::

::: {.block data-latex="{}"}
```{python}
string_2; print(string_2)
```
:::

> `print` changes the way results are displayed

##### Raw strings

- **raw strings** do not escape backslash (`\`)
  - prepend string with `r` character

::: {.block data-latex="{}"}
```{python}
#| error: true
string_1 = "C:\user\name"
```
:::

::: {.block data-latex=""}
```{python}
string_2 = r"C:\User\name"
```
:::

::: {.block data-latex="{}"}
```{python}
print(string_2)
```
:::

##### Formatted strings {.smaller}

- used for **mixing** **hard coded text** and **variable values with formatting**
- old syntax
  - `"text with {0[:fs]} and {1}".format(var1, var2)`
- new syntax (python version >= 3.6)
  - `f'text with {var1[:fs]} and {var2[:fs]}'`

> where `fs` to be read as format specifier

##### Formatted strings (old) example

::: {.block data-latex=""}
```{python}
user_name = "First Last"
user_age = 20
my_string = "Name: {0}\nAge: {1}".format(user_name, user_age)
```
:::
::: {.block data-latex="{}"}
```{python}
print(my_string)
```
:::

##### Formatted strings (old) example with format specifier

::: {.block data-latex=""}
```{python}
user_name = "First Last"
user_age = 20
user_balance = 1000001
my_string = "Name: {0:^30}\nAge: {1:^30}\nBalance: {2:>30,.2f}".format(\
  user_name, user_age, user_balance)
```
:::
::: {.block data-latex="{}"}
```{python}
print(my_string)
```
:::

##### Formatted strings (new) example

::: {.block data-latex=""}
```{python}
user_name = "First Last"
user_age = 20
user_balance = 1000001
my_string = f"Name: {user_name:^30}\nAge: {user_age:^30}\
    \nBalance: {user_balance:,.2f}"
```
:::
::: {.block data-latex="{}"}
```{python}
print(my_string)
```
:::

#### Operations

- **common operations on sequence types**
- **operations specific to strings**

##### Sequence {.smaller .shrink}

{{< include ../.common/_seq-ops.qmd >}}

###### Index & Slice

- Retrieve by position
    - Indexing: retrieving elements by position
    - Slicing: extracting subset of elements of a sequence

###### Index & Slice {.smaller .shrink}

![](../../../resources/diagrams/data-types/seq-idx.png){fig-align="center" height="25%"}

####### 

- Indexing starts at 0 and ends at n - 1
- Negative indices are allowed
- Usage
  - `s[i]`: return item at index `i`
  - `s[i:j]`: return items from index `i` to `j-1`
    - returns `j - i` items
  - `s[i:j:k]`: return items from index `i` to `j-1` with step `k`
    - `k=1` by default

###### Examples

```{python}
some_str = "abcdefgh"
```

Enumerate function is used to get pairs of index and elements of a sequence.

```{python}
#| output: asis

print([*enumerate(some_str)])
```

- select `c` to `f`

```{python}
some_str[2:6]
```

###### Examples

```{python}
some_str = "abcdefgh"
```

```{python}
#| output: asis

print([*enumerate(some_str)])
```

- select second last - `g`

```{python}
some_str[-2]
```

###### Examples

```{python}
some_str = "abcdefgh"
```

```{python}
#| output: asis

print([*enumerate(some_str)])
```

- select last 3 elements

```{python}
some_str[-3:]
```

###### Examples

```{python}
some_str = "abcdefgh"
```

```{python}
#| output: asis

print([*enumerate(some_str)])
```

- select `d` onwards

```{python}
some_str[3:]
```

###### Examples

```{python}
some_str = "abcdefgh"
```

```{python}
#| output: asis

print([*enumerate(some_str)])
```

- select up till `d`

```{python}
some_str[:4]
```

```{python}
some_str[:3] + some_str[3:]
```

##### String specific

- There are a lot of default operations ([link](https://docs.Python.org/3/library/stdtypes.html#string-methods))
    - case, find/replace, checks, strip, split, ...
    - usually easy to use, look at reference as needed

- regular expressions
  - searching and matching patterns in strings
  - depends on module `re` in standard library
  - advanced topic, avoid at this stage

##### Arithmetic Operators

The `+` and `*` operations can be used with strings, other operators will give error.

Note that operations work with compatible type of objects.

- `+`: concatenate strings
    - works with `str` type objects, i.e. strings
- `*`: repeat a string
    - works with a `str` and an `int`

###### Example 1

```{python}
some_str_1 = "some string 1"; some_str_2 = "some string 2"
concat_1_2 = some_str_1 + " " + some_str_2
print(concat_1_2)
```

###### Example 2

```{python}
some_str = "xyz"
print(some_str*5)
```

###### Example 3

```{python}
some_str_1 = "some string 1"; some_str_2 = "some string 2"
concat_1_2 = some_str_1 * some_str_2
```

### Tuple

#### Overview {.smaller .shrink}

Tuple is an **immutable** **collection** of **ordered**, **heterogeneous** objects with below features

- **sequence type** (collection of ordered objects)
  - this helps enable support for **indexing** and **slicing**
  - the position of data has meaning
  - useful in passing and operating on set of objects within code

- **heterogeneous**: *can contain any type of object*
  - more efficient if items are homogeneous

- **immutable**
  - modify **in-place** operations are not supported
    - a new object is created in memory on modification if elements are immutable
  - adding/deleting/changing elements is not provided by default

- [Python Tutorial: Gentle introduction to tuples](https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences)
- [Python library reference: Detailed documentation on sequences](https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range)

#### Specifications

##### Creation syntax

- using **commas**
  - comma decides the tuple
  - parenthesis are just for code readability
- using tuple **constructor**: `tuple()`
- using **unpacking** (Python special syntax)
- using **comprehension** (covered in Python special features)

##### Creation by use case {.smaller .shrink}

- using **elements**
  - *0 item*: `()` or `tuple()`
  - *1 item*: `i,` or `(i,)`
    - `(i)` will give error, comma is needed
  - *more than 1 item*: `i1, i2, i3` or `(i1, i2, i3)`

- using **elements from another iterable[s]**:
  - using tuple **constructor**: `tuple(iterable[s])`
  - using **unpacking**
    - `t = *l,`, `t = (*l,)`, `t = (*s, *l)`
    - `t = (*l)` will give error, comma is needed

#### Operations {.smaller .shrink}

Tuple has access to **common** operations on **sequence types** with no additional methods.

{{< include ../.common/_seq-ops.qmd >}}

### List

#### Overview {.smaller .shrink}

List is a **mutable** **collection** of **ordered**, **heterogeneous** objects with following features.

- **sequence type**
  - this helps enable support for **indexing** and **slicing**
  - the position of data has meaning
  - useful in passing and operating on set of objects within code

- **heterogeneous**: can contain any type of object
  - more efficient if items are homogeneous

- **mutable**
  - adding/deleting/changing elements is provided by default
  - modify **in-place** operations are supported

- Python Tutorial: Gentle introduction to list: [part 1](https://docs.python.org/3/tutorial/introduction.html#lists), [part 2](https://docs.python.org/3/tutorial/datastructures.html#more-on-lists)
- [Python library reference: Detailed documentation on sequences](https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range)

#### Specifications

- **empty** list: `[]` or `list()`
- using **elements**: `[i1, i2, ...]`, `[i1]`
- using **elements from iterable[s]**:
  - using list **constructor**: `list(iterable)`
  - using **unpacking**
    - `[*t]`, `[*t,]`, `[*s, *t, *l]`
  - using **comprehension** (covered in Python special features)

#### Operations

- **common** operations on **sequence types**
- operations on **mutable** sequence types

##### Sequence operations {.smaller .shrink}

{{< include ../.common/_seq-ops.qmd >}}

##### Mutable sequence operations

- most of the operations are in-place
  - implies no new object creation on modification

- **operations on sequence itself**
  - copy (shallow), extend, repeat, reverse

- **operations on items**
  - delete, replace, append, clear all, remove, insert, pop

- [link](https://docs.Python.org/3/library/stdtypes.html#mutable-sequence-types)

### Range {.smaller .shrink}

Range is a special **iterable** to **generate a sequence of integers** with following characteristics.

- **immutable sequence type**
- cannot see all elements at a time
  - have to be unpacked into a list or tuple
- syntax for creation
  - `range(stop)`
  - `range(start, stop[, step])`
    - **start** is **included**
    - **stop** is **excluded**
- primarily used for loops, discussed later

#### Examples

```{python}
print(range(10))
```

```{python}
print(list(range(10)))
```

```{python}
print([*range(11)])
```

```{python}
print([*range(1, 11)])
```

```{python}
print([*range(-1, -11)])
```

```{python}
print([*range(-1, -11, -1)])
```

### Dictionary

#### Overview {.smaller .shrink}

A dictionary is a **mutable** **mapping type** collection of **heterogeneous objects** **mapped** to **keys** that are **hashable** and **unique** objects.

- in newer versions (>3.9) the order is guaranteed

- collection of `{key: value}` pairs where
    - **key** can be any **hashable object**
        - **strings, numeric data types can be used**
        - immutable type which contain only immutable objects
        - tuples with immutable objects can be used
        - **lists, dictionary cannot be used**
    - **value** can be any **Python object**


A dictionary is useful when a collection of objects is needed with the option to do quick searches based on keys rather than index, unlike sequences.

- [Python Tutorial: Gentle introduction to dictionary](https://docs.python.org/3/tutorial/datastructures.html#dictionaries)
- [Python library reference: Detailed dictionary documentation](https://docs.python.org/3/library/stdtypes.html#mapping-types-dict)

- Concept of hashable objects is introduced in DSA

#### Specifications {.smaller .shrink}

- using key value pairs separated by commas
    - `d = {"key1": value1, "key2": value2, ...}`

- using type constructor
    - `d = dict([("key1", value1), ("key2", value2), ...])`
    - `d = dict(key1=value1, key2=value2)`

- create empty dictionary
    - `d = {}`
    - `d = dict()`

- using comprehensions (covered in Python special features)

- if a key is passed multiple times, final value exists

#### Operations

- operations on **dictionary itself**
- operations on **keys** and **values**

##### Operations on dictionary

- length: `len(d)`
- clear: `d.clear()`
- shallow copy: `d.copy()`
- update from another dictionary: `d.update([other])`

##### Operations on keys and values {.smaller .shrink}

- **check** [keys]{color="brown"}: `key in d` / `key not in d`
- **view all** [keys]{color="brown"}/[values]{color="blue"}: `d.keys()` / `d.values()` / `d.items()`
- **get all** [keys]{color="brown"}/[values]{color="blue"} as list of tuples: `list(enumerate(d))`
- **get all** [keys]{color="brown"} as list: `list(d)`
- **get all** [keys]{color="brown"} as list reversed: `list(reversed(d))`
- **get [value]{color="blue"}**, error if key not present: `d[key]`
- **set [value]{color="blue"}**, inserts key if key not present: `d[key] = value`
- **del [key]{color="brown"}/[value]{color="blue"}**, deletes last entry and returns deleted key, value: `d.popitem()`
- if key not present return default if defined else error
    - **get [value]{color="blue"}**: `d.get(key[, default])`
    - **del [key]{color="brown"}/[value]{color="blue"}** and return deleted value: `d.pop(key[, default])`

### Set {.smaller .shrink}

::: {.block data-latex="{}"}
Set is a collection of unique objects with operations related to math sets available, e.g. union, intersection. A special dictionary with keys only.
:::

::: {.block data-latex="{}"}
In Python specifically, set is an unordered collection of hashable objects. In newer versions (>3.9) the order is guaranteed.
:::

- [Python tutorial for sets](https://docs.python.org/3/tutorial/datastructures.html#sets)
- [Python documentation on set type](https://docs.Python.org/3/library/stdtypes.html#set-types-set-frozenset)

Sets are commonly used for

- membership testing: search by value
- removing duplicates from a collection

#### Specifications

A set can be created using curly braces with the exception of empty set.

- create a set with valid keys
    - curly braces
    - `set` constructor

```python
some_set = {key1, key2, ...}
some_set = set(iterable)
```

- empty set can be created using `set()` constructor
    - using `{}` creates an empty dictionary

### Boolean data type

#### Overview

- Boolean data type, `True` and `False`, is the fundamental unit for implementing boolean conditional expressions

- Boolean **comparison operator** are used to create elementary conditions

- **Combination operators** allow for building larger conditions by combining multiple conditions

- Conditional control flow blocks, `if` and `match`, use conditions

- There are some additional features which Python provides
    - covered later in Python special features

#### Specifications {.smaller .shrink}

- `bool` in Python, based on usage, can refer to
    - data type
    - function
- `bool` type is used to represent `boolean values`
- `bool` type inherits from `int` type
- `bool` data type can take value from 2 built-in constants, `True` and `False`
  - underlying `int` values are `int(True) = 1` and `int(False) = 0` respectively
- *can be stored in variables like other objects*
  - *useful in conditional blocks*

#### Examples {.smaller .shrink}

- basics

```{python}
bool(True), int(True), type(True)
bool(False), int(False), type(False)
```

- storing in variables
  - it is useful to name boolean variables like `is_<some check>`

```{python}
#| results: 'hold'

is_int = True
is_int, bool(is_int), int(is_int), type(is_int)
```

#### Boolean comparison operators

##### Overview {.smaller .shrink}

::: {.block data-latex="{}"}
Boolean comparison operators

- used for **object comparisons**, e.g. equality testing
- return `True` or `False`, if used with **compatible** object types
- used to create boolean **conditions** which are used in conditional blocks, `if` and `match..case`
:::

::: {.block data-latex="{}"}
When used with sequence types (string, tuple, list)

- equality operators (`==`, `!=`) return `True` if all elements are equal (not equal) in content
- inequality operators only test minimum and maximum as appropriate
- membership testing check for existence of elements and is most useful
:::

##### Options and syntax {.fragile .smaller .shrink}

```{r}
#| output: asis
#| echo: false

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "bool-ops" # name or number
package <- "hux" # hux, pander, kable

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet=sheet)

tbl_df <- tbl_df[tbl_df$Type == "Comparison",][-c(1, 5)]

tbl_out <- create_table(tbl_df, package=package) |>
    huxtable::theme_article() |>
    huxtable::set_col_width(c(.3, .25, .4))

print_tbl_out(tbl_out, package)
```

##### Examples

###### Numeric

```{python}
num_1 = 10; num_2 = 15; num_3 = 10.0
```

```{python}
num_1 == num_2, num_1 < num_2, num_1 <= num_3
```

- can be stored in variables
```{python}
cnd = num_1 > num_3
```

```{python}
print(f"{cnd = }, {type(cnd) = }")
```

###### Sequence type

> Membership testing is more useful for sequence types

###### Strings

- test character in a string

```{python}
some_string = "abcd"
some_chr_1 = "a"
some_chr_2 = "e"
```

```{python}
some_chr_1 in some_string
```

```{python}
some_chr_2 in some_string
```


###### Small string in a longer string

```{python}
some_long_str = "A reasonably long string"
some_short_str = "long"
```

```{python}
some_short_str in some_long_str
```

###### Tuples and lists {.shrink}

```{python}
some_list = [1, 2, 3, 4, (1, 2, 3)]
some_tuple = 1, 2, 3
num_1 = 3; num_2 = 5
```

```{python}
num_1 in some_list
```

```{python}
some_tuple in some_list
```

```{python}
num_2 in some_tuple
```

- store a boolean operation in a variable

```{python}
cnd = some_tuple in some_list
```

```{python}
#| echo: false
print(f'{cnd = }, {type(cnd) = }')
```

###### None type

- Single instance of `None` type object created in a Python session
- `None` is used to signify if a variable is defined but not assigned a value yet

```{python}
some_var = None
some_var is None
```

#### Boolean combination operators

> Boolean combination operators use boolean math to provide means of combining multiple comparison operations and conditions to form larger conditions.

##### Overview {.fragile .smaller .shrink}

```{r}
#| output: asis
#| echo: false

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "bool-ops" # name or number
package <- "hux" # hux, pander, kable

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet=sheet)

tbl_df <- tbl_df[tbl_df$Type == "Combination",][-c(1, 5)]

tbl_out <- create_table(tbl_df, package) |>
    huxtable::theme_article() |>
    huxtable::set_col_width(c(.1, .4, .5))

print_tbl_out(tbl_out, package)
```

##### Specifications {.smaller .shrink}

- **basic examples** of combining conditions
  - `a == 10`
  - `a >= 5 and a <= 10`
  - `(a > 0 and a < 10) or (a >= 10 and a < 25)`

- **order of precedence** used for evaluation
    1. `()`
    2. comparison operators have same priority (`==`, `!=`, `<`, `>`, `<=`, `>=`)
    3. `not` > `and` > `or`

- **chained comparisons**
    - are automatically converted to paired `and` comparisons
    - example: `a < b < c` is same as `a < b and b < c`
    - this is specific to Python


- for conditions with too many nested combinations
  it is recommended to use `()`
    - best for code readability
    - avoid errors due to precedence order

- *can be stored in variables like other objects*
    - and used later in control flow

###### Truth tables {.fragile .smaller .shrink}

```{r}
#| echo: false
#| results: 'asis'

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "bool-tbl" # name or number
package <- "hux" # hux, pander, kable

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet=sheet)

tbl_df <- tbl_df[c(1,2,3,5)]

tbl_out <- create_table(tbl_df, package = package) |>
    huxtable::theme_article() |>
    huxtable::set_align("center") |>
    huxtable::set_width(1) |>
    huxtable::set_col_width(.25)

print_tbl_out(tbl_out, package)
```

### Generic concepts

#### Iterable unpacking {.smaller .shrink}

- Special feature in newer versions of Python
    - introduced in Python 2
    - [PEP-3132: Extended Iterable Unpacking](https://peps.python.org/pep-3132/) in Python 3

- `*` unpacks remaining items
- returns a list
- advantages
    - **better code readability**
    - **easier** than using indexing
    - **faster**
- gives **error** if there is a **mismatch** in number of items and variables

##### Examples

###### 

- Unpack and assign elements of an iterable to variables
    - get first and remaining items of an iterable

```{python}
some_list = [1, 2, 3, 4]; some_tuple = (1, 2, 3, 4)
```

```{python}
first_item = some_list[0]
end_items = some_list[1:]
```

```{python}
print(f'{first_item = }, {end_items = }')
```

```{python}
first_item, *end_items = some_list
```

```{python}
print(f'{first_item = }, {end_items = }')
```

###### 

- Unpack and assign elements of an iterable to variables
    - get last and remaining items of an iterable

```{python}
some_list = [1, 2, 3, 4]; some_tuple = (1, 2, 3, 4)
```

```{python}
begin_items = some_tuple[0:-1]
last_item = some_tuple[-1]
```

```{python}
print(f'{begin_items = }, {last_item = }')
```

```{python}
*begin_items, last_item = some_tuple
```

```{python}
print(f'{begin_items = }, {last_item = }')
```

######

- Unpack and assign elements of an iterable to variables
    - get first two, last and remaining middle items of an iterable

```{python}
some_list = [1, 2, 3, 4, 5, 6, 7]; some_tuple = (1, 2, 3, 4, 5, 6, 7)
```

```{python}
first_item, second_item, *remaining_items, last_item = some_tuple
```

```{python}
print(f'{first_item = }, {second_item = }')
print(f'{remaining_items = }, {last_item = }')
```

###### Combine iterables into another

```{python}
some_list_1 = [1, 2, 3]; some_tuple_1 = (4, 5);
some_tuple_2 = (*some_list_1, *some_tuple_1)
```

```{python}
#| echo: false
print(f'{some_tuple_2=}')
```

###### `**` for dictionary

```{python}
some_dict_1 = {"key1": "value1", "key2": "value2.1"}
some_dict_2 = {"key2": "value2.2", "key3": "value3"}
some_dict_3 = {**some_dict_1, **some_dict_2}
```

```{python}
#| echo: false
print(f'{some_dict_3=}')
```

#### Implications of mutability

##### Background {.smaller .shrink}

- **Modify in-place**: any modification to the object does not lead to creation of a new object

- **Copy on modify**: create a new copy of object if modified, opposite of modify in-place

- **Mutable** $\implies$ **modify in-place**
    - Lists and dictionaries can be modified without creation of new object on RAM

- **Immutable** $\implies$ **copy on modify**
    - Strings and tuples create new objects on RAM if modified

###### 

- Implications
    - **flexibility**
    - **efficiency** (in terms of speed and memory)

- **Immutable** objects (strings, tuples) are
  - **efficient** for **constant data**
  - **less flexible**

- **Mutable** objects (lists, dictionaries) are
  - **less efficient** for **constant data**
  - **flexible**, support in-place modification
  - ***can be more efficient if data keeps changing over time***

##### Changing elements

###### Immutable types - strings, tuples

```{python}
#| error: true
some_string = "abcdee"
some_string[-1] = "f"
```

```{python}
#| error: true
some_tuple = (0, 1, 1)
some_tuple[2] = 2
```

###### Mutable types - lists, dictionaries

```{python}
some_list = [0, 1, 5]
some_list[2] = 2
print(some_list)
```

Strings have internal methods that can change elements, but then they follow copy-on-modify.

```{python}
some_string_1 = "abc"
some_string_2 = some_string_1.replace("a", "b")
```

```{python}
print(f'{some_string_1=}, {some_string_2=}\n\
    {some_string_1 is some_string_2 = }')
```

###### 

```{python}
some_string = "abc"; some_string_orig_id = hex(id(some_string))
```

```{python}
#| echo: false
print(f'{some_string=}, {some_string_orig_id = }')
```

```{python}
#| echo: false
print(f'{hex(id(some_string.replace("a", "b"))) = }')
```

```{python}
#| echo: false
print(f'{some_string=}, {some_string_orig_id = }')
```

```{python}
some_string = some_string.replace("a", "b")
```

```{python}
#| echo: false
print(f'{some_string=}\n{hex(id(some_string)) = }\n{some_string_orig_id = }')
```

##### Propagation of changes

Mutable types like lists or dictionaries, when passed around through variable assignment, changes are propagated.

- when you make changes to original list they propagate
  - this is required in many cases
  - but can also lead to a bug
  - *be aware of the concept*

- to *avoid default behavior* when needed use
  - **constructor** `list(iterable)`
  - **unpacking** `[*iterable]`
  - **loops**

```{python}
some_list_1 = [1, 2, "a", "b"]
some_list_2 = some_list_1
```

```{python}
print(f'{some_list_1=}, {some_list_2=}\n{some_list_2 is some_list_1 = }')
```

```{python}
some_list_1[2] = "abc"
```

```{python}
print(f'{some_list_1=}, {some_list_2=}\n{some_list_2 is some_list_1 = }')
```

```{python}
some_list_2[-1] = "xyz"
```

```{python}
print(f'{some_list_1=}, {some_list_2=}\n{some_list_2 is some_list_1 = }')
```

- using constructor or unpacking does not pass the object itself

```{python}
some_list_1 = [1, 2, "a", "b"]
some_list_2 = list(some_list_1)
```

```{python}
#| echo: false
print(f'{some_list_1=}, {some_list_2=}\n{some_list_2 is some_list_1 = }')
```

```{python}
some_list_1[2] = "abc"
```

```{python}
#| echo: false
print(f'{some_list_1=}, {some_list_2=}\n{some_list_2 is some_list_1 = }')
```

- using constructor or unpacking does not pass the object itself

```{python}
some_list_1 = [1, 2, "a", "b"]
some_list_2 = [*some_list_1]
```

```{python}
print(f'{some_list_1=}, {some_list_2=}\n{some_list_2 is some_list_1 = }')
```

```{python}
some_list_1[2] = "abc"
```

```{python}
print(f'{some_list_1=}, {some_list_2=}\n{some_list_2 is some_list_1 = }')
```

##### Mutable in immutable {.shrink}

- `tuple` is immutable in terms of its element objects

- the contained object remains mutable if it is mutable

```{python}
some_list = [1, 2, 3, 4, 5]
some_tuple = (some_list, "some other object")
```

```{python}
print(f'{some_list=}\n{some_tuple=}\n{some_list is some_tuple[0] = }')
```

```{python}
some_list.pop()
```

```{python}
print(f'{some_list=}\n{some_tuple=}\n{some_list is some_tuple[0] = }')
```

###### 

- if only contents are needed and propagation is to be avoided use **unpacking** or **constructor**

```{python}
some_list = [1, 2, 3, 4, 5]
some_tuple_1 = *some_list,; some_tuple_2 = tuple(some_list)
```

```{python}
print(f'{some_list=}\n{some_tuple_1=}\n{some_tuple_2=}')
print(f'{some_list is some_tuple_1 = }')
print(f'{some_list is some_tuple_2 = }')
```

######

```{python}
some_list.pop()
```

```{python}
print(f'{some_list=}\n{some_tuple_1=}\n{some_tuple_2=}')
print(f'{some_list is some_tuple_1 = }')
print(f'{some_list is some_tuple_2 = }')
```

##### Shallow vs deep copy

- **Shallow copy**: creates a new object for the collection not elements
    - Default copy method available with collections (string, tuple, list, dictionary)

- **Issue**: if elements in nested collection is mutable

- **Solution**: The standard library has `copy` module which has `deepcopy`

- **Deep copy**: create new objects for collection and its elements recursively

###### Example {.shrink}

```{python}
import copy
some_list = [1,2,3]; some_tuple = (4, 5); some_dict = {"six": 6, "seven": 7}
some_list_1 = [some_list, some_tuple, some_dict]
some_list_2 = some_list_1.copy()
some_list_3 = copy.copy(some_list_1)
some_list_4 = copy.deepcopy(some_list_1)
```

```{python}
#| echo: false
print(f'{some_list_2 is some_list_1 = }')
print(f'{some_list_3 is some_list_1 = }')
print(f'{some_list_4 is some_list_1 = }')
print(f'{some_list_2[0] is some_list_1[0] = }')
print(f'{some_list_3[0] is some_list_1[0] = }')
print(f'{some_list_4[0] is some_list_1[0] = }')
```

## Control Flow

### Introduction

#### Overview {.smaller}

_**When do you need to control the flow of a program?**_

- *change outcome based on state of object[s] (condition[s])*
  - **conditional blocks**: `if...[elif]....[else]`, `match...case`
- *repeat certain task[s] or iterate through a collection of data*
  - **loops**: `for...[else]`, `while...[else]` blocks
- *avoid stopping of program on errors and handle the flow differently*
  - **error handlers**: `try...[except]...[else]...[finally]` blocks
- *remove dependency on certain tasks*
  - **asyncio** (asynchronous input output)
- *increase efficiency by optimizing redirection of tasks to multiple cpu cores/threads*
  - **parallel computing**, ...

> Note: square brackets are generally used to represent something optional

#### Objectives

For all of the control flow techniques, **conditionals**, **loops** and **error handlers**

- get acquainted to specifications
- understand the rules and few implications conceptually
- examples of common use cases
- understand conceptually when to use what
- experiment with individual pieces

### Conditional blocks

#### Overview {.smaller}

::: {.block  data-latex="{}"}
Conditional blocks use conditions to control and change the flow of a program. Conditions are created using boolean operations.
:::

::: {.block data-latex="{}"}
- `if...[elif]...[elif]...[else]` blocks
    - covers everything needed from basic conditional blocks
:::

::: {.block data-latex="{}"}
- `match...case...[case_]` blocks
    - special case where a variable has to be tested for different values
    - in most cases can be implemented using `if` block
    - better for code readability
    - has some additional special features related to pattern matching
:::

#### `if` blocks

`if` blocks are used to execute some code only when a condition is evaluated to `True`.

##### Specifications

Below are possible forms of `if` block.

::::: {.columns}
:::: {.column width=49%}

```python
if condition:
    # if block content
```

```python
if condition:
    # if block content
else:
    # else block content
```
::::

:::::: {.column width=2%}
::::::

:::: {.column width=49%}

```python
if condition_1:
    # if block content
elif condition_2:
    # elif block 1 content
elif condition_3:
    # elif block 2 content
else:
    # else block content
```
::::
:::::

```python
### execute some short expression conditionally
if condition: <short expression>
```

###### {.shrink .smaller}

```python
if condition_1:
    # if block content
elif condition_2:
    # elif block 1 content
elif condition_3:
    # elif block 2 content
else:
    # else block content
```

- start an `if` block
    - `if` statement with an expression ending in colon (`:`)
- end an `if` block
    - short expression on the same line
    - **indented** block of one or more lines of code
- there can be 0 or more `elif` (else if) blocks
- there can be 0 or 1 `else` block
- syntax of `elif` and `else` is same as `if`

###### Ternary operator

```python
X if condition else Y
```

```{python}
print("condition True") if 1 > 0 else print("condition False")
```

```{python}
print("condition True") if 1 == 0 else print("condition False")
```

##### Control flow

###### {.smaller}

:::: {layout="[[55,-5,40]]"}
![](../../../resources/diagrams/control-flow/if-flow.png)

::: {.block data-latex="{}"}
- check conditions sequentially
    - if any is `True`
        - execute the corresponding block content and exit
    - if all are `False`
        - execute `else` block if present
        - exit
:::
::::

##### Examples

###### Basic

```{python}
some_num = 12
if some_num >= 0:
    print(f'{some_num} is positive')
```

###### With `else` block

```{python}
some_num = 12
if some_num >= 0:
    print(f'{some_num} is positive')
else:
    print(f'{some_num} is negative')
```

###### With `elif` block

```{python}
some_num = 12
if some_num == 0:
    print(f'{some_num} is zero')
elif some_num > 0:
    print(f'{some_num} is positive')
elif some_num < 0:
    print(f'{some_num} is negative')
```

###### With `elif` and `else`

```{python}
some_num = 12
if some_num == 0:
    print(f'{some_num} is zero')
elif some_num > 0:
    print(f'{some_num} is positive')
else:
    print(f'{some_num} is negative')
```

#### `match...case` block

##### Overview

Match blocks are used if some object is to be tested against multiple cases.

It can be achieved using `if` blocks but `match` blocks are better for code readability and ease of use for the given use case.

`_` is optional and for case when none of the options match.

##### Specifications

::::::::: {layout="[[40,-10,40]]"}

```python
match some_obj:
    case option_1:
        # do something and exit
    case option_2:
        # do something and exit
    [case _:
        # do something and exit
    ]
```

```python
if some_obj == option_1:
    # do something and exit
elif some_obj == option_2:
    # do something and exit
[else
    # do something and exit
]
```
:::::::::

More information can be found at [Python documentation for match statements](https://docspython.org/3/tutorial/controlflow.html#match-statements).

### Loops

#### Overview

- Loops are needed for iteration
    - **repeating** certain pieces of code
    - iterating over collections to **access**, **operate** or **modify** elements
- When **number of repetitions** is
    - **known**: use `for` block
    - **not known**:  use `while` block

######

- It is recommended not to modify the collection (structure) that is being iterated,  
  instead use any of the below solutions
    - create a new collection
    - create a copy

- **Iterating** is a common term which refers to going through elements of a collection.
    - **Iterables** and **iterators** in Python are based on this idea.

#### `for` block

##### Specifications {.smaller .shrink}

::::::::: {layout="[[45,-10,45]]"}

```{python}
#| eval: false
for item in iterable:
    # do something
    # item is available
    print(item)
```

```{python}
#| eval: false
for i in range(n):
    # do something
    # i is available
    print(item)
```

:::::::::

```python
for item in iterable: print(item)
```
::: {.block data-latex="{}"}
Fundamental form

- `for` keyword declares the start of a `for` block
- `item in iterable` is the generic form
- `:`, colon, to declare end of `for` declaration
- code to be repeated, which has access to an item for a given iteration
    - if a short expression has to be repeated it can be used on the same line
:::

######

Using this fundamental form other variation are created. e.g.

- `range(n)` function is used to loop through fixed number of times
    - example to repeat 10 times
        - `for i in range(10):` i takes values 0 through 9
        - `for i in range(1, 11):` i takes values 1 through 10
    - `range()` function
- loops can be nested using indentation
    - useful for working with nested data structures

###### `continue`

`continue` clause causes the loop to jump to next iteration without executing remaining lines in loop.

In the below structure, when the condition is true, item will not be printed.

```{python}
#| eval: false

for item in iterable:
    # do something
    # item is available
    if condition:
        continue
    print(item)
```

Continue is useful if you need to skip execution of some code for certain elements of the iterable.

###### `break` and `else` {.smaller .shrink}

- `break` clause causes exit of the **innermost** loop
    - is **optional**
    - **innermost** is critical when there are nested loops
- `else` clause
    - is **optional**
    - is **executed** only if loop ends normally, i.e. no `break` is hit

```{python}
#| eval: false

for item in iterable:
    # do something
    # item is available
    if condition:
        break
    print(item)
else:
    print("No break found")
```

##### Control flow {.shrink}

![](../../../resources/diagrams/control-flow/for-flow.png){width="80%" fig-align="center"}

##### Examples

###### Basic

- Loop through 1 to `n_max = 20`
    - store even numbers in a list `evens`
    - store odd numbers in a list `odds`

```{python}
n_max = 20
evens = []; odds = []
for i in range(1, n_max + 1):
    evens.append(i) if i % 2 == 0 else odds.append(i)
```

```{python}
print(evens)
print(odds)
```

###### `continue`

In the below example only odd numbers are printed as the loop hits `continue` for even numbers.

```{python}
for i in range(5):
    if i % 2 == 0: continue
    print(i)
```

###### `break` and `else`

- For a given list of numbers
    - validate if the numbers are within some limits, e.g. [0, 100]
    - if all values are within limits
        - print "validation successful"
    - if any of the values are outside limits
        - print "validation failed" with value
        - exit the loop

######

```{python}
correct_list = [65, 24, 53, 91, 59, 81, 93, 7, 78, 10]
for num in correct_list:
    if num < 0 or num > 100:
        print(f"validation failed, list contains {num}")
        break
else:
    print("validation successful")
```

######

```{python}
incorrect_list = [97, 144, 115, 127, 33, 99, 85, 109, 21, 110]
for num in incorrect_list:
    if 0 <= num <= 100:
        continue
    else:
        print(f"validation failed, list contains {num}")
        break
else:
    print("validation successful")
```

- Notice that `else` block is useful in this situation as it is run only when for loop iteration is complete without hitting `break` statement.

- There are different ways to structure the same conditions and required outcome.

###### Nested loops {.shrink}

Print table of numbers from 1 through 12 for multiplication with 1 through 10.

```{python}
for i in range(1, 13):
    for j in range(1, 11):
        end = "\n" if j == 10 else "\t"
        print(i*j, end=end)
```

#### `while`

##### Specifications

```python
while condition:
    # code block
    [continue]
    # code block
    [break]
[else]:
    # code block
```

- loop repeats while **condition** is `True` or `break` statement is hit
- `continue`, `break`, `else` clauses are optional

##### Control flow

- main `while` block contents are executed repeatedly until condition is `True`
    - if `continue` statement is hit
        - loop restarts and condition is checked again
- if `break` statement is hit anywhere loop exits
    - without going through `else` block even if present
- when condition is `False`
    - `else` block is executed if present
    - loop is exited

###### 

![](../../../resources/diagrams/control-flow/while-flow.png){width="80%" fig-align="center"}

##### Use cases

A while loop is needed when number of repetitions is not known in advance

- When data structure is dependent on external sources
    - e.g. user input, web data base, ...
- Recursive algorithms
    - Computer science: binary search, merge sort, etc.
    - Math:
        - numerical methods of approximations
        - algorithm to find greatest common divisor

##### Examples

###### Infinite loop

- to be avoided
- very easy to create by not modifying the condition in while block
- ***remember `ctrl + c` to bail out***

```{python}
#| eval: false
condition = True
while condition:
    # forget to set condition = False
    print("inside infinite loop")
```

###### Basic

```{python}
a = 6
while a != 0:
    a -= 1
    if a == 2:
        print(f'break block: {a = }')
        break
    if a == 3:
        print(f'continue block: {a = }')
        continue
    print(f'main block: {a = }')
```

###### GCD algorithm

Below is gcd algorithm to find the greatest common divisor of 2 integers using while loop.

- given 2 numbers a, b
    1. find remainder of a, b (*modulo operator `%` gives the remainder*)
    2. if remainder is zero then b is the gcd
    3. replace a with b and b with remainder (*in Python this is 1 step using multiple assignment*)
    4. goto to step 1

Since the number of repetitions needed are based on input, while loop is suitable for this.

###### 

```{python}
#| results: 'hold'

a, b = 9, 6
rem = a % b
while rem != 0:
    print(f'{a = }, {b = }, {rem = }')
    a, b = b, rem
    rem = a % b

print(f'{a = }, {b = }, {rem = }')
print(b)
```

#### Looping techniques

##### Iterators and Iterables

**Iterator** is an object that can be iterated upon its elements only **once**. It is **exhaustible**.

**Iterable** is an object that can be iterated upon its elements repeatedly.

Both cannot be viewed directly and have to be converted into a list or tuple to view contents.

######

::: {.callout-caution icon="false"}
Be careful while using iterators since they are **consumable** or **exhaustible**.

Do not store them in variables for re-use.
:::

```{python}
some_tuple = "a", "b", "c", "d"
some_iterator = enumerate(some_tuple)
```

```{python}
print(list(some_iterator))
```

```{python}
print(list(some_iterator))
```

######

{{< include ../../../resources/tables/_iters.qmd >}}

##### Accessing index of iterables (sequences)

- `enumerate(iterable)` to access index and value of items in an iterable

```{python}
some_tuple = "a", "b", "c", "d"
list(enumerate(some_tuple))
```

```{python}
for idx, item in enumerate(some_tuple):
    print(f'{idx=}, {item=}')
```

###### Without `enumerate`

- lengthier
- inconvenient
- inefficient

```{python}
for idx in range(len(some_tuple)):
    print(f'{idx=}, item={some_tuple[idx]}')
```

##### Multiple iterables

- `zip(iterable1, iterable2, ...)`
    - returns an iterator

```{python}
some_list = [1, 2, 3]
some_tuple = (4, 5, 6)
list(zip(some_list, some_tuple))
```

```{python}
result = []
for e1, e2 in zip(some_list, some_tuple):
    result.append(e1 + e2)
print(result)
```

###### Without zip

```{python}
result = []
for idx in range(len(some_list)):
    result.append(some_tuple[idx] + some_list[idx])
print(result)
```

##### Dictionary

Python provides multiple functions to help iterating over dictionaries.

- keys: `d.keys()`
- values: `d.values()`
- keys, values: `d.items()`

- All of these return a view object which is an iterator.

- Most commonly used is `d.items()` as it provides access to both key and value.

###### Example

```{python}
some_dict = {"key 1": "value 1", "key 2": "value 2", "key 3": "value 3"}
for k, v in some_dict.items():
    print(f'key = {k}, value = {v}')
```

##### Mutable collections

- Issue
    - do not modify mutable collections (`list`, `dict`, `set`) structurally
    - difficult to predict behavior

- Solutions
    - create a new collection
    - create a copy while iterating

###### Examples with errors

###### List

```{python}
nums = list(range(1, 6))
print(nums)
for num in nums:
    if num <= 3:
        nums.remove(num)

print(nums)
```

###### Dictionary

```{python}
#| error: true
some_dict = {"k1": "v1", "k2": "v2", "k3": "v3"}
for k, v in some_dict.items():
    if k == "k2":
        del some_dict[k]
```

###### Solutions

#### Create a new collection: List

```{python}
nums = list(range(1, 6))
new_nums = []
for num in nums:
    if not num <= 3:
        new_nums.append(num)
```

```{python}
print(nums)
print(new_nums)
```

#### Create a new collection: Dictionary

```{python}
some_dict = {"k1": "v1", "k2": "v2", "k3": "v3"}
new_dict = {}
for k, v in some_dict.items():
    if not k == "k2":
        new_dict[k] = v
```

```{python}
print(some_dict)
print(new_dict)
```

#### Create a copy: List

```{python}
nums = list(range(1, 6))
print(nums)
for num in nums.copy():
    if num <= 3:
        nums.remove(num)
```

```{python}
print(nums)
```

#### Create a copy: Dictionary

```{python}
some_dict = {"k1": "v1", "k2": "v2", "k3": "v3"}
print(some_dict)
for k, v in some_dict.copy().items():
    if k == "k2":
        del some_dict[k]
```

```{python}
print(some_dict)
```

### Error handlers

#### Introduction

##### Errors

- given the number of rules and syntax there are a lot of opportunities for errors

- 2 broad categories
    - **Syntax error**: caught when the code is being parsed
        - parsed means interpreter is reading the code to figure out what is to be done
        - commonly referred to as [**compile time error**]{color="brown"}
    - **Exception**: error detected during execution
        - commonly referred to as [**run time error**]{color="brown"}

###### 

- Syntax error

```{python}
#| error: true

a =, 2
```

- Exception

```{python}
#| error: true
# try:
###     1/0
# except Exception as e:
###     print(e)
eg_num = 1/0
```

##### Exceptions {.smaller .shrink}

- Python has some built-in known exceptions or error types.

- Exceptions are objects built using object oriented programming.

- Examples
    - `Exception`: base catch almost all errors
    - `ZeroDivisionError`: division by zero
    - `TypeError`: operation not supported by `type`[s] used in operation
- On run time error, an `Exception` type object is created which has information regarding
    - `Exception` type
    - **traceback**

###### Python Exception hierarchy {.shrink}

![](../../../resources/diagrams/control-flow/exceptions-hierarchy.png){width="80%" fig-align="center"}

- [Python documentation for built in exceptions](https://docspython.org/3/library/exceptions.html?highlight=typeerror#built-in-exceptions).

###### `raise`

- `raise` statements causes the program to stop with default exception.
- Optionally a known error can be passed with a custom message
    - e.g. `raise ValueError("Invalid input")` 
- `raise` uses with `try` and `while` blocks
    - expected error is intercepted and has to handled differently.

```python
raise ValueError("some custom message")
```

##### Examples

```{python}
1/0
```

```{python}
undefined_var_name
```

```{python}
some_list = [1, 2, 3]
print(some_list[10])
```

```{python}
float("text")
```

```{python}
"abc"*"xyz"
```

#### `try` blocks

##### Overview

- `try...except` blocks are used to [intercept]{color="blue"} and [handle]{color="blue"} [expected]{color="green"} [run time errors]{color="red"} [differently]{color="blue"}

- Use cases
    - ignore the error and continue running the program
    - do some clean up before letting the error stop the program
    - run some code irrespective of error or not

##### Specifications {.shrink .smaller}

```python
try:
    # try code block
[except Exception as e:
    # except code block
    [raise]]
[else:
    # else code block]
[finally:
    #  finally code block]
```

- **required**
    - there must be at-least one `except` or `finally` block
    - `else` clause (if present) should be after the `except` block
- **optional**
    - there can be multiple `except` clauses
    - `raise` statement and `else` block are optional

##### Control flow

- `try` block statements are always evaluated first
- `except` blocks are run when they trap  specified **error**
    - if `raise` statement is hit
        - `finally` block is run
        - program is stopped with the `<Exception type>` raised
- `else` block is run in case of **no error**
- `finally` block is run ***always***, error or no error
    - generally used for clean up

######

![](../../../resources/diagrams/control-flow/try-flow.png){width="90%" fig-align="center"}

###### `except` blocks

`except` statement in a `try` block is used to declare an `except` block.

- They can be used in 2 forms.
    - `except <Exception type>`
    - `except <Exception type> as <variable name>`

- run if there is a run time error while executing `try` block and the error matches the `<Exception type>` specified

###### 

- `<variable name>` is bound to the `<Exception type>` object

- 2 main components
    - Exception type, e.g. `NameError`, `TypeError`, etc.
    - Error object: traceback

##### Use cases

Try blocks are generally used to **intercept expected errors** and control the outcome if error occurs, use case depends on the context. e.g. 

- avoid stopping program on an expected error
    - when program depends on external sources, e.g. db operations, web requests, ...
- do something on an expected error and then raise the error
- handle different error types differently

##### Examples

###### Ask user input until it is correct

- This is an example for nesting different control flow techniques.

- The same problem serves as a use case for using recursive functions discussed later.

```{python}
#| eval: false

while True:
    try:
        some_int = int(input('Enter an integer...'))
        print(some_int)
        break
    except ValueError:
        continue
```

## Functions

### Introduction

#### Terminology

##### Historically {.smaller}

::: {.block data-latex="{}"}
- **Sub-routine**: any named block of code that can be called (run) using its name
    - **Procedure**: any sub-routine that
        - has side effects
        - does not take any input
        - does not return anything
    - (**Pure**) **Function**: any sub-routine that
        - does not have side effects, does not leave its trace after execution
        - takes inputs and operates only on the inputs
        - returns something
:::

##### Currently

::: {.block data-latex="{}"}
- Functions
:::

#### Background {.shrink .smaller}

::: {.block  data-latex="{}"}
- Functions are a major pillar in any programming language

- **Repeat related tasks with code reuse**

- At a more abstract level, functions provide
    - **means of combination**
        - build smaller pieces and then join to make a bigger piece
    - **means of encapsulation**
        - hide details of implementation during usage
    - **means of abstraction**:
        - create blueprints of functionality
:::

#### Components of a function {.smaller}

![](../../../resources/diagrams/functions/parts.png){width="70%"}

::: {.block data-latex="{}"}
- *Name*
- *Parameters* (optional)
- *Body* (code)
    - *docstring* (optional, beginning)
    - *return* statement (optional)
:::

#### Usage {.smaller}

A function can be

- **Called** `function_name(parameter_1 = argument_1, ...)`
- **Stored** `variable_name = function_name`
- **Passed** `function_name_2(variable_name = function_name)`

#### Functions are callable {.smaller}

- In simplest form a function call
    - (_optionally_) **receives** arguments (value) for some predefined parameters
    - (_optionally_) **runs** some code to execute certain operation[s]
    - (_optionally_) **returns** some object[s]
    - e.g. `some_func()`, `len(iterable)`, `add(1, 2)`, ...

- A function call can have **side effects**
    - it does something in background
        - write to a database
        - do some i/o task, e.g. print
    - may or may not return any object

#### Functions are objects

- Can be *assigned to a variable*
- Can be *stored* in a data structure (such as `list`, `tuple`, `dictionary`, ...)
- Can be *passed to a function as an argument*
- Can be *returned from a function*

#### Different forms of functions

- **Regular functions**
- **Anonymous functions**: **lambda expressions**
- **Partials**: new function from an existing function with partial set of arguments provided
- **Higher order functions**: take function[s] as arguments and optionally return function[s]

#### Lifetime of functions {.shrink .smaller}

- At *compile time* (when the function definition is read)
    - function object is created without evaluation, except
        - objects are created for parameters with default values
        - default values are objects stored in function object
    - code is stored in the function object
    - variables are assigned scopes

- At *run time* (when the function is called)
    - a new local scope is created in the calling environment
    - variable names are looked up in assigned scopes
    - function code is evaluated

### Basic Specifications

#### First line

##### {.smaller}

- Statement starting with keyword `def` declares a function definition
- `def` *must be* followed by
    - **function name**
    - a pair of **parenthesis** ending in `:`
- Parenthesis on the first line can *optionally* contain **parameters**
    - parameters can *optionally* be **annotated** with `type`
        - types are *not evaluated*
        - e.g. `def func(a:int, b:str) -> str:`
        - `-> str` indicates the function returns a `str` type object
    - detailed discussion on parameters separately in parameters section
- Colon (`:`) must be followed by **function body**
    - if function body is too short it can be included on the same line

##### Short functions on 1 line

```python
def some_short_func(x, y): return x + y
def some_short_func(): pass
def some_short_func(): ""
```

#### Function body

::::::::: {.columns}
:::::: {.column width=50%}
- *Must be* **indented**
- First line can *optionally* be a **doc string**
- *Optionally* contain **return**
- *Optionally* contain **pass**
::::::
:::::: {.column width=5%}
::::::
:::::: {.column width=45%}

```python
def function_name(a, b):
    """function description
    parameter 1: description
    returns: description
    """
    # code block
    return result_object
```
::::::
:::::::::

#### Doc strings

- Doc strings are used to document functions

- Can be multiline strings.

- Critical for large projects or packages

- [sphinx](https://www.sphinx-doc.org/en/master/)

- [VSCode Extension: autoDocstring - Python Docstring Generator](https://marketplace.visualstudio.com/items?itemName=njpwerner.autodocstring)

#### `pass` statement

- `pass` statement does not alter control flow
- Used as place holder for functions to be implemented
- Can be replaced by a doc string

```{python}
#| eval: false
def some_func(): pass

def some_func(): ""
```

#### `return` statement {.smaller}

- Syntax: `return [expression_list]`
- `expression_list` can be
    - a single object
    - comma separated objects which are turned to a tuple
- Control flow:
    - when a `return` statement is hit anywhere in the code block
        - expression_list, if present, is evaluated and returned
        - `None` returned if there is no expression
        - function call is exited
    - **exception**: when `return` is hit from `try..except..else..finally` block
        - `finally` block is run before the function call is exited

### Parameters and arguments

#### Definitions

- **Parameters**: are input variables in context of defining the function

- **Arguments**: are variables or objects passed to parameters in context of calling the function

##### Basic example

```python
def some_func(a, b):
  # code block
  pass

x = "a string"

some_func(10, x) # function call
```

- `a` and `b` are *parameters* of `some_func`
- `10` and `x` are *arguments* for `some_func`

#### Object passing

- In Python, the arguments are passed as object references to the parameters.

- Therefore if the object passed is mutable, changes will be propagated.

##### {.shrink}

```{python}
#| results: 'hold'
an_int = 10; a_string = "abc"; a_tuple = (an_int, a_string)
a_list = [*a_tuple]

def a_func(x1, x2, x3, x4):
    x4.append("xyz")
    print('-'*20)
    print('from within function call')
    print(x1 is an_int, x2 is a_string, x3 is a_tuple, x4 is a_list)
    print('-'*20)
    return x1, x2, x3, x4

ret_tuple = a_func(x1=an_int, x2=a_string, x3=a_tuple, x4=a_list)

print(ret_tuple[0] is an_int, ret_tuple[1] is a_string, \
        ret_tuple[2] is a_tuple, ret_tuple[3] is a_list)

print(f'{a_list=}')
```

#### Argument types

Based on how parameters are defined arguments can be passed in different ways

- **Positional arguments**: are passed to parameters using position during a function call

- **Keyword arguments**: are passed to parameters using keyword (parameter name) during a function call, also called **named parameters**

- **Optional/default arguments**: any parameter with default value specified makes the argument optional
    - with positional arguments order has to be kept in mind

##### Examples

```python
def some_func(a, b):
    pass
```

```python
some_func(10, 20) # passed as positional
some_func(a = 10, b = 20) # passed as keyword
```

###### Examples

```{python}
def some_func(a, b=20): # b is optional
    print(f'{a = }, {b = }')
```

::: {layout="[[45,-10,45]]"}

```{python}
some_func(10)
some_func(10, 30)
```

```{python}
some_func(a = 10)
some_func(b = 30, a = 10)
```

:::

#### Specifications {.smaller}

- General structures for defining parameters (`/`, `*`, `**`)
    - `function_name(<pos or kw>)`
    - `function_name(<pos>, /, <po or kw>, *, <kw>)`
    - `function_name(<pos>, /, <po or kw>, *args, <kw>, **kwargs)`

- **Regular arguments**: by default all arguments can be passed as positional or keyword subject to
    - **positional** arguments **must** come **before** **keyword arguments**
    - once a keyword argument is given all remaining arguments are keyword

- After one default argument, remaining must be default
    - except for keyword only arguments

##### {.smaller}

- **Separation**
    - `/` is used to separate positional only arguments
    - `*` is used to separate keyword arguments

- **Collection** (**variadic arguments**)
    - `*args` collects all available positional arguments as a **tuple**
        - has to be defined after other positional arguments if present
        - `args` is just convention, can be name of choice, but recommended
    - `**kwargs` can collect all available keyword arguments as a **dictionary**
        - has to be defined at the end
        - `kwargs` is just convention, can be name of choice, but recommended

- `*` and `*args` mark the beginning of keyword arguments, hence cannot precede `/`

#### Use cases {.smaller}

- As a user of packages
    - regular arguments are needed mostly
    - while using external packages familiarity with the specifications will help

- **Positional only** parameters are used when
    - parameter names have no meaning
    - reliance on keyword for passing arguments has to be avoided
    - e.g. `print` function: multiple objects can be passed before any kw arg

- **Keyword only parameters** are used when
    - names have special meaning
    - reliance on positional arguments has to be avoided
    - e.g. `print` function: `end`, `sep` etc. have to be passed after all positional variadic args as kw

#### Examples {.shrink .smaller}

**Regular arguments**: by default all arguments can be passed as positional or keyword subject to

- Positional arguments **must** come before keyword arguments  
  once a keyword argument is given all remaining arguments **must** be keyword

```{python}
#| eval: false
def some_func(a, b, c):
    pass
```

::::::::: {layout="[[45,-10,45]]"}
::: {.callout-tip data-latex="{Allowed}"}
##### Allowed
- `some_func(10, 20, 30)`
- `some_func(10, 20, c = 30)`
- `some_func(10, b = 20, c = 30)`
:::

::: {.callout-warning data-latex="{Not allowed}"}
##### Not allowed
- `some_func(a = 10, 20, 30)`
- `some_func(10, b = 20, 30)`
- `some_func(a = 10, b = 20, 30)`
:::
:::::::::

##### Separation

- `/` is used to separate positional only arguments
- `*` is used to separate keyword arguments

```{python}
def some_func(pos_1, pos_2, /, pos_or_kw_1, *, kw_1, kw_2):
    print(f"{pos_1=}, {pos_2=}, {pos_or_kw_1=}, {kw_1=}, {kw_2=}")
```

```{python}
some_func(1, 2, 3, kw_1=4, kw_2=5)
some_func(1, 2, pos_or_kw_1=3, kw_1=4, kw_2=5)
some_func(1, pos_2=2, pos_or_kw_1=3, kw_1=4, kw_2=5)
```

##### Variadic arguments {.smaller}

- **Collection** (**variadic arguments**)
    - `*args` collects all available positional arguments as a tuple
        - has to be defined after other positional arguments if present
        - `args` is just convention, can be name of choice, but recommended
    - `**kwargs` can collect all available keyword arguments as a dictionary
        - has to be defined at the end
        - `kwargs` is just convention, can be name of choice, but recommended

###### Examples

```{python}
def some_func(*args, **kwargs):
    print(f'{args}')
    print(f'{kwargs}')
```

```{python}
some_func(1, 2, 3)
some_func(1, 2, 3, a = 4, b = 5)
```

- `args` is just convention, can be name of choice, but recommended
- `kwargs` is just convention, can be name of choice, but recommended

###### Examples

```{python}
def some_func(*args_tuple, **kw_dict):
    print(f'{args_tuple}')
    print(f'{kw_dict}')
```

```{python}
some_func(1, 2, 3)
some_func(1, 2, 3, a = 4, b = 5)
```

### Examples

#### Check primes

Prime is a positive integer greater than 1 which is divisible only by 1 and itself. E.g. 2, 3, 5, ...

Given a positive integer check if it is a prime. Print a message confirming the result.

### Solution: Code {.shrink}

```{python}
def check_prime(num: int) -> None:
    """
    check if a number is prime and print the result
    num: positive integer
    returns: None
    """
    if not isinstance(num, int):
        print(f'{num} is not an integer')
        return
    if num <= 1:
        print(f'{num} is not a positive integer greater than 1')
        return
    divisors = []
    for i in range(1, num + 1):
        if num % i == 0: divisors.append(i)
    if divisors == [1, num]:
        print(f'{num} is a prime')
    else:
        print(f'{num} is not a prime')
```

#### Solution: Results

```{python}
check_prime(10)
check_prime(23)
check_prime(1)
check_prime(-2)
```

#### GCD {.smaller}

Implement the gcd algorithm using a function that takes 2 numbers as input and returns the greatest common divisor.

Below is gcd algorithm to find the greatest common divisor of 2 integers.

- Given 2 numbers a, b
    1. find remainder of a, b (*modulo operator `%` gives the remainder*)
    2. if remainder is zero then b is the gcd
    3. replace a with b and b with remainder (*in python this is 1 step using multiple assignment*)
    4. goto to step 1

### Solution: `while`

```{python}
#| results: 'hold'

a, b = 9, 6
rem = a % b
while rem != 0:
    print(f'{a = }, {b = }, {rem = }')
    a, b = b, rem
    rem = a % b

print(f'{a = }, {b = }, {rem = }')
print(b)
```

### Solution: function {.shrink .smaller}

```{python}
def calc_gcd(num_1: int, num_2: int) -> int:
    """
    Calculate and return the greatest common divisor of 2 integers
    """
    rem = num_1 % num_2
    while rem != 0:
        num_1, num_2 = num_2, rem
        rem = num_1 % num_2
    return num_2
```

Having defined the function, it can be called multiple times with different values without worrying about the implementation. This serves as an example of **means of encapsulation**.

```{python}
calc_gcd(3, 9)
calc_gcd(12, 45)
```

### Caveat for default values

#### Issue {.smaller}

- When using mutable data types (like list, dictionary or set) as default values for function parameters, the behavior has to be looked out for.

- Default values are typically used for immutable data types like numbers, strings or bool.

- It is important to note that default values are created once in memory at compile time
    - when the `def` statement is executed for creating the function object
    - i.e. at compile time
    - not during a function call.

#### Example

```{python}
#| results: hold
def some_func(num, some_list=[]):
    some_list.append(num)
    return some_list

print(some_func(1))
print(some_func(2))
```

- Note that during second call same list was used.

##### Solution

```{python}
#| results: hold
def some_func(num, some_list=None):
    if some_list == None: some_list = []
    some_list.append(num)
    return some_list

print(some_func(1))
print(some_func(2))
```

### Higher order functions

#### 

- Higher order functions evolved as part of functional programming paradigm where functions are treated as objects.

- Higher order functions are functions that
    - take function[s] as input
    - optionally return function[s]

####

- Higher order functions along with rules of scoping are used to create different types of functions

- Design patterns created using higher order functions
    - **Map-Reduce**: apply some function to elements of a collection
    - **Factory** functions: create new functions based on some input argument
    - **Decorator** functions: add some standard functionality to a function

####

- Python standard library has some modules/packages to help with these
    - [`functools`](https://docs.python.org/3/library/functools.html?highlight=reduce#module-functools): Higher-order functions and operations on callable objects
    - [`operators`](https://docs.python.org/3/library/operator.html): Standard operators as functions

#### Map Reduce

##### 

::: {.block data-latex="{}"}
- Map-Reduce is a design pattern to work with collections.
- These are newer features in high level languages like Python.
- They provide a better and cleaner alternative to iterative solutions using loops for working with collections.
- Filter is a special case of map.
- Collectively these are also referred to as functionals.
:::

##### {.smaller}

Improvement in in properties of the program

- Readability
    - iteration is isolated from what operation is being done, hence better readability
- Modularity
    - map is responsible for iteration
    - function passed is responsible for operation to be applied to each element
- Extensibility
    - function passed can be anything, so different operations can be applied by defining new functions without impacting the core functionality of iterating and applying the function.
- Testability
    - it is easier to test and debug as the structure is modular
- Efficiency
    - map is faster than loop but slower than comprehensions

##### Map

**Map** is a generic concept of applying (mapping) a function to all elements of a collection or multiple collections in parallel.

**Map** is a better alternative to `for` loops as code readability is improved as what is being done is isolated from iteration.

###### Syntax

- `map(function, iterable[, iterables])` is the Python implementation
    - returns an *iterator* (consumable, can be used once)

- With **single iterable**
    - function applied should take 1 argument which will be elements of the iterable

- With **multiple iterables**
    - function applied should take as many arguments as iterables
    - `map` stops at iterable of shortest length, if lengths are different

######

:::::: {layout="[[45,-5,50]]"}
::: {.center data-latex=""}
![single iterable](../../../resources/diagrams/functions/map-1.png)
:::

::: {.center data-latex=""}
![multiple iterables](../../../resources/diagrams/functions/map-2.png)
:::
::::::

#### Example: Single iterable

```{python}
some_list = list(range(5))
```

####### Loop

```{python}
sqrd_list = []
for x in some_list:
    sqrd_list.append(x**2)
```

```{python}
#| echo: false
print(f'{sqrd_list = }')
```

####### Map

```{python}
def sqr(x):
    return x**2

sqrd_itr = map(sqr, some_list)
```

```{python}
#| echo: false
print(f'{list(sqrd_itr) = }')
```

###### Map & lambda

```{python}
sqrd_itr = map(lambda x: x**2, some_list)
```

```{python}
#| echo: false
print(f'{list(sqrd_itr) = }')
```

#### Example: Multiple iterables

```{python}
tuple_1 = 1, 2, 3
tuple_2 = 4, 5
```

```{python}
tuple(map(lambda x, y: x + y, tuple_1, tuple_2))
```

```{python}
tuple(map(lambda x, y: x + y, tuple_2, tuple_1))
```

##### Filter

::: {.block data-latex="{}"}
**Filter** is a generic concept of filtering values from a collection using certain conditions.

Note that it is a special case of map.
:::

**Syntax**

- `filter(function, iterable)` is provided in Python
    - returns an iterator (consumable, can be used only once)
    - function should return true or false when acting on an element
    - if function is `None` then all truthy elements are returned

#### Example: `None`

```{python}
some_list = [1, 0, None, '', 'abc', tuple()]
```

```{python}
list(filter(None, some_list))
```

Below is the same task done using iterative solution.

```{python}
filtered_list = []
for item in some_list:
    if item: filtered_list.append(item)
filtered_list
```

###### Example

- filter positive integers from a list

```{python}
some_list = [-2, -1, 0, 1, 2]
```

```{python}
[*filter(lambda x: x > 0, some_list)]
```

Below is the same task implemented using iterative solution.

```{python}
filtered_list = []
for item in some_list:
    if item > 0: filtered_list.append(item)
```

```{python}
filtered_list
```

##### Reduce

######

- Reduce is a generic concept of **aggregating elements** of a collection into single result.

- The actual underlying operation is to apply a function (operation) to 2 items at a time recursively.

- $collection = [e_0, e_1, e_2, e_3, e_4, \cdots, e_{n - 1}]$
    - result of step 1: $r_1 = f(e_0, e_1)$
    - result of step 2: $r_2 = f(r_1, e_2)$
    - result of step 3: $r_3 = f(r_2, e_3)$
    - ...
    - result of step n - 1: $r_{n - 1} = f(r_{n - 2}, e_{n - 1})$

######

- Optionally an initial value can be given which is used as the base case
    - Step 1 uses this value and the first element.
    - This is also used in case the collection has 0 or 1 element.

- Note that there will be an error if the collection is empty and no initializer is specified.

- **sum** of some numbers is applying **reduce**
- **cumulative sum** of some numbers is the **intermediate result of reduce**

######

- Reduce is less often used
    - most often used to create aggregate tables and data

- Python standard library has tools to apply reduce and accumulate.
    - `functools.reduce(function, iterable[, initializer])`
    - `itertools.accumulate(iterable[, func, *, initial=None])`

###### Example

To find the sum of numbers in a list using iterative solution and reduce.

```{python}
some_list = list(range(10))
print(some_list)
```

```{python}
sum_itr = 0
for num in some_list:
    sum_itr += num
```

```{python}
sum_itr
```

######

```{python}
import functools as ft
import operator as op

sum_red = ft.reduce(op.add, some_list, 0)
```

```{python}
sum_red
```

- Instead of defining `add_func = lambda x, y: x + y`, `operator` module was used.

### Recursive functions

#### Background

- Recursion is a generic concept of repeating a smaller well define task to get to a solution using base case[s]
    - e.g. gcd algorithm

- Recursion can be implemented using iterative solution or recursive functions

#### Introduction {.smaller}

- Recursive functions call themselves from within themselves to terminate when the base case[s] is reached
    - base case[s] need to be defined carefully to **avoid infinite recursive calls**

- [Python tutor](https://Pythontutor.com/Python-debugger.html#mode=edit)

- Recursive functions in programs
    - not always efficient
    - better for code readability

- _Do not use recursive functions unless it is unavoidable_
    - generally used in algorithms
    - merge sort is an example of recursive algorithm that is efficient

#### Examples

##### Factorial

$$
\begin{aligned}
n! &= n*(n-1)*(n-2)*\cdots*1 \\
&= n * (n-1)! \\
0! &= 1
\end{aligned}
$$

######

::::::::: {layout="[[49,-2,49]]"}

```{python}
#| eval: false
def fact_iter(n):
    result = 1
    for i in range(1, n+1):
        result *= i
    return result
```

```{python}
#| eval: false
def fact_rec(n):
    if n == 0:
        return 1
    else:
        return n*fact_rec(n-1)
```

:::::::::

```{python}
#| eval: false
fact_rec = lambda n: 1 if n == 0 else n*fact_rec(n-1)
```

##### GCD Algorithm {.smaller}

- Given 2 numbers a, b
    1. find remainder of a, b (*modulo operator `%` gives the remainder*)
    2. if remainder is zero then b is the gcd
    3. replace a with b and b with remainder (*in Python this is 1 step*)
    4. goto to step 1

- Earlier this was solved using `while`

- Implement this using
    - regular function
    - recursive function

#### Solution: `while`

```{python}
#| results: 'hold'

a, b = 9, 6
rem = a % b
while rem != 0:
    print(f'{a=}, {b=}, {rem=}')
    a, b = b, rem
    rem = a % b

print(f'{a=}, {b=}, {rem=}')
print(b)
```

###### Regular function

```{python}
def find_gcd(a: int, b: int) -> int:
    """
    find the greatest common divisor of 2 integers a and b
    """
    rem = a % b
    while rem != 0:
        a, b = b, rem
        rem = a % b
    return b
```

```{python}
find_gcd(35, 28)
```

###### Recursive function

```{python}
def find_gcd_rec(a: int, b: int) -> int:
    """
    find greatest common divisor of 2 integers a and b using recursion
    """
    rem = a % b
    if rem == 0:
        result = b
    else:
        result = find_gcd_rec(b, rem)
    return result
```

```{python}
find_gcd_rec(35, 28)
```

###### Refactoring

```{python}
def find_gcd_rec(a: int, b: int) -> int:
    """
    find greatest common divisor of 2 integers a and b using recursion
    """
    rem = a % b
    if rem == 0:
        return b
    else:
        return find_gcd_rec(b, rem)
```

###### Refactoring

```{python}
def find_gcd_rec(a: int, b: int) -> int:
    """
    find greatest common divisor of 2 integers a and b using recursion
    """
    rem = a % b
    return b if rem == 0 else find_gcd_rec(b, rem)
```

##### Handling exceptions

- Ask user input until it is correct
- Limit maximum incorrect trials

#### Solution: control flow blocks

```{python}
#| eval: false

while True:
    try:
        some_int = int(input('Enter an integer...'))
        print(some_int)
        break
    except ValueError:
        continue
```

#### Solution: recursive function {.shrink}

```{python}
def get_an_integer(max_count=5, count=1):
    """
    Ask user to input an integer until integer is provided
    or maximum number of trials expire
    """
    try:
        some_int = int(input('Enter an integer...'))
        return some_int
    except ValueError:
        print(f'This was try number {count}, and was not an integer.')
        if count < max_count:
            count += 1
            get_an_integer(count=count)
        else:
            print(f"maximum tries ({max_count}) reached")
```
## Object Oriented Programming (OOP)

### Introduction

#### 

- **Object oriented programming** $\to$ **OOP**
- Fundamental to how objects are defined and used in a programming language

- There are 2 components of OOP
    - **object definition**: aka **class** definition or **type** definition
    - **object instance[s]**: creation of the object[s] of a certain class (type)

#### Basic example

- `int` is a class or type
- multiple instances like `1`, `2` etc.

- In Python, `type` is the root class of all classes
    - `type` and class are used interchangeably
    - `type` can also be used as a function
        - to check the class of an object

```{python}
type(10), type(int), type(type)
```

#### Class Structure {.smaller}

**Class** is the blueprint of a certain type of object, what attributes all instance objects of this type will share

- **state**: data attributes define the state of an instance
- **operations**: callable attributes (**methods**)

**Class instance object** is an instance object of certain class (`type`) created and stored on RAM

- multiple instances can be created
- usually referred to as objects

#### Use cases

At a more abstract level, OOP provide

- **means of combination**
    - combine data and operations
    - build smaller pieces and then join to make a bigger piece
- **means of encapsulation**
    - hide details of implementation during usage
- **means of abstraction**:
    - create blueprints of functionality
    - although functions can be used, OOP is better for this

#### Namespaces

Class and instances have their own namespaces.

Instance object namespace is searched first then class namespace is searched by the interpreter for variables.

#### Attributes of an object

###### Overview

####### Data attributes

- **class** level
    - **bare**
    - **properties**: **static** or **calculated**
- **instance** level
    - **bare**
    - **properties**: **static** or **calculated**

####### Methods

- **instance** methods
- **class** methods
- **static** methods

##### Data attributes

- **Class data attributes**: Shared across all instance objects
    - They are suited for data attributes that do not define the state of an object
    - Main advantage: can be configured centrally
    - If the value is changed all instance objects have access to the new value.

- **Instance data attributes**: define the state of an instance object
    - local to the instance, change is not propagated

###### {.smaller}

- **Bare data attributes**: any attribute, class or instance, that can be accessed and modified directly without any pre or post functionality

- **Properties** hide bare data attributes behind a property name
    - if referenced from any instance object, act upon the bare attribute
    - used to add some pre and post code while accessing or modifying the bare data attribute

- **Static properties**: do not calculate the values of the underlying bare data attribute

- **Dynamic properties**: do calculate the values of the underlying bare data attribute based on some other values

##### Methods

- Methods are callable attributes that provide operations

- By **default** methods defined inside a class are **instance methods**
    - can be declared to be class or static using decorator syntax

###### Method types {.smaller}

- **Instance methods**
    - accessible from instance only
    - have with access to the instance object itself
    - first parameter is enforced to be the instance object

- **Class methods**
    - accessible from both class and all instance objects
    - access to class attributes
    - first parameter is enforced to be the class object

- **Static methods**
    - accessible from both class and all instance objects
    - regular functions without any enforced parameter

### Basics

#### Create a class and access attributes

- it is a convention, in Python, to use CamelCase for class names

```{python}
class BasicClass:
    data_attr = "bare class attribute"
```

- accessing attributes
    - `getattr()`, `setattr()`, `delattr()`
    - dot notation (`.`)

```{python}
BasicClass.data_attr
```

#### Create instance and access attributes

- create instances by calling the class

```{python}
obj_1 = BasicClass()
obj_2 = BasicClass()
```

- access attributes using dot notation (`.`)

```{python}
obj_1.data_attr
obj_2.data_attr
```

###### 

- check type of any instance object

```{python}
type(obj_1), type(obj_2)
```

- class attributes are shared by instance objects and are useful for data attributes to be changed centrally

```{python}
BasicClass.data_attr = "new value"
obj_1.data_attr, obj_2.data_attr
```

### Instance methods

#### Incorrect example

#####

- define the class

```{python}
class CustomClass:
  def custom_method():
    print("running custom_method")
```

- call the method from class directly
    - **this will work but not useful**

```{python}
CustomClass.custom_method()
```

#####

- create an instance object and call the method from instance object
    - **this will not work**

```{python}
#| echo: false

class CustomClass:
  def custom_method():
    print("running custom_method")
```

```{python}
#| error: true

obj_1 = CustomClass()
obj_1.custom_method()
```

#### Correct example

##### `self` argument {.smaller}

- Error reason
    - methods by default are bound to instance object
    - first parameter is passed by Python as the instance object itself

- It is a convention to call this first parameter `self`
    - It can be named anything
    - it is recommended to use `self` for consistency

- Instance methods are not meant to be called directly from class

```{python}
class CustomClass:
  def custom_method(self):
    print("running custom_method")
    print(self)
```

##### Calling from class

- Call instance method from class directly: **this will not work**
- This is because there is no instance object to pass as first argument
- How class and static methods are defined will be covered later

```{python}
#| error: true

CustomClass.custom_method()
```

##### Calling from instance

```python
class CustomClass:
  def custom_method(self):
    print("running custom_method")
    print(self)
```

- Create an instance and call the method from instance directly: this will work

```{python}
#| error: true

obj_1 = CustomClass()
obj_1.custom_method()
```

### Instance data attributes

#### `__init__`

- `__init__` is an instance method called at the time of instance object creation
    - this is by Python design
    - it is optional

- Used to create instance attributes at the time of instance object creation

##### Example

```{python}
class CustomClass:
    def __init__(self, bare_data_attr_1_val, bare_data_attr_2_val):
        self.bare_data_attr_1 = bare_data_attr_1_val
        self.bare_data_attr_2 = bare_data_attr_2_val

    def custom_method(self):
        print('running custom_method')
        print(f'with access to {self.bare_data_attr_1 = }')
        print(f'and {self.bare_data_attr_2 = }')
```

###### Create instances {.shrink}

```{python}
obj_1 = CustomClass(2, 4)
obj_1.bare_data_attr_1, obj_1.bare_data_attr_2
obj_1.custom_method()
```

```{python}
getattr(obj_1, "bare_data_attr_1")
setattr(obj_1, "bare_data_attr_1", "abc")
getattr(obj_1, "bare_data_attr_1")
```

### Instance properties

#### Overview {.smaller .shrink}

- In other languages there is a concept of making certain attributes `private`
    - in Python properties are used for this
    - attribute is still accessible but direct access is discouraged

- To define a property manually use
    - `property(fget, fset, fdel, doc)`
    - `fget`, `fset` and `fdel` are instance methods to get, set and delete property value

- `del` reserved word is used to delete attributes

- It is convention to name the underlying attribute name to be `_<property_name>`
    - this is to indicate that attribute is for internal use

- Using methods to access, modify and delete attributes helps with
    - adding checks and other functionality as needed
    - hiding attribute name behind property name
        - change in attribute name does not break other code using the class

#### Example {.shrink}

```{python}
class CustomClass:
    """This is CustomClass with a bare data attribute and a property"""
    def __init__(self, property_1_val, bare_data_attr_1_val):
        self.property_1_name = property_1_val
        self.bare_data_atrr_1_name = bare_data_attr_1_val

    def get_property_1_name(self):
        print("getter called..")
        return self._property_1_name

    def set_property_1_name(self, property_1_val):
        print("setter called..")
        # required checks or calculations
        self._property_1_name = property_1_val

    def del_property_1_name(self):
        print("delete method called..")
        # required checks or calculations
        del self._property_1_name

    property_1_name = property(fget=get_property_1_name,
        fset=set_property_1_name, fdel=del_property_1_name,
        doc="""The property's description.""")
```

##### Decorator syntax {.shrink}

```{python}
class CustomClass:
    """This is CustomClass with a bare data attribute and a property"""
    def __init__(self, property_1_val, bare_data_attr_1_val):
        self.property_1_name = property_1_val
        self.bare_data_atrr_1_name = bare_data_attr_1_val

    @property
    def property_1_name(self):
        """Property description"""
        print("getter called..")
        return self._property_1_name

    @property_1_name.setter
    def property_1_name(self, property_1_val):
        print("setter called..")
        # required checks or calculations
        self._property_1_name = property_1_val

    @property_1_name.deleter
    def property_1_name(self):
        print("delete method called..")
        # required checks or calculations
        del self._property_1_name
```

### Class methods

#### Overview

- Class methods can be defined using `@classmethod` decorator

- Like instance methods, first parameter is mandatory and gives access to class
    - it is bound to the class
    - it is convention to name this first parameter as `cls`
    - all instances created have access as well

#### Example {.shrink}

```{python}
class CustomClass:
    x = 10
    @classmethod
    def some_class_method(cls):
        print(f"This is a class method bound to class - {cls}")
        print(f"has access to class attributes {cls.x = }")

CustomClass.some_class_method()
obj = CustomClass()
obj.some_class_method()
```

### Static methods

#### Overview

- Static methods are regular functions defined in a class

- Defined using `@staticmethod` decorator

- Can be accessed from class and all instances

- There is no mandatory first parameter

#### Example

```{python}
class CustomClass:
  @staticmethod
  def some_static_method(a=10):
    print("This is a static function")
    print(f"a regular function with parameters, e.g. {a = }")

CustomClass.some_static_method()

obj = CustomClass()
obj.some_static_method(a = 100)
```

### Full example

#### Description {.smaller}

Below is a full example to illustrate all the pieces together. There is a `Circle` class to create circle objects with the following components

- `pi` is a class data attribute
- `_radius` is instance data attribute marked private
    - this is only available in instances
    - not recommended for direct use
- `radius` is a static property to access `_radius` from instances
- `area` is a dynamic property with no set method
    - provides access to attribute `_area`
    - automatically updated when radius changes
- `circumference` is an instance method

#### Code {.shrink}

```{python}
class Circle:
    def __init__(self, radius_val):
        self.radius = radius_val

    pi = 3.141592653589793

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, radius_val):
        print("setting radius and calculating area")
        self._radius = radius_val
        self._area = self.pi * (self.radius**2)

    @property
    def area(self):
        return self._area

    def calc_circumference(self):
        print('calculating circumference')
        return 2*self.pi*self.radius
```

#### Usage

```{python}
c1 = Circle(1)
c1.radius, c1.area, c1.calc_circumference()
c1.area, c1.calc_circumference()
c1.radius = 2
```

### Summary

####

- `class` defines classes which are callable and used to create instance objects

- `__init__` method is used to control creation of attributes at instance object creation

- Access attributes
    - `<obj_name>.<attr_name>[()]`
    - `getattr(<obj_name>, <attr_name>)`
- Modify attributes
    - `<obj_name>.<attr_name> = <something>`
    - `setattr(<obj_name>, <attr_name>, <something>)`
- Delete attributes
    - `del <obj_name>.<attr_name>`
    - `delattr(<obj_name>, <attr_name>)`

####

- Data attributes
    - class level
        - bare: defined directly
        - properties: defined using meta classes (not covered)
    - instance level
        - bare: defined using `__init__`
        - properties: defined using `property()` or `@property`, static or calculated

####

- Methods (operations)
    - instance: have access to the instance object (`self`)
        - available for use with instances not with class itself
    - class methods
        - created using `@classmethod` decorator
        - have access to the class object (`cls`)
    - static methods
        - regular functions
        - created using `@staticmethod` decorator
        - available across instance objects and class

### Advanced topics {.smaller}

- Inheritance
    - single inheritance
    - multiple inheritance

- Python special methods
    - called *dunder* (double underscore) methods
    - provide some default functionality with minimal code
    - e.g. `__init__`, `__str__`, `__repr__`, `__add__`, ...
    - this is the reason for convention to avoid `__` in variable names to avoid clashes

- Meta programming and meta classes

#### Inheritance

- Python supports both
    - **single inheritance**
    - **multiple inheritance**

##### Single Inheritance

- Inherit attributes from a single class
- Hierarchy is built when a class inherits from another class
- **Sub class**: class that inherits
- **Base class**: class from which the sub class inherits

##### Multiple inheritance

- A class can inherit attributes from multiple classes
- Attributes are inherited following a recursive algorithm
- More details are documented at [Python documentation](https://docs.Python.org/3/tutorial/classes.html#inheritance)

#####

- In-built functions to check the class hierarchy
    - `isinstance(<obj>, <type>)`
    - `issubclass(<sub class>, <base class>)`

```{python}
isinstance(True, int), issubclass(bool, int)
```

## Python special features

### Conditional expressions

#### Overview

Python has 3 specials concepts related to conditional expressions.

- **truthy/falsy**: object's associated truth value
- **execution context**: decides evaluation result
- **short circuit**

#### Truthy and Falsy

##### Overview

- Every object in Python has an **associated truth value**
  - referred to as **object's truth value**
  - if the **object's truth value** is `True` $\implies$ **truthy**
  - if the **object's truth value** is `False` $\implies$ **falsy**
  - hence the object is **truthy** or **falsy**

- `bool(any_object)` function returns **object's truth value**

######

- Below cases are **falsy** and everything else **truthy**:
  - `None`
  - `False`
  - `0` in any numeric type (e.g. 0, 0.0, 0+0j, …)
  - `len(c) = 0`: **empty collections**
  - custom classes that implement `__bool__` or `__len__` method that return `False` or `0`

##### Examples

###### Numeric type

```{python}
num_1_1 = 1; num_1_2 = 1.0
```

```{python}
#| echo: false
#| results: 'hold'

print(f'{num_1_1 = :3},\t{bool(num_1_1) = },\t{type(num_1_1) = }')
print(f'{num_1_2 = :3},\t{bool(num_1_2) = },\t{type(num_1_2) = }')
```

```{python}
num_2_1 = 0; num_2_2 = 0.0
```

```{python}
#| echo: false
#| results: 'hold'

print(f'{num_2_1 = :3},\t{bool(num_2_1) = },\t{type(num_2_1) = }')
print(f'{num_2_2 = :3},\t{bool(num_2_2) = },\t{type(num_2_2) = }')
```

###### Collections

```{python}
empty_string = ""; empty_tuple = (); empty_list = []; empty_dict = {}
```

```{python}
#| echo: false
#| results: 'hold'

print(f'{bool(empty_string) = }, {bool(empty_tuple) = }')
print(f'{bool(empty_list) = }, {bool(empty_dict) = }')
```

```{python}
non_empty_string = "abc"; non_empty_tuple = (1, 2)

non_empty_list = ["a", 1]; non_empty_dict = {"key 1": empty_list}
```

```{python}
#| echo: false
#| results: 'hold'
print(f'{bool(non_empty_string) = }, {bool(non_empty_tuple) = }')
print(f'{bool(non_empty_list) = }, {bool(non_empty_dict) = }')
```

#### Short circuit

- Short circuit is general optimization strategy used by many languages
- Main idea is to avoid evaluating unnecessary condition in an boolean combination
- `x and y`, where `x`, `y` are conditional expressions
    - if `x` is evaluated to `False` return `False` without evaluating `y`
- `x or y`, where `x`, `y` are conditional expressions
    - if `x` is evaluated to `True` return `True` without evaluating `y`

#### Execution context

- Python treats conditional expressions differently based on where they are used
- Objects can be used directly in conditional expressions
    - `bool(obj)` is used where necessary

##### `if`/`elif` conditions

- Conditional expression used in `if`/`elif` statement's condition return booleans values (`True`/`False`).

- Condition can contain object's as well
    - `bool(obj)` is used rather than object's value

##### Examples

######

In below code, since `x` is an empty list it is falsy, `bool(x) = False`, therefore `else` block is executed.

```{python}
x = []
if x:
    print("x is truthy")
else:
    print("x is falsy")
```

######

In below code, since `x` is a string, it is truthy (`bool(x) = True`), therefore `if` block is executed.

```{python}
x = "abcd"
if x:
    print("x is truthy")
else:
    print("x is falsy")
```

###### 

In below example, since `bool(x) = False`, `else` block is executed without evaluating `bool(y)`.

```{python}
x = []; y = None
if x and y:
    print("x and y returned True")
else:
    print("x was false, therefore y was not evaluated")
```

##### Outside `if`/`elif` condition

- comparisons evaluate to boolean values as usual
- combinations objects are returned
    - can be boolean or other data type

######

```{python}
x = []; y = 2
y < 5; y == 2
```

```{python}
x = []; y = 2
x and y
```

```{python}
x = []; y = 2
x or y
```

#### Summary

##### Tables

###### AND {.smaller}

```{r}
#| echo: false
#| results: 'asis'

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "bool-tbl" # name or number
package <- "pander" # hux, pander, kable

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet=sheet)

tbl_df <- tbl_df[c(1,2,3,4)]

tbl_out <- create_table(tbl_df, package = package)

print_tbl_out(tbl_out, package)
```

###### OR {.smaller}

```{r}
#| echo: false
#| results: 'asis'

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "bool-tbl" # name or number
caption <- NULL
package <- "pander" # hux, pander, kable

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet=sheet)

tbl_df <- tbl_df[c(1,2,5,6)]

tbl_out <- create_table(tbl_df, package = package)

print_tbl_out(tbl_out, package)
```

##### Specifications

###### AND {.smaller}

For `x and y`, where `x` and `y` can be variables, objects or conditions:

- evaluate `bool(x)`
    - if `bool(x)` is `True`
        - if  `x and y` is part of a condition in `if`/`elif` block - evaluate and return`bool(y)`
        - if `x and y` is not part of a condition in `if`/`elif` block - return `y`
    - if `bool(x)` is `False`
        - if  `x and y` is part of a condition in `if`/`elif` block - return `False`
        - if `x and y` is not part of a condition in `if`/`elif` block - return `x`

###### OR {.smaller}

Similarly, for `x or y`, where `x` and `y` can be variables, objects or conditions:

- evaluate `bool(x)`
    - if `bool(x)` is `True`
        - if  `x and y` is part of a condition in `if`/`elif` block - return `True`
        - if `x and y` is not part of a condition in `if`/`elif` block - return `x`
    - if `bool(x)` is `False`
        - if  `x and y` is part of a condition in `if`/`elif` block - evaluate and return`bool(y)`
        - if `x and y` is not part of a condition in `if`/`elif` block - return `y`

#### Use cases

##### Iterables

```python
some_itr =  # some iterable object
if some_itr is not None and len(some_itr) > 0:
    # code block
else:
    # code block
```

```python
some_itr =  # some iterable object
if some_itr:
    # code block
else:
    # code block
```

##### Assign default

```python
new_var = expected_var or default_object
```

- If `expected_var` is **truthy**
    - because of short circuit `or`
        - it will be returned and assigned to `new_var`
- If it is **falsy**
    - default object will be evaluated and returned

### Comprehensions

#### Overview {.smaller}

- Comprehensions are a newer feature in Python
    - combine the fundamentals of map and filter in a more concise syntax

- They are relevant for iterables, i.e. tuples, lists, sets and dictionaries

- Mostly used with lists and dictionaries.

- Generic idea is 
    - [transformation]{color="blue"} [iteration]{color="purple"} [filter]{color="red"} or
    - [expression]{color="blue"} [loop]{color="purple"} [condition]{color="red"}

- Filter/condition is optional

- Comprehensions can be nested

#### List comprehensions

- [[expression using item]{color="blue"} [for item in list]{color="purple"} [if condition on item]{color="red"}]

##### Examples

###### Without filter

- _list of squares from a list of integers_

```{python}
some_itr = list(range(10))
squared_itr = [item**2 for item in some_itr]
print(some_itr, squared_itr, sep="\n")
```

![](../../../resources/diagrams/special-features/list-comp-1.png){width="70%" fig-align="center"}

###### With filter

- _list of squares from a list of integers if integer is even_

```{python}
some_itr = tuple(range(10))
evens_squared_itr = [item**2 for item in some_itr if item % 2 == 0]
print(some_itr, evens_squared_itr, sep="\n")
```

![](../../../resources/diagrams/special-features/list-comp-2.png){width="90%" fig-align="center"}

###### Multiple iterables

- _list of sum of squares of 2 iterables of numbers_

```{python}
t_1 = (*range(1,4),); t_2 = (*range(4,7),)
sum_of_sqrs = [x**2 + y**2 for x, y in zip(t_1, t_2)]
t_1, t_2, sum_of_sqrs
```

###### Nested comprehensions

- _make all possible combinations of letters of 2 strings if they are not equal_

```{python}
string_1 = 'abc'; string_2 = 'axy'
combinations = [l1 + l2 for l1 in string_1 for l2 in string_2 if l1 != l2]
print(combinations)
```

###### {.shrink}

- For better code readability, this can be written as

```{python}
string_1 = 'abc'; string_2 = 'axy'
combinations = [l1 + l2 
                for l1 in string_1
                    for l2 in string_2
                        if l1 != l2]
print(combinations)
```

- This is same as 

```{python}
string_1 = 'abc'; string_2 = 'axy'
combinations = []
for l1 in string_1:
    for l2 in string_2:
        if l1 != l2:
            combinations.append(l1 + l2)
print(combinations)
```

#### Tuple, set, dict

##### Overview

- Tuple: use tuple constructor
- Sets & dictionaries: use curly braces

##### Examples

###### Tuple with multiple iterables

- _Tuple of sum of squares of 2 iterables of numbers_

```{python}
t_1 = (*range(1,4),); t_2 = (*range(4,7),)
sum_of_sqrs = tuple(x**2 + y**2 for x, y in zip(t_1, t_2))
t_1, t_2, sum_of_sqrs
```

###### Set

```{python}
some_set = set((1, 2, 3))
print({e**2 for e in some_set if e > 1})
```

###### Dictionary

```{python}
import string
dict_1 = dict(zip(string.ascii_letters[0:10], list(range(10))))
print(dict_1)
```

```{python}
#| results: 'hold'
dict_2 = {k: v**2 for k, v in dict_1.items() if k in {'a', 'e', 'i'}}
print(type(dict_2))
print(dict_2)
```
# Architecture

## Overview
### Background

- **Language specifications**
    - [**Building blocks**: _specifications for elements and blocks of code_]{color="blue"}
    - [ **Architecture**: _specifications for writing programs_ ]{color="brown"}
        - [means and specifications to combine elements and blocks to build programs]{color="brown"}
        - [management of execution of blocks (under the hood)]{color="brown"}
- **Design**: _knowledge of how to write good programs_
- **Tools**: _needed to write, test, debug and run programs_

### Introduction

- **Environment = Namespace + Scope**: _how to isolate and identify (variable) names and objects_
- **Scripts and packages**: _how to organize and use building blocks in scripts and folders_
- **External packages**: _overview of external packages available for use_
- **Language engine**: _overview of workings of Python interpreter_
- **Debugging**: _investigating and troubleshooting errors while writing programs_

### Objectives

- Understand the specifications related to architecture and do experiments in isolation
- Tools: use editor and cli to manage installation, scripts and projects
## Namespaces and scopes

### Introduction

#### Terminology

- The terminology related to this is not consistent
    - "environment" and "frame" are used interchangeably for the concept of "namespace" and "scope"

- Focus on understanding the concept
    - this will avoid confusion when below terms are used interchangeably

#### Namespace

A **namespace** is a **mapping** from **names (variables)** to **object references**.

- Namespaces help find and access the associated objects using variable names.

- Technically, in Python, they are dictionaries that store the mapping.

#### Scope

A **scope** is a textual region of the code which has its own separate namespace.

- This helps isolate and manage different variable names and objects used in different blocks of code.

- Many languages do this by keeping track of namespace for all blocks, e.g. control flow blocks (`if`, `for`, ...). 

- Python restricts this to just function and class/instance object blocks. Control flow blocks like `if`, `for` etc. do not have their local scopes.

#### Tools

- [Tool: Python tutor](https://pythontutor.com/python-debugger.html#mode=edit)

### Specifications

#### Basic

Below are the scopes in the order they are searched

- **Innermost scope for a function**
    - namespace contains **local names** (*only if present*)
- **Scope of enclosing functions**
    - namespace contains **non local names** (*only if present*)
- **Global scope** (scope of the module)
    - namespace contains **global names**
- **Built-in scope**
    - namespace contains **built-in names**

#### Lifetime

#####

- **Built-in** scope's namespace
    - created when the interpreter starts up
    - never deleted, exists till interpreter is terminated

- **Global** (module) scope's namespace
    - created at compile time, when the module is read for the first time
    - never deleted, exists till interpreter is terminated

##### {.smaller}

- **Local** scope's namespace for a function
    - compile time (when the definition is read)
        - local scope's namespace is not created at this stage
        - variables are tagged scopes
        - objects for default parameters are created and stored in function object
        - the function object is created in the enclosing scope's namespace
    - run time (during function call)
        - _every time function is called a new local scope's namespace is created_
        - deleted when the call terminates, i.e. on `return` or **error**

### Function scope specifications

#### Variable scopes

Scope of variables used within a function.

##### Explicit declaration

- Variables can be declared as `global` or `nonlocal`
    - `global`: variable is looked up in global name space skipping enclosing functions namespaces
    - `nonlocal`: variable is looked up only in the enclosing function scope, not in global namespace

##### Without explicit declaration

- If a **variable is assigned** within a function
    - compile time: **tagged to local scope**

- If a **variable is referenced without being assigned** within the function
    - compile time: the next level up enclosing scope is searched until builtin scope
    - compile time: **tagged to the first scope it is found in**
    - run time: **error is raised if not found**

#### Generic

- On end of function execution the function scope's namespace is deleted

- When cross referencing functions from other modules
    - the global scope for a function is the scope of the module in which it is defined
    - this will become clear after understanding modules and packages discussed in next chapter

####

::: {.center  data-latex=""}
![Scopes](../../../resources/diagrams/architecture/scopes.png){width="90%"}
:::

####

::: {.center  data-latex=""}
![Nested scopes](../../../resources/diagrams/architecture/scopes-nested.png){width="90%"}
:::

### Examples

#### `global`

```{python}
#| results: 'hold'
var = "global"

def func():
    print("inside func call var = " + var)

func()

print("in global scope var = " + var)
```

#### `local`

```{python}
#| results: 'hold'
var = "global"

def func():
    var = "local"
    print("inside func call var = " + var)

func()

print("in global scope var = " + var)
```

#### `global` with nested scopes

```{python}
#| results: 'hold'
var = "global"

def outer_func():

    def inner_func():
        print("inside inner_func call var = " + var)

    inner_func()

outer_func()

print("in global scope var = " + var)
```

#### `nonlocal` {.shrink}

```{python}
#| results: 'hold'
var = "global"

def outer_func():
    var = "nonlocal"

    def inner_func():
        nonlocal var
        print("inside inner_func call var = " + var)

    inner_func()
    print("inside outer_func call var = " + var)

outer_func()

print("in global scope var = " + var)
```

#### Declaring `global` in nested scopes {.shrink}

```{python}
#| results: 'hold'
var = "global"

def outer_func():
    var = "nonlocal"

    def inner_func():
        global var
        print("inside inner_func call var = " + var)

    inner_func()
    print("inside outer_func call var = " + var)

outer_func()

print("in global scope var = " + var)
```

### Use cases

:::: {layout="[[45,-10,45]]"}

::: {.div data-latex="{}"}
- Basic use cases
    - avoiding errors
    - resolving errors
    - understand code
:::

::: {.div data-latex="{}"}
- Advanced use cases
    - implementing design patterns
        - factory functions
        - decorators
        - generators
    - solutions to more complex problems
:::

::::

## Modules & Packages

### Introduction

#### Background

- Python repl does not offer saving and repeating code.
    - All the work is gone once the repl is closed.
    
- Jupyter notebooks are good for interactive tasks but not useful for large programs.

- Scripts provide additional functionality.
    - Save and run large programs from command line
    - Save and re use definitions, like variables, functions and classes, related to a task
        - e.g. standard library, external modules and packages

- Packages help organizing scripts for large projects

#### Resources

Python documentation on modules and packages

- [Python tutorial: Modules & Packages](https://docs.python.org/3/tutorial/modules.html#modules)
- [Python reference: `__main__`](https://docs.python.org/3/library/__main__.html)
- [Python reference: Import system](https://docs.python.org/3/reference/import.html?highlight=namespace#the-import-system)
- Namespace packages
    - [Python reference](https://docs.python.org/3/reference/import.html?highlight=namespace#namespace-packages)
    - [PEP 420](https://peps.python.org/pep-0420/)

### Module

#### Terminology

In Python a module can refer to several different things.

- Commonly module refers to a file with `.py` extension.
- Packages are special type of modules, but referred to as packages explicitly
- `module` is also a `type` or `class`
- Python object once the module file or a package is loaded using `import`
    - instance object of `type` `module`

#### Module objects

There are 3 cases when module type object is created using import in Python

- *file*: a file or script containing Python code
- *package*: a folder containing sub-folders and scripts
    - *regular* package: declared using `__init__.py` file
    - *namespace* package

### Regular package

- Any folder with a `__init__.py` file, even if empty, is treated as a **regular package**.

- Packages provide a way to organize and exchange code as they can contain packages (sub-packages) and file type modules.

- Optionally, a regular package can also contain a `__main__.py` file, this is run when the package is run as the top level environment.

- Cross referencing between modules in sub packages using relative imports.

### Naming

####

**Convention**: lower snake case

**Rule**: names containing special characters other than `_` give error, essentially same rules as for variable names

#### Pep-8 Conventions {.fragile .smaller}

```{r}
#| output: asis
#| echo: false
#| cache: false

tables_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "pep-8-conventions"
package <- "hux" # hux, pander, kable

df <- readxl::read_excel(here::here(tables_file_path), sheet=sheet)

tbl <- create_table(df[c(1,2),], package = package, apply_theme = TRUE)

print_tbl_out(tbl, package)
```

### Usage

There are 2 main uses of modules and packages.

- Execution as top level environment  
   Python `'__main__'` system manages this
- Organizing and cross referencing objects  
   Python `import` system manages this

#### `__main__`

- Manages the run time behavior of modules and packages
- Only run when a module or package is run as top level, i.e. directly
    - `python3 -m <module or package name>`
        - works when in the same directory as the module or package
        - module name is used without `.py` extension
    - `python3 <module or package path>`
        - full path includes `.py` extension for files

##### Modules

When a module is run directly as top level environment

- `__name__` is set to `'__main__'`
- all code is run
- the code is isolated using `if __name__ = '__main__'` block
    - the code is not run with `import`

##### Regular packages

When a package is run directly as top level environment

- `__name__` is set to `'__main__'`
- all code is run
- the code is isolated using `__main__.py` file
    - the code is not run with `import`
- `if __name__ = '__main__'` block not used
    - gives error if present in `__init__.py` or `__main__.py`

#### `import` system

##### Introduction {.smaller}

- Helps manage using object definitions (variables, functions, classes) from other scripts.
- It loads the file or package as a module type object with access to exported objects
- Python assigns values to some special attributes under the hood
    - `<module name>.__name__`: module's name or `__main__` if run directly
    - `<module name>.__file__`: absolute path to the module location
    - `<module name>.__package__`: is populated if is a regular package or a part of one, else is empty string
    - `<module name>.__path__`: exists if module is a regular package or is part of one, else gives error

##### Modules

Full module (file or package) can be imported using below statements.

- `import <module name>`
- `import <module name> as <module alias>`

##### Objects & sub-modules {.smaller}

- `from <module_name> import <object_name>`
    - `from <module name> import *`
    - `from <module name> import <object name>`
    - `from <module name> import <sub module name>`
    - `from <module name> import <object name> as <object alias>`
    - `from <module name> import <sub module name> as <module alias>`

- `from <module name> import *` is not recommended when using other packages
    - it pollutes the namespace
    - creates name clashes
    - `<module name>.<obj name>` is better for code readability  
      It is provides information about source of the object used

##### Runtime behavior {.smaller}

Whenever a file or package type module is imported the following things happen

- Python interpreter checks if the module/package is already loaded into current namespace
    - if the module/package is loaded
        - nothing is done
    - if the module/package is not loaded
        - Python interpreter runs the code in module or `__init__.py` for a package
        - main code is not run
        - all the exported objects are loaded

- When only a sub package is imported Python still loads the parent package
    - therefore there is no efficiency gain if only a sub package is imported

### Applications

#### 

A Python project might be intended to do one or both type of below tasks.

- Perform some task[s] by running a script as top level environment
- Create a package to define objects (functions, classes, data-objects, ...) for re-use and sharing

#### 

Below are the use cases with recommendations.

- **Adhoc and small projects**: jupyter notebooks are sufficient most of the times.

- For **adhoc and large projects** modules may be needed.
    - If the size of code grows, it is useful to organize the code using regular packages.

- For **recurring tasks** it makes sense to use modules which can be run from command line.
    - If the size of code grows, it is useful to organize the code using regular packages.

#### Small projects

#####

- `main.py` to run the task from top level
    - it refers to function definitions and input objects from other modules as described below
    - it is a convention to name this file as `app.py` or `main.py`
- `category_1.py`, `category_2.py`, ... contain all functions for a category of tasks
- `inputs.py` contains all inputs required for configuration

#####

- project root
    - `main.py`
    - `inputs.py`
    - `category_1.py`
    - `category_2.py`

#### Large projects

- Use regular packages
    - categorizing into sub packages
    - relative imports for cross referencing
    - controlling exports

## Available Modules & Packages

### Introduction

- Modules and packages allow code re-use and distribution

- There are several modules and packages available
    - provide definitions (functions, constants, classes) for a variety of use cases

- There are 3 main resources for using external modules and packages for use in Python code.
    - Built-in
    - Python standard library
    - PyPI: Python package index

### Built-in

- These are built-in objects that are always available
- They are loaded by default
    - do not need the use of `import`
- Categories
    - [built-in **functions**](https://docs.python.org/3/library/functions.html)
    - [built-in **constants**](https://docs.python.org/3/library/constants.html)
    - [built-in **types**](https://docs.python.org/3/library/stdtypes.html)
    - [built-in **Exceptions**](https://docs.python.org/3/library/exceptions.html)

### Standard library {#sec-std-lib}

- Large collection of modules and packages provided by Python
- These have to be loaded using `import`
    - not loaded by default like the built-in objects
- Some of these, like `math` and `sys`, are written in `C` for speed
- [Library reference](https://docs.python.org/3/library/index.html)

#### Frequently used modules

```{r}
#| echo: false
#| output: asis
#| cache: false

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "std-library" # name or number
package <- "hux" # hux, pander, kable

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet=sheet)
tbl_df <- tbl_df[tbl_df$include == TRUE, ][1:3]

tbl <- create_table(tbl_df, package = package, apply_theme = TRUE) |>
    huxtable::merge_repeated_rows(col = c(1)) |>
    huxtable::set_col_width(value = c(.4, .1, .5)) |>
    huxtable::set_bold(col = c(1), value = TRUE) |>
    huxtable::set_text_color(row = -1, col = c(2), value = "purple") |>
    huxtable::set_bottom_border(TRUE) |>
    huxtable::set_markdown(row = 1, value = FALSE)
```

##### {.fragile .smaller}

```{r}
#| echo: false
#| output: asis
#| cache: false

print_tbl_out(tbl[c(1:5),], package)
```

##### {.fragile .smaller}

```{r}
#| echo: false
#| output: asis
#| cache: false

print_tbl_out(tbl[c(1, 6:9),], package)
```

##### {.fragile .smaller}

```{r}
#| echo: false
#| output: asis
#| cache: false

print_tbl_out(tbl[c(1, 10:15),], package)
```

##### {.fragile .smaller}

```{r}
#| echo: false
#| output: asis
#| cache: false

print_tbl_out(tbl[c(1, 16:20),], package)
```

### Python package index (PyPI)

- [`PyPI`](https://pypi.org/) handles open source contributions to the language
- External packages which have to be installed before they can be loaded using`import`
- [`pip`](https://pip.pypa.io/en/stable/) is the installer for external packages on `PyPI`

#### Some important packages

```{r}
#| echo: false
#| output: asis
#| cache: false

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "ext-library" # name or number
package <- "hux" # hux, pander, kable

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet=sheet)

tbl <- create_table(tbl_df, package = package, apply_theme = TRUE) |>
    huxtable::merge_repeated_rows(col = c(1)) |>
    huxtable::set_valign(col = 1, value = "top") |>
    huxtable::set_col_width(value = c(.4, .1, .5)) |>
    huxtable::set_bold(col = c(1), value = TRUE) |>
    huxtable::set_col_width(value = c(.3, .3, .4))
```

##### {.fragile .smaller}

```{r}
#| echo: false
#| output: asis
#| cache: false

print_tbl_out(tbl[c(1, 2, 3, 6),], package)
```

##### {.fragile .shrink .smaller}

```{r}
#| echo: false
#| output: asis
#| cache: false

print_tbl_out(tbl[c(1, 4, 5, 7, 8),], package)
```

### Virtual Environments

#### Introduction

- Keep installation of external packages organized for different tasks
- Keep track and manage version requirements for external packages needed for specific projects
- [Python docs: venv](https://docs.python.org/3/library/venv.html)

#### Why use a virtual env?

- The external packages keep releasing new versions for bug fixes, enhancements and new features

- Latest version might no longer support a feature that the project code needed

- Conflict between dependencies of different project's

- Some projects might need a specific version of Python itself

- There might be some packages which are needed for one time tasks

#### Usage

##### How to create a virtual environment?

- `venv` module is part of standard library and can be used with bash commands
- Linux/Mac: `python3 -m venv <path to new venv>`
- Windows: `py [-v] venv <path to new venv>`
- It is recommended to use Python version in bash commands, while creating and restoring `venv`

##### How to activate `venv` using bash?

- Linux/Mac:
    - `source <venv path>/bin/activate`
- Windows:
    - `source <venv path>/Scripts/activate`
- Editors, like VSCode, allow to select Python interpreter for running a project
    - `venv` can be set to be activated by default

#### Project dependencies {.smaller}

- `venv` along with `pip` can be used to manage project dependencies

- `venv` keeps installed packages isolated in a virtual environment

- `pip` is used to create a list of required external modules installed in `venv`
    - windows: `py [-v] -m pip freeze > py-requirements.txt`
    - unix/mac: `python3 -m pip freeze > py-requirements.txt`
    - version dependencies can be managed as well

- `pip` is used to re-create `venv` by installing required external modules contained in `<py-requirements.txt>` file in `venv`
    - windows: `py [-v] -m pip install -r py-requirements.txt`
    - unix/mac: `python3 -m pip install -r py-requirements.txt`

- Resources: [pip user guide](https://pip.pypa.io/en/stable/user_guide/)

#### Structuring `venv`'s

##### Options {.smaller}

- **Centralized approach**: keep all virtual environments in a central location
    - related projects can share virtual environments
    - typically location is `$HOME/.venvs/<name of venv>`
- **De-centralized approach**: each project has its own virtual environment
    - simple but effective as there is no need to manage conflicts
    - similar projects can be grouped in a root directory with a common `venv` if needed

> Given the amount of memory used by virtual environments and simplicity of management, de-centralized approach makes more sense unless there is a specific reason.

##### Example {.smaller}

- project root
    - **.git/**
    - **.py-venv/**
    - **docs/**
    - `main.py`
    - `inputs.py`
    - `category_1_funcs.py`
    - `category_2_funcs.py`
    - `py-requirements.txt`
    - `.gitignore`

## Language engine
### Overview

- [Official implementation of Python](https://www.python.org/) is an **interpreter written in C**, and therefore also referred to as **CPython**

- Below terms refer to this
    - Python interpreter
    - CPython
    - CPython interpreter

#### How is program executed

##### 

- The interpreter checks the conditions for .py file
    - is .py file a new file
    - is .py file modified since last compilation
    - was .pyc file written using an older Python version
- If any of the conditions is true then .py file is compiled to .pyc file (byte code)
- Byte code is converted to machine code and sent for processing

##### 

![](../../../resources/diagrams/architecture/python-interpreter.png)

##### Under the hood

Below is an introductory overview of things that happen under the hood which interpreter handles.

- **Managing execution**: sending and receiving of operations and data, to and from the processor
- **Garbage collection**: clearing un used objects created during execution
- **Threads and processes**: python interpreter uses single thread and single core at a time by default

### Hardware Management

#### Layers {.smaller}

1. **Hardware**: CPU controls all the different components. It understands only machine code (binary).
2. **Operating system (OS)**: is the first major layer on top of hardware that controls all programs or applications interacting with the hardware.
3. **Programs**: also referred to as _computer applications_ or just _applications_. This is the final layer offering specific interactions with the hardware. These have to go through the OS to finally send and receive instructions to and from hardware. Some examples include
    - **file explorer**: provides a graphical interface to interact with the file system stored on hard disk. It displays the information on monitor and provides interaction through mouse and keyboard events.
    - **browser**: provides a graphical user interface (gui) to interact with the data on the web. In the background it sends and receives data through network adapter and displays it on monitor.
    - **network**: there are network processes always running in the background to keep the machine connected to web and internal networks

##### Python interpreter {.smaller}

- OS
    - starts process[es] requested by Python interpreter
    - allocates space on RAM for these process[es] using some algorithm
    - manages sending/receiving data and instructions to/from CPU received from all running processes
- Python interpreter
    - sends/receives data and instructions to/from CPU through OS
    - loads all the resources needed to run the program from hard disk to RAM
    - manages the usage of allocated space on RAM
- CPU
    - does all the processing
    - manages all the data and instructions received from OS
    - sends back the results to OS

##### Resources

There are 2 critical resources that a program has to manage:

- Memory (RAM)
- Processor (CPU)

Python being a very high level language, manages both these automatically in background

#### Memory (RAM)

#####

![](../../../resources/diagrams/architecture/ram-usage.png){width="70%" fig-align="center"}

#####

{{< include ../../../resources/tables/_architecture-stack-heap.qmd >}}

##### Stack

- Stack is the component of memory used for program execution
- It is modeled as stack data structure, like a book stack, **LIFO**
- The code instructions and variable names are sent to the stack as the program is read
    - deleted when the instruction completes.

- **Stack overflow**: when stack gets full
    - e.g. infinite recursive function call, ~ 3000 calls before stack overflow

- **Stack trace**: history of instructions

##### Heap

- Heap is the part of allocated memory which is used for storing objects
- Heap functions like RAM, random memory addresses can be accessed
- Garbage collection

#### Processor management {.smaller}

Managing the CPU through program is considered as one of the most complex topics in programming as it involves understanding multiple topics

- CPU: how CPU processes data and instructions sent to it
- OS: how does OS schedules and manages tasks from all running processes
- Program: what features the programming language provides to handle execution of different tasks in a program

For regular use of programming there is not much requirement to increase performance by designing the program. This is needed when building large and advanced applications.

##### Python interpreter

- Python interpreter, by default, starts a single process with 1 main thread while running a program.

- Python has Global interpreter lock (GIL) which limits execution of one thread at a time

## Error handling (Debugging)

### Introduction

#### Terminology

- Bugs & Debugging

#### Overview {.smaller}

- Control flow: handling expected errors through code
- Debugging: investigating errors while writing code
    - **trace back**
    - **debugger**
- Testing: automate testing for reuse
    - **Unit tests**: Automating testing of small pieces of code
    - **Integration tests**: Automating testing of combination of pieces working together
    - **Resources**
        - Python standard library: [`unittest`](https://docs.python.org/3/library/unittest.html#module-unittest)
        - PyPI package: [`pytest`](https://docs.pytest.org/)

### Error types {.smaller}

- **Lexical and syntax errors**: these are easily caught by the editor tools like linter and style checkers
- **Semantic errors**: when some rules of implementation details are violated
    - e.g. passing a string to function when number was required
    - some common type of errors are caught by the editor tools, but not all
- **Incorrect logic**: No error but the solution is incorrect
    - e.g. while using nested loops the order of loop matters

#### Tools

##### Overview

- Preventive
    - [Editing tools](https://code.visualstudio.com/docs/python/editing): syntax highlighting, auto completion, refactoring, etc.
    - [Lint tools](https://code.visualstudio.com/docs/python/linting): semantic errors to some extent

- Investigative
    - **Exceptions & trace back**
    - **Debugger**

##### Exceptions & trace back

- They contain 2 key information
    - Exception type
    - Trace back: also called stack trace, stack traceback, stack backtrace etc.
        - history of execution instructions sent which caused the error

- Error message in Python
    - Where the error occurred
    - Type of error if it is a known type

###### Order of traceback

- Starts from the bottom
    - it tells where the error occurred
- Traces back where the call to this error originated from

###### Traceback example

```{python}
#| code-line-numbers: true
#| eval: false
some_list = [1, 2]

def f1(): some_list.pop()
def f2():
    for i in range(3):
        f1()

f2()
```

###### Traceback example {.shrink}

```python

IndexError                                Traceback (most recent call last)
Cell In[1], line 8
      5     for i in range(3):
      6         f1()

Cell In[1], line 6, in f2()
      4 def f2():
      5     for i in range(3):

Cell In[1], line 3, in f1()

IndexError: pop from empty list
```

##### Debugger

######

- Python interpreter, like most languages, provides a set of tools for debugging
    - collectively referred to as debugger
    - special set of commands which can interrupt the interpreter at given point saving the state of stack and heap and provide interactive execution options

######

- VSCode, like most editors, integrates this functionality in the editor
    - [VSCode: Python tutorial: Debugging](https://code.visualstudio.com/docs/python/python-tutorial#_configure-and-run-the-debugger)

# Design

## Design: Overview

### Motivation {.smaller}

- Growth in scale and complexity of programs
- Skill that makes a good programmer
    - writing **a program** to solve a problem
    - writing **a good program**
- Requires knowledge and practice

#### Recommended properties of a good program

- **Readable**: easy to read and understand
- **Testable**: safe from errors, easy to test even after making changes
- **Modular**: responsibilities are separated out into small independent blocks
- **Extensible**: easy to extend functionality with little change in existing code
- **Efficient**: in terms of speed and memory

### Overview {.smaller}

1. Design **components of programs**
    - [**Design patterns**]{color="Salmon"}
    - [**Data structures & Algorithms (DSA)**]{color="brown"}
    - [**Regular expressions**]{color="brown"}
    - **Testing**
    - **Documentation**
        - **Specifications**
1. Design **structure of programs** (**Frameworks**)
1. Design **process of creating programs** ([**Workflow**]{color="Salmon"})
    - **Software requirement analysis**
    - **Refactoring**

### Objectives

- It gives more context when using existing solutions from developers.
- It allows to benefit from best practices by using them early.
- It provides opportunity to apply and practice some of components in small code.
    - This should help those who happen to pursue programming to advanced levels.

### Design patterns

#### Definition {.smaller}

::: {.definition data-latex="{}"}
Design patterns are abstraction of ways to organize building blocks using the language specifications and architecture to improve properties of a program. Typically a given pattern improves a subset of properties.
:::

::: {.definition data-latex="{}"}
There are 2 distinct dimensions

- abstraction of common programming tasks
- abstraction of good patterns to implement those tasks
:::

##### Design patterns in Python

- **Map-reduce**
- **Iterators**
- **Generators**
- **Decorators**
- **Context managers**
- **Advanced OOP**
- **Meta-programming**

## Data structures & Algorithms (DSA)

### Introduction

::: {.block data-latex="{}"}
**Data structures and algorithms**, referred to as **DSA**, is an advanced topic in computer science.
:::

#### Background

##### Macro level {.smaller}

- Data and correspondingly requirement for data analysis is growing rapidly

- Application speed depends heavily on data storage and operations
    - Efficiency in context of speed is one of the most needed property of a computer program

- There are multiple ways to improve efficiency
    - Hardware: faster CPU, which is hitting a boundary
    - Program Design: concurrency, multi-threading, multi-processing, async-io
    - DSA: has been instrumental in increased performance of applications

##### Micro level {.smaller}

- A program instructs CPU to perform operations which take time.
    - load data into RAM
    - fetch data from RAM
    - operate on data
    - write data onto RAM

- The scale of these operations is very large
    - e.g. simple program to do data analysis

- DSA helps reduce these operations to improve performance

##### Current state

- Many languages, including Python, provide basic data structures by default
- Some languages, like C, leave it to the programmer

##### Applications {.smaller}

- Basic user of programming
    - know basic data structures and algorithms
    - match the right data structures to situations
- Advanced user of programming
    - know advanced data structure and algorithms
    - implement a data structure if required
- Research: Computer science & engineering
    - research on DSA
    - rigorous math involved
    - main challenges
        - find optimal solutions in terms of speed and design to the ever expanding field of data
        - prove and communicate the solutions

#### Objectives

- Present and introduce some of the core results
- Explain context and intuition behind the developments in the field
- This should help
    - Everyone: during usage of these concepts in writing programs
    - Someone whose target is to get into software development
        - lay foundation for advanced study of the topic

#### Overview {.smaller}

The study of data structures and algorithms can be summarized as below.

- **Problem specification**: **interface**
    - specification for **structure** of data
    - specification for **operations** needed to be performed on data
- **Solution**/**implementation**
    - **data structure**: implementation of how to store the data with given structure
    - **algorithms**: implementation of how to perform operations for a given data structure
- **Measuring efficiency**
    - **asymptotic notation**
    - **computation model**: **WordRAM** model

#####

- Choosing the data structure depends on use case
    - how data is to be structured?
    - which type of operations are to be performed?
    - how frequently?

- The choice of data structure decides available algorithms for different operations implemented for a data structure

#### Interface vs data structure {.fragile .smaller}

```{r}
#| echo: false
#| output: asis
#| cache: false

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "dsa-1" # name or number
### col_names <- c("", "Interface", "Data structure") # default, NULL or custom
package <- "hux" # hux, pander, kable

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet = sheet)
tbl_df <- tbl_df[2:3]

tbl_out <- create_table(tbl_df, package = package, apply_theme = TRUE) |>
    huxtable::theme_compact() |>
    huxtable::set_bottom_border(TRUE)

print_tbl_out(tbl_out, package)
```

### Measuring efficiency

There are 2 major costs involved while using a data structure

- **time** taken to perform operations
- **memory** (**space**) used on **RAM**

Measuring time and memory usage depends on 2 factors

- computation model (hardware)
- how the data structure uses this model

#### Computation model

::: {.block data-latex="{}"}
Computational model refers to abstracting hardware performance in general terms to study the behavior of different operations to be performed. Typically *word RAM* model is used in theoretical studies. In practice it may differ.
:::

- Implication of assumptions in *word RAM* model are that all elementary operations take constant amount of time
    - read, write, delete in RAM for a location
    - mathematical operations
    - logical operations

#### Measuring time

##### Context

Time complexity of an algorithm can be measured in different ways based on different contexts.

- how the time complexity is measured?
    - measure time to run the algorithm
    - **measure operations performed and how they grow with size of data structure**

- what time is captured?
    - best case time
    - average time
    - **worst case**

###### {.smaller}

- Measuring time directly has following disadvantages
    - it depends on the quality of machine
        - tests can be run on various machines but that is inefficient
        - testing a slow algorithm on very fast machine leads to false conclusions
    - it depends on size of data
        - tests can be run on different data sizes but it is difficult to test for very large sizes

- It is more useful to measure time in terms of operations performed and then see how they grow with size of data.
    - Using this approach isolates dependency on machine.

###### 

- Using **best case time** might give false results
    - an algorithm might be fast on small data size but perform slow on large data size

- Using **average time** will give more information
    - probability distribution is needed to decide which data sizes will be used more frequently
    - not feasible

- **Worst case time** is used
    - ensures bound on performance and reduces noise in comparing performance of different algorithms

##### Solution

::: {.block data-latex="{}"}
Time complexity is measured for **worst case** performance, using **asymptotic notation** for **number of operations performed depending on data size**, usually represented with $n$.
:::

##### Asymptotic notation {.smaller}

::: {.block data-latex="{}"}
Asymptotic notation is used to get an idea of asymptotic growth ignoring scaling factors and constants.

More formally, asymptotic notation represents a set of functions.
:::

- how the growth of a function behaves when the underlying variable grows too large

- E.g.
    - if the the performance of an algorithm for a data structure takes the form $T(n) = 3n^2$
    - what is the growth in value of $T(n)$ as $n \to \infty$
    - where $T(n)$ is the time the algorithm takes and $n$ is the size of data structure

###### {.fragile .smaller}

```{r}
#| echo: false
#| output: asis
#| cache: false

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "asymptotics" # name or number
package <- "hux"

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet=sheet)
tbl_out <- create_table(tbl_df, package = package) |>
    huxtable::set_markdown(col = 2, value = FALSE) |>
    huxtable::set_escape_contents(col = 2, value = FALSE) |>
    huxtable::set_text_color(row = c(3,5), value = "brown") |>
    huxtable::theme_article() |>
    huxtable::set_width(1) |>
    huxtable::theme_compact() |>
    huxtable::set_bottom_border(TRUE)
print_tbl_out(tbl_out, package)
```

- Theta and Big O are mostly used in measuring complexity.

- The notation is some times used as $f(n) = O(g(n))$ but it is more accurate to use $f(n) \in O(g(n))$ as $O(g(n))$ denotes a collection of functions.

###### Definitions

::: {.block data-latex="{}"}
####### O Notation

A non-negative function $f(n)$ is in $O(g(n))$ if and only if there exist constants $c, n_0 \in \mathbb{R}$ such that $f(n) \le c \cdot g(n) \quad \forall \ n > n_0$.
:::

::: {.block data-latex="{}"}
####### Omega Notation

A non-negative function $f(n)$ is in $\Omega(g(n))$ if and only if there exist constants $c, n_0 \in \mathbb{R}$ such that $f(n) \ge c \cdot g(n) \quad \forall \ n > n_0$.
:::

::: {.block data-latex="{}"}
####### Theta Notation

A non-negative function $f(n)$ is in $\Theta(g(n))$ if and only if $f(n) \in (O(g(n)) \cap \Omega(g(n)))$.
:::

###### Example

For example, if it is concluded that number of operations in an algorithm is given by the function $T(n) = 3n^2 + 4n+ 2$ then $T(n) \in \Theta(n^2)$.

Theta notation allows for stating complexity in simpler terms ignoring scaling and constant factors.

Plots show how the $n^2$ term dominates as n grows larger.

###### Plot

```{r}
#| echo: false
#| warning: false

func_list <- list(
    c("3*x^2 + 4*x + 2", "3*n^2 + 4*n + 2"),
    c("x^2", "n^2"),
    c("3*x^2", "3*n^2"),
    c("4*x + 2", "4*n + 2")
)

plt_function(
    func = func_list, x_min = 0, x_max = 20, y_min = 0, xlab = "n"
)

```

###### Plot

```{r}
#| echo: false
#| warning: false

plt_function(
    func = func_list, x_min = 0, x_max = 100, y_min = 0, xlab = "n"
)
```

###### Plot

```{r}
#| echo: false
#| warning: false

plt_function(
    func = func_list, x_min = 0, x_max = 10^3, y_min = 0, xlab = "n"
)
```

###### Plot

```{r}
#| echo: false
#| warning: false

plt_function(
    func = func_list, x_min = 0, x_max = 10^6, y_min = 0, xlab = "n"
)
```

###### {.fragile}

In terms of efficiency of algorithms it is often desired to keep the complexity low.

Below are the common functions which complexity takes in increasing order.

Anything below linear is considered good.

```{r "theta order"}
#| echo: false
#| output: asis
#| cache: false

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "theta-order" # name or number
package <- "hux" # hux, pander, kable

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet=sheet)

tbl_out <- create_table(tbl_df, package = package, apply_theme = TRUE) |>
    huxtable::set_text_color(row = 2, col = c(1,2), value = "darkgreen") |>
    huxtable::set_text_color(row = 2, col = c(3), value = "orange") |>
    huxtable::set_text_color(row = 2, col = c(4), value = "brown") |>
    huxtable::set_text_color(row = 2, col = c(5,6), value = "red") |>
    huxtable::set_markdown(FALSE) |>
    huxtable::set_escape_contents(FALSE) |>
    huxtable::set_width(1)

print_tbl_out(tbl_out, package)
```

###### Summary

```{r}
#| echo: false
#| warning: false

func_list = list(
    c("1", "1"),
    c("log2(x)", "log2(n)"),
    c("x", "n"),
    c("x^2", "n^2"),
    c("x^3", "n^3"),
    c("2^x", "2^n")
)
plt_function(
    func = func_list, x_min=0, x_max=20, y_min=0, y_max=25, linewidth = .6,
    xlab = "n"
)
```

### Interfaces

#### Introduction

Interface provides the abstract or theoretical requirements of storing and operating on certain type of data.

For example, tuple, list or dictionary is used depending on the use case.

Abstraction and generalization of use cases is interface. Tuple, list and dictionary are the implementation or data structures.

##### Terminology

Interfaces are also referred to as 

- Application programming interface (**API**): by developers
- Abstract data type (**ADT**): by computer scientists

##### Types

There are 2 main types of interfaces.

- sequence
- mapping

###### Sequence

- **Extrinsic order**: order of items provided externally is preserved
- Special sequence types
    - **stack**: insert last and delete last (LIFO: last in first out)
    - **queue**: insert last and delete first (FIFO: first in first out)
    - **dequeue** (aka deque, double-ended queue)

###### Mapping

- **Mapping** (also referred to as **set**, **associative array**)
    - **Intrinsic order**: items identified by unique keys, keys can optionally be stored in order
    - Types of mapping types
        - **set**: items are keys themselves
        - **dictionary**: items are associated with keys

#### Operations {.smaller}

Operations on major interfaces can be categorized into 3 basic types

- **container operations**: operations on container itself
    - e.g. build, length
- **static operations**: operations on elements that do not alter the container
    - e.g. search (query) operations on elements by index (sequence) or value (mapping)
- **dynamic operations**: operations on elements that alter the container itself
    - e.g. inserting, deleting elements

##### Sequence interface {.fragile .shrink .smaller}

```{r}
#| echo: false
#| output: asis
#| cache: false

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "dsa-seq-ops" # name or number
package <- "hux" # hux, pander, kable

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet = sheet)

tbl_out <- create_table(tbl_df, package = package, apply_theme = TRUE) |>
    huxtable::set_bold(col = c(1), value = TRUE) |>
    huxtable::set_col_width(c(.15, .15, .7)) |>
    huxtable::theme_compact() |>
    huxtable::set_font_size(value = 14) |>
    huxtable::set_bottom_border(TRUE)

print_tbl_out(tbl_out, package)
```

##### Map interface {.fragile .smaller .shrink}

```{r}
#| echo: false
#| output: asis
#| cache: false

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "dsa-set-ops" # name or number
package <- "hux" # hux, pander, kable

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet = sheet)

tbl_out <- create_table(tbl_df, package = package, apply_theme = TRUE) |>
    huxtable::set_bold(col = c(1), value = TRUE) |>
    huxtable::set_col_width(c(.15, .15, .7)) |>
    huxtable::theme_compact() |>
    huxtable::set_font_size(value = 16) |>
    huxtable::set_bottom_border(TRUE)

print_tbl_out(tbl_out, package)
```

### Data structures

```{r}
#| include: false

### header and footer for 2 tables below
if (knitr::is_html_output()) {
    tmp <- c("", "Operations - $O(\\cdot)$" = 5)
    hdr_seq <- c("", "Sequence interface operations - $O(\\cdot)$" = 5)
    hdr_map <- c("", "Map interface operations - $O(\\cdot)$" = 5)
    fn <- paste0(
        "$\\cdot_{(a)}$ implies amortized, ",
        "$\\cdot_{(e)}$ implies expected, ",
        "h is height of the tree"
    )
} else {
    tmp <- c("", "Operations - $O(\\\\cdot)$" = 5)
    hdr_seq <- c("", "Sequence interface operations - $O(\\\\cdot)$" = 5)
    hdr_map <- c("", "Map interface operations - $O(\\\\cdot)$" = 5)
    fn <- paste0(
        "$\\\\cdot_{(a)}$ implies amortized, ",
        "$\\\\cdot_{(e)}$ implies expected, ",
        "h is height of the tree"
    )
}

cl = list()
cl$red <- "#efcbcb"
cl$amber <- "#f0d2c0"
cl$green <- "#e0e6cd"
```

```{r}
#| include: false

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "dsa-ds-seq" # name or number
package_seq <- "kable" # hux, pander, kable

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet=sheet)
tbl_df_seq <- tbl_df[2:ncol(tbl_df)]

create_table_seq <- function(tbl_df, pkg = package_seq) {
    tbl_out_seq <- tbl_df |>
        create_table(package = package_seq, apply_theme = FALSE) |>
        kableExtra::kable_styling(
            bootstrap_options = c("hover", "condensed", "responsive"),
            latex_options = c("HOLD_position", "scale_down"),
            full_width = FALSE
        ) |>
        kableExtra::add_header_above(c(" ", "Build", "Static", "Dynamic" = 3)) |>
        kableExtra::add_header_above(hdr_seq, escape = FALSE) |>
        kableExtra::footnote(general = fn, escape = FALSE) |>
        clrz_ptrn_kbl(df_ = tbl_df, cols_ = 2:6, ptrns_ = c("1|^log n", "^h"),
            colors_ = c(cl$green, cl$amber), default_color = cl$red)
}

tbl_out_seq <- create_table_seq(tbl_df_seq)
```

```{r}
#| include: false

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "dsa-ds-map" # name or number
package_map <- "kable" # hux, pander, kable

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet=sheet)
tbl_df_map <- tbl_df[2:ncol(tbl_df)]

create_table_map <- function(tbl_df, pkg = package_map) {
    tbl_out_map <- tbl_df |>
        create_table(package = package_map, apply_theme = FALSE) |>
        kableExtra::kable_styling(
            bootstrap_options = c("hover", "condensed", "responsive"),
            latex_options = c("HOLD_position", "scale_down"),
            full_width = FALSE
        ) |>
        kableExtra::add_header_above(c(" ", "Build", "Static", "Dynamic",
            "Order" = 2)) |>
        kableExtra::add_header_above(hdr_map, escape = FALSE) |>
        kableExtra::footnote(general = fn, escape = FALSE) |>
        clrz_ptrn_kbl(df_ = tbl_df, cols_ = 2:6, ptrns_ = c("1|^log n", "^h"),
            colors_ = c(cl$green, cl$amber), default_color = cl$red)
}
tbl_out_map <- create_table_map(tbl_df_map)
```

#### Overview

##### Introduction

- Data structures are the actual implementations of interfaces.

- There is no single data structure that solves all operations required in an interface efficiently.

- Different data structures solve a subset of operations efficiently.

##### Types

Below are main types of data structures

- *array based*: **static array**, **dynamic array**
- *pointer based*: **linked list** (w[/o] tail), **doubly linked list** (w[/o] tail)
- **hash table** (*array and pointer mixed*)
- *graph based*: **binary search tree**, **AVL tree**, ...

#### Static array

##### Introduction

- Random access memory (RAM) of computer hardware is like a giant continuous slots of memory addresses.

- A static array finds and stores data in contiguous slots of equal size, depending on the size of data elements.

- The order is extrinsic, i.e. the items are stored in the order provided.

![](../../../resources/diagrams/dsa/static-array-2.png)

###### Operations

The static array object then needs to contain only the start memory address and length of the array.

- static operations: constant time ($\Theta(1)$)
    - memory address(i) = memory address(0) + i * item storage size
- dynamic operations: linear time ($\Theta(n)$)

![](../../../resources/diagrams/dsa/static-array-2.png)

##### Python tuples

- Python tuples are approximately static array

- One main difference is tuples are immutable, i.e. modification operations are not supported, a new object is created on modification.

##### Performance

- Static arrays are efficient for sequences with static operations only.

- For dynamic operations, in the worst case new contiguous slot of free memory has to be looked and container has to be build, therefore it is $O(n)$ operations.

###### Performance {.shrink .smaller}

```{r}
#| echo: false
#| output: asis

tbl_df_seq[tbl_df_seq[1] == "array", ] |>
    create_table_seq() |>
    print_tbl_out(package = package_seq)
```

```{r}
#| echo: false
#| output: asis

tbl_df_map[tbl_df_seq[1] == "array", ] |>
    create_table_map() |>
    print_tbl_out(package = package_map)
```

#### Linked list

##### Singly linked list without tail {.shrink .smaller}

::::::::: {layout="[[49,-2,49]]"}
:::::: {data-latex=""}
- random slots alloted
- object stores the
    - head memory address
    - len
- each node stores
    - item
    - link to next nodes memory address
::::::
:::::: {data-latex=""}
- static operations: linear time ($\Theta(n)$)
- dynamic operations
    - insert/delete first: constant time ($\Theta(1)$)
    - other: linear time ($\Theta(n)$)
::::::
:::::::::

![](../../../resources/diagrams/dsa/linked-list-2.png)

###### Performance {.smaller}

```{r}
#| echo: false
#| output: asis
#| cache: false

create_table_seq(tbl_df = tbl_df_seq[tbl_df_seq[1] == "linked list", ]) |>
    print_tbl_out(package = package_seq)
```

##### Doubly linked list with tail {.smaller}

![](../../../resources/diagrams/dsa/linked-list-dbl-2.png)

###### {.smaller}

::::::::: {layout="[[45,55]]"}
:::::: {data-latex=""}
- random slots alloted
- object stores the
    - head memory address
    - tail memory address
    - len
- each node stores
    - item
    - memory address of previous node
    - memory address of next node
::::::
:::::: {data-latex=""}
- static operations: linear time ($\Theta(n)$)
- dynamic operations
    - insert/delete first: constant time ($\Theta(1)$)
    - insert/delete last: constant time ($\Theta(1)$)
    - other: linear time ($\Theta(n)$)
- good for implementing **stack** and **queue** with unknown length
    - insert/delete first/last  
      *aka* push/pop/queue/dequeue
::::::
:::::::::

###### Performance {.smaller}

```{r}
#| echo: false
#| output: asis

filter = tbl_df_seq[1] == "linked list" | 
    tbl_df_seq[1] == "doubly linked list w/ tail"
tbl_df_seq[filter,] |>
    create_table_seq() |>
    print_tbl_out(package = package_seq)
```

#### Dynamic array {.smaller}

- Provides faster **insert/delete first/last** operations
- Extra space is alloted at beginning/end
- Idea is to **amortize the cost** of operations by providing extra space
    - when list is full, it is extended by a target **fill ratio**
    - when list is empty, the size is reduced to target **delete ratio**
- Python **list** is a dynamic array, with extra slots alloted both in the beginning and end of container
    - inserting or deleting at first or last position takes $O(1)$ time (averaged over $n$ operations)

![](../../../resources/diagrams/dsa/dyn-array-1.png)

##### Performance {.smaller}

```{r}
#| echo: false
#| output: asis

tbl_df <- tbl_df_seq[tbl_df_seq[1] == "dynamic array",]
tbl_df |>
    create_table_seq() |>
    print_tbl_out(package = package_seq)
```

#### Hash tables

##### Overview {.smaller}

Hash tables are used to implement set interface: **sets** and **dictionaries**.

- Requirement: find items based on keys efficiently
    - arrays find item by looking up memory address based on index
    - in set interface the keys can be strings or other objects
    - search based on item value in array is not fast
- Key idea is to associate/map the keys with non negative integers (index)
    - integers map to memory address
    - given the key, find the associated integer with the key
    - given the integer, find the associated key
- Keys can be numeric, strings or other objects
    - generally, they must be unique

##### Hashing numbers

Taking example of a phone book where the requirements are

- store names and phone numbers
- search by phone number: _hashing numbers_
- search by name: _hashing strings_

######

![](../../../resources/diagrams/dsa/hash-1.png)

###### {.smaller}

- Assuming phone numbers are 15 digit numbers
- $u$ is the set of all possible 15 digit numbers
    - size of universe is $|u| = 10^{15} = `r format(10^15, scientific=FALSE, big.mark=",")`$
    - not possible to store array of this size
    - this makes use of *direct access array* ($|m| = |u|$) impractical
- Let $n$ be the set of numbers to be stored $|n| = ?$, e.g. $|n| \le 1000$
- $m$ is the array of reduced size that you can store
    - choose $|m|$ such that $|n| \le |m|$
    - size of the array is $|m|$, assume $|m| = 1000$
- *Hash function* maps the key from $u \to m$
- *Hash table* is the map of key from $u \to m$
- To search any key takes $\Theta(1)$ time
    - convert the key to array index using hash function
    - access the returned index

##### Collisions and chaining

- Assuming $n = 4$ contacts have to be stored in array of size $|m| = 7$
- Since $|u| >>>> |m|$ ($|u| = 10^{15}$) there will be collisions
    - *collisions*: hash function will give same integer for multiple inputs $h(k_1) = h(k_2)$, where $k_1 \ne k_2$
    - this is by *pigeon hole principle*
- There are 2 methods to resolve the issue of collisions
    - *chaining*: store collisions in a *linked list*
    - *open addressing*: store collisions in next free slot

######

![](../../../resources/diagrams/dsa/hash-2.png)

##### Hashing strings

- Convert characters into integers using ascii or unicode
- There are many methods to combine the codes to form an integer
- Then rest of the problem is similar to hashing numbers
- There are many good solutions available
- To maintain the phone book by both name and number use 2 hash tables  
  One hash table with hash of numbers, other with hash of strings

##### Key requirements for a good hash function

- **Deterministic**: returns same integer for a given key always
- **Fast** to compute: $\Theta(1)$
- Keep the array size ($|m|$) low to **minimize space**
- Keep number of **collisions low**

##### Use cases

- Hash tables have revolutionized searching and can be found everywhere in technology
- Sets and dictionaries are generally implemented using hash table
    - Python `dict` and `set`
- Language interpreter does fast lookup for keywords
- Contact list in phones
- Web and other text searches use hashing
- Applications use hash table for configuration files to search settings

#### Summary

##### Sequence interface {.shrink .smaller}

```{r}
#| echo: false
#| output: asis

print_tbl_out(tbl_out_seq, package_seq)
```

##### Map interface {.shrink .smaller}

```{r}
#| echo: false
#| output: asis

print_tbl_out(tbl_out_map, package_map)
```

### Algorithms

#### Generic

Algorithm is a procedure to solve a problem.

Study of algorithms involves study of finding correct and efficient procedures to solve problems.

#### Algorithms for data structures

An algorithm is a solution to implementing operations like search and sort for a data structure.

An operation for a implementation of a data structure can use any of the compatible algorithms, but not all will be efficient.

For example, for sorting an array merge sort is much quicker than most algorithms.

#### Examples {.fragile .smaller}

```{r}
#| echo: false
#| output: asis
#| cache: false

table_file_path <- "resources/tables/pybcb-tables.xlsx"
sheet <- "dsa-alg" # name or number
package <- "hux"

tbl_df <- readxl::read_excel(here::here(table_file_path), sheet=sheet)

tbl_out <- create_table(tbl_df, package = package) |>
    huxtable::set_markdown(col = 3, row = c(-1), value = FALSE) |>
    huxtable::set_escape_contents(col = 3, row = c(-1), value = FALSE) |>
    huxtable::theme_compact() |>
    huxtable::set_width(1) |>
    huxtable::set_background_color(row = (-1), col = 3,
        value = c(cl$amber, cl$green, cl$red, cl$red, cl$amber))

print_tbl_out(tbl_out, package)
```

## Design: Workflow

#### Overview

Designing workflow in context of programming can be split into 2 dimensions.

- **Program**: micro level, workflow while writing code
- **Project**: macro level, workflow of overall project

#### Program

While writing code there are 2 major dimensions.

- Editing tools: like prediction, linting etc.
    - these only help with basic checks and completion
    - these are managed at project level through editor settings
- Elements of code related to properties of a good program

This part of workflow design is related to the 2nd dimension and is dealt with refactoring.

##### Refactoring

**Refactoring** means reviewing and changing code to attain properties of a good program, without changing the actual output.

Recommended properties of a good program are: **readable**, **testable**, **modular**, **extensible**, **efficient**

Some practical aspects of writing programs are

- There are multiple ways to solve the same problem
- It is a cyclical process of writing code and refactoring
- More often than not, refactoring opportunities become apparent only while reviewing code

##### Recommendations

- Follow naming conventions
- Use doc strings
- Use and follow type annotations
    - make exceptions only if necessary
- Use comments where necessary
- Any task repeated more than a couple of times can be considered to be put into a function
- Functions should have minimum possible responsibilities, ideal is single responsibility
- Use appropriate data types

##### Sample workflow

Below is a workflow for writing code, to cover aspects that editing tools cannot cover.

- Step 1: focus on getting the the code to produce the correct result using recommended practices
- Step 2: review the code for opportunities for refactoring
- Step 3: refactor code
- Step 4: goto step 1

Repeat until needed.

#### Projects

Learning and practising project workflow management from the very start and for smallest of projects is recommended as it has many advantages like

- Workflow becomes operationally more
    - organized
    - efficient

- Reduces errors

- Allows more time on design and thought

- [Python docs: packaging python projects](https://packaging.python.org/en/latest/tutorials/packaging-projects/#packaging-python-projects)

### Tools: Settings

- [VSCode: workspaces](https://code.visualstudio.com/docs/editor/workspaces)
- [VSCode: profiles](https://code.visualstudio.com/docs/editor/profiles)
- [VSCode: tasks](https://code.visualstudio.com/docs/editor/tasks)
- [VSCode: sync](https://code.visualstudio.com/docs/editor/settings-sync)

##### Components {#sec-wkfl-comps}

###### Dependencies

There are 2 key dependencies of a Python project.

- Python version used: document using a `pyproject.toml` file
- External packages and their version used in the project
    - virtual environments provide solutions

###### Python version

- Python, once installed, is machine and os independent.
- Python is available for most of the used computer system and operating system combinations.
- [Python Docs: Packaging: `pyproject.toml`](https://packaging.python.org/en/latest/tutorials/packaging-projects/#configuring-metadata)

###### External packages

- Discussed in virtual environment section in architecture

###### Documentation

- **Doc strings**: document functions, classes
    - [autoDocstring - Python Docstring Generator](https://marketplace.visualstudio.com/items?itemName=njpwerner.autodocstring)
- **Comments**: in the code itself to explain key concepts and logic applied
- `readme.md`: documentation for the project at high level
- [`Sphinx`](https://www.sphinx-doc.org/en/master/)
- Refactoring
    - code structure
    - names

###### Version control

- Regularly maintain `.gitignore` file
    - `.py-venv` folder is large and need not be tracked as it can be restored using requirements file
    - anticipate and add directory and file patterns at the start of the project, it is inefficient to untrack files/folders later
- Do regular structured commits with helpful messages

##### Sample structure {.smaller}

- project root
    - **.git/**
    - **.py-venv/**
    - **docs/**
    - **src/**
        - `inputs.py`
        - `category_1_funcs.py`
        - `category_2_funcs.py`
    - `main.py` or `app.py`
    - `pyproject.toml`
    - `py-requirements.txt`
    - `readme.md`
    - `.gitignore`

# Applications

## Overview
### Background

- _**Why** do you learn computer programming?_ $\to$ **Use cases**
- _**What** is computer programming?_ $\to$ **Theory**: **Building blocks**, **Architecture**, **Design**
- [_**How** do you do computer programming?_ $\to$ **Practical experience**: **Tools**, **Application**]{color="brown"}

### Objectives

- **Application** of theoretical concepts of specifications to solve practical problems
- **Practice** of writing programs
- **Illustrate** some common **use cases**

### Use cases

- **Automate** repetitive manual tasks to
    - increases efficiency
    - reduces errors
- Create **new solutions** using programming, which standard tools do not offer

### Process {.smaller}

- Finding relevant **existing solutions** from **standard library** or **PyPI**
- Understanding
    - how they are structured
    - what are the different ways they can be used
- **Integrating** them with the building blocks and architecture of Python to solve simple tasks
- For getting **help** on specific topic,
    - refer to the **documentation**
    - search the **web**

### Recommendations

- Remember to refactor code
- Do not try to memorize everything, remember where to look for information

## Automation
### Overview

#### Introduction

- Python provides access to lower level system properties
    - file system
    - processes

- Can be used for automation

#### Use cases

- **Project templates**

- **System operations**

- **Pdf operations**

- **Documentation**

- $\cdots$

### System Operations

#### Date time

- Date time is a data structure required for many tasks related to programming.

- [datetime](https://docs.python.org/3/library/datetime.html)

- It is very common to use a needed data structure implemented through standard library and external packages in `PyPI`.

- [Documentation](https://docs.python.org/3/library/datetime.html)
    - [Formatting](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior)

##### Exercise {.smaller}

- Using Jupyter notebook
    - read the system time
    - create strings in following format
        - date stamp: "yyyy-mm-dd"
        - date-time stamp: "yyyy-mm-dd-h-m-s-ms"
        - time stamp: "h-m-s-ms"
    - print time stamps

- This is useful when creating any type of logs
- Date or time stamps need to be inserted in names for files and folders or even text content into files

#### Path manipulations

- [Python standard library](https://docs.python.org/3/library/index.html)
    - [pathlib](https://docs.python.org/3/library/pathlib.html)
    - [os.path](https://docs.python.org/3/library/os.path.html)

##### Mini project

- Using Jupyter notebook
- Store source and destination paths in a variable

###### {.smaller}

- Create a function that
- takes source path as input
- checks if source path is
    - empty: continue
    - non empty: prompt the user with message and confirm whether to continue
- creates the below folder structure in the source path
    - .logs
    - sub_folder_1
        - `file_1.py`
    - sub_folder_2
        - `file_2.py`
    - `.gitignore`
    - `pyproject.toml`

###### {.smaller}

- Create a function that
- takes source and destination paths as input
- checks if the destination path is
    - empty: continue
    - non empty: prompt the user with message and confirm whether to continue
- copies the contents of source in destination without overwriting
    - checks if any file exists before copying
        - copies only if file in source is newer than in destination
        - hint: os.path has getmtime (last modified), getctime (created), getatime (last access)

######

- Call the functions to test everything works
- Notes:
    - Before creating functions you can try small pieces to check how they work. This is typical of write-refactor cycles.
    - This is an example of how to
        - create your own templates for creating boiler plate for repetitive projects and tasks
        - do basic file/folder operations like getting attributes and performing operations

#### File read/write

- [open](https://docs.python.org/3/library/functions.html?highlight=open#open)

- [Python i/o tutorial](https://docs.python.org/3/tutorial/inputoutput.html)

- There are multiple ways to write to file, as illustrated in the tutorial:
    - write plain text to file
    - write and read python objects through `json` or `pickle` package

#####

- For performing read/write operations on **csv**, **excel** and **database** formats:

- Resources
    - Python standard library: [`csv`](https://docs.python.org/3/library/csv.html)
    - [`pandas`](https://pandas.pydata.org/pandas-docs/stable/index.html#)

- For most basic stuff `csv` module is sufficient

##### Mini-project {.smaller .shrink}

- Add below functionality to 'path manipulations' mini project
- 'Datetime' mini project can be used
- create a current date time stamp
- create a file in the .logs folder with name as the current date time stamp
    - open the file and write details
        - number of files copied
        - number of files ignored
- copy the file to destination path .log folder
- **Note**: creating and copying log file is dependent on order of placement in code
    - number of files will have to be adjusted for the new log file created
    - plus care has to be taken to ensure copying the new log file to destination path

#### Creating CLI's

##### Introduction

- Python scripts can be invoked from shell with Python CLI, e.g. `python -m <name>`.

- To create system utilities, it easier to pass input arguments directly from CLI rather than opening and running script to edit the inputs and then run the script.

###### Resources

- Basic: [`sys.argv`](https://docs.python.org/3/tutorial/stdlib.html#command-line-arguments)
- Advanced: `argparse` package in standard library
    - [tutorial](https://docs.python.org/3/howto/argparse.html#argparse-tutorial)
    - [details](https://docs.python.org/3/library/argparse.html#)

- `argparse` is recommended as it is simple to use but can be extended to advanced use cases.

###### Usage

- Once the script can take arguments
    - an alias can be added in `.bashrc` or `.bash_aliases`
        - e.g. `alias cmd1="python3 -m ~/utils/cmd1.py"`
    - Then `cmd1` can be directly used from terminal

##### CLI Project - 1 {.smaller .shrink}

**Project templates**

Create a python package which can be called from CLI using arguments to create a project template for a certain regular task at a specified path.

- use regular package for the project
- name can be for example `<create_data_analysis_template>`
- when called it will create a folder with certain predefined structure and files
    - the template structure can be stored within package folder and copied to any destination required
- input arguments from CLI
    - destination: required, `-d` or `--destination`
    - source: optional, `-s` or `--source`
        - if not provided use the default template folder path within package
    - add time stamp: `-t` or `--timestamp`, optional bool and defaults to true
        - when true: add date time stamp to the destination path name

##### CLI Project - 2 {.smaller .shrink}

**Mirroring Software**

Create a mirroring software implemented as a python cli package with the below features. The idea is to keep a mirror of a folder in a different location.

> Note: This is a bigger project so can be done at relaxed pace, in 2 to 4 weeks.

- cli arguments
    - source: optional with default value, `-s` or `--source`
    - destination: optional with default value, `-d` or `--destination`
    - verbosity: optional with default, `-v` or `--verbosity` with values from a list
    - dry run flag: optional bool defaulting to `false`, `-r` or `--dry-run`

###### {.smaller .shrink}

- make 2 nested dictionaries for source and destination with below features
    - file path
    - file path if it exists in corresponding location else `None`
    - modified time for both source and destination if exists
    - flags
        - both dictionaries: file present in corresponding location
        - in source dictionary: modified time of source is greater than file in destination if present
- operations
    - source dictionary: file copied from source to destination if
        - file is not present in destination, create parent path as required
        - modified time in source is greater than in destination
    - destination dictionary: delete file from destination if it is not in source
        - delete the containing directory if the file is the last file

### Documentation

- Automating documentation can be most rewarding in all setups.

#### Quarto {.smaller .shrink}

- The recommended tool for this is [Quarto](https://quarto.org/)
- Easy to use, seems intimidating but for simple usage it is as easy as writing in Word or Powerpoint
- A lot of options in terms of document export (html, pdf, latex, word, ppt, etc.)
- Good default aesthetics in output with minimal configuration
- Good isolation of aesthetics, structure and content
- Support for table rendering is very advanced, using R packages like `huxtable`, `kableExtra`, `GT`
- Can be used for advanced usage
    - Can include automated calculations, tables, figures
    - Can include dynamic content in websites

#### Other options

- [AsciiDoc](https://asciidoc.org/)
- [Sphinx](https://www.sphinx-doc.org/en/master/)

## Data Analysis
### Background

For all domains knowing basic data analysis using programming is essential.

For engineering and science domains the requirements are higher but the first step is the same.

Therefore, learning to do basic data analysis using programming is a common subset.

### Objectives

- Provide an overview
- Point to resources for further learning

### Data Science

#### Terminology

- Since the field of data is relatively new at this time and evolving very fast, the terminology is not consistent.

- The reasons for this rapid change are rapid advancement in
    - computing capacities
    - storage capacities
    - scope of data collection

#### Definitions

##### Data science

**[Data science]{color="brown"}** is the field of study which is dedicated to studying data, scientifically. This includes all aspects of the data cycle which includes several subjects related to each stage in cycle, which may require applying knowledge of several other supporting subjects like math, computer science (software and hardware), domain specific knowledge, process and operations, etc.

##### Data analytics

**[Data Analytics]{color="brown"}** is the skill to apply advanced math techniques, like statistics, machine learning and artificial intelligence, to model data to do predictive and prescriptive analysis using data.

##### Data Analysis

**[Data analysis]{color="brown"}** is the skill to do basic static analysis using data which answers questions related to past and present. This involves very basic math.

#### Data cycle {.shrink}

![](../../../resources/diagrams/data-analysis/data-cycle.png){height="5in" fig-align="center"}

##### {.smaller .shrink}

At small scale, one person might work on all elements. e.g. college projects requiring some analysis in which all stages can be performed using spreadsheets and programming.

At large scale, there might be multiple teams working on a single element. e.g. in a bank

- **Design**: All teams involved contribute to discussions
- **Collection**: All customers and several departments have access to corresponding applications which feed data to bank's database servers
- **Storage & Processing**:
    - There are multiple teams to perform validations and adjustments for loaded data coming in from different sources
    - There are separate teams for managing database servers
- **Analysis**: There are multiple teams across multiple functions analyzing data
- **Reporting**: There are multiple reporting teams
- **Decision**: Business teams

##### Design {.smaller .shrink}

Design stage involves using knowledge of all the components, the target is to capture every aspect preemptively. For a large recurring project it might mean involvement of a large number of teams specialized in specific areas of the the data cycle.

Every data related project starts with designing decision stage, framing good questions that drive the project, but then it is an iterative process.

##### Collection

- **Spreadsheets**
- **Web interface**
- **Desktop application**

##### Storage & Processing

- **Storage**: excel, text files, database
- **Processing**
    - Extract Transform Load (ETL) processes
    - pre processing
        - resolving duplicates
        - bad data values
        - missing data values

##### Analysis {.smaller .shrink}

- **Static**: answers simple questions using historical data
    - what has happened in the past?
    - what is the current state?
    - what is driving the current state?

- **Predictive**: answers more complex questions using math (probability and statistics)
    - what would happen in future given a scenario?
    - static models

- **Prescriptive**: answers more complex questions using math (probability and statistics)
    - predict various scenarios
    - answer, what should be done to ensure desired results?
    - static models, more advanced than predictive models

- **Machine learning**, **Artificial intelligence**: come up with models based on data
    - models train themselves based on data

#####

- **Operational Process**
    - Extract
    - Clean
    - Analyze
    - Model

- **Visualization** is part and key component of data analysis

##### Communication

- Components
    - tables
    - visualization
    - theory: how you arrived at the results
    - analysis: key findings
    - recommendations
- Tools: documentation using programming

##### Decision

- Check if results are satisfactory, if not re-design in next cycle
- If there are new questions or findings, re-design in next cycle

### Learning paths

#### Data analysis

#####

Data analysis is generic and applicable to all domains. It requires to learn the basic usage of 

- Data storage technologies: spreadsheets, comma separated files, databases
- Data analysis using programming
    - import data in to a data structure on heap (RAM)
    - operate on data
    - visualization
    - documentation of analysis and results

#####

Steps involved in data analysis using programming

- Import data from excel, csv or txt files, database
- Clean data
- Analyze data by performing operations and visualization
- Document analysis and results

#### Data analytics

Data analytics is relevant for science and engineering fields. Data analysis is a pre-requisite for this. Additionally it requires learning more about below topics for coming up with models for prediction, prescription or machine learning and artificial intelligence.

- Math: statistics, machine learning, neural networks, etc.
- Advanced knowledge of technologies used, including programming

### Data analysis in Python {.smaller .shrink}

- [pandas](https://pandas.pydata.org/)
- [Python4DS](https://aeturrell.github.io/python4DS/welcome.html)
- [Python for Data Analysis, 3E](https://wesmckinney.com/book/)

Note that the resources are meant for the STEM audience so not everything will be in scope for generic audience. Still some initial chapters that focus on basic data analysis should be useful.
